<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Printer Utils</title>
<meta name="author" content="issypup">
<meta name="date" content="2025-08-10">
<style>
  :root { --bar-h: 42px; }
  body {
    font-family: sans-serif;
    padding: calc(var(--bar-h) + 12px) 12px 56px;
    background: #f4f4f4;
  }
  h1, h2 { margin-top: 1rem; }
  table { border-collapse: collapse; margin-top: 0.5rem; }
  td, th { border: 1px solid #ccc; padding: 0.4rem; text-align: center; }
  input[type="number"], input[type="text"] { width: 100px; }
  button { padding: 0.45rem 0.9rem; margin: 0.25rem 0.25rem 0.25rem 0; cursor: pointer; }
  .tighten { background: #ffe0e0; }
  .loosen  { background: #e0f0ff; }
  .na      { background: #eaeaea; }
  .gap { border: none; background: transparent; color: #888; font-weight: bold; }
  #screwMap td { width: 110px; height: 60px; vertical-align: top; font-size: 0.85em; }

  /* Status bar (always visible) */
  #statusBar {
    position: fixed; top: 0; left: 0; right: 0; height: var(--bar-h);
    background: #222; color: #fff; display: flex; align-items: center;
    gap: 12px; padding: 0 12px; z-index: 9999; font-weight: 600;
  }
#statusBar .pill { 
  /* background:#444; */  /* remove this line if needed */
  transition: background-color 200ms ease, filter 200ms ease, transform 200ms ease;
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 10px; border-radius:999px; font-weight:600;
}

/* state colors – more specific than #statusBar .pill */
#statusBar .pill.idle    { background:#555; }     /* no target / idle */
#statusBar .pill.ready   { background:#2ecc71; }  /* green, stable */
#statusBar .pill.heating { background:#e74c3c; }  /* red, heating */
#statusBar .pill.cooling { background:#3498db; }  /* blue, cooling */
#statusBar .pill.offline { background:#444; color:#fff; }
#statusBar .pill.pid { background:#f39c12; } /* orange */

/* pulse effect (used for heating/cooling) */
.pulse { animation: pillPulse 1.0s ease-in-out infinite; }
@keyframes pillPulse {
  0%   { transform:none; filter:brightness(100%); }
  50%  { transform:scale(1.05); filter:brightness(115%); }
  100% { transform:none; filter:brightness(100%); }
}

/* keep hotend/bed pills nicely spaced */
#temps { display: inline-flex; gap: 24px; }

  #statusBar .ok    { background: #2a7; }
  #statusBar .warn  { background: #f39c12; }
  #statusBar .bad   { background: #c0392b; }

  /* Tabs */
  #tabButtons { display:flex; flex-wrap: wrap; gap:6px; margin: 8px 0 4px; }
  #tabButtons button {
    padding: 0.45rem 1rem; cursor: pointer; background: #eee; border: 1px solid #ccc;
  }
  #tabButtons button.active { background: #ddd; font-weight: bold; }
  .tabContent { display: none; }
  .tabContent.active { display: block; }

  /* Controls rows inside tabs */
  .tabControls { display:flex; flex-wrap:wrap; gap:8px; margin: 8px 0 8px; align-items: center; }

  /* Printer log */
  #printerLog {
    background:#111; color:#ddd; border:1px solid #333;
    height: 220px; overflow:auto; padding:8px; white-space:pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    border-radius: 6px;
  }

#printerName.editable {
  cursor: pointer;
}
#printerName.editable:hover {
  text-decoration: underline;
}

  /* Footer status */
  #footerStatus {
    position: fixed; bottom: 0; left: 0; right: 0;
    background: #222; color: #fff; padding: 6px 10px;
    display:flex; justify-content: space-between; font-size: 0.9em;
  }

#aboutTab .aboutCard {
  background: #fff;
  border: 1px solid #ddd;
  padding: 16px 18px;
  border-radius: 8px;
  max-width: 560px;
  margin: 20px auto;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

#aboutTab .aboutCard h2 {
  margin: 0 0 10px;
  font-size: 1.3em;
  color: #333;
  border-bottom: 2px solid #eee;
  padding-bottom: 6px;
}

#aboutTab .aboutCard p { margin: 10px 0 0; color: #555; }

#aboutTab .kv {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  margin-top: 8px;
  font-size: 0.95em;
}
#aboutTab .kv span:first-child { color: #666; }
#aboutTab .kv span:last-child  { font-weight: 600; color: #111; }

  /* Small UI helpers */
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .col { display:flex; flex-direction:column; gap:6px; }
  .box { background:#fff; border:1px solid #ddd; padding:8px; border-radius:6px; }
  .label { font-weight:600; }
  .muted { color:#666; font-size:0.9em; }
  .widen { width: 220px; }
  .progress { height: 10px; background:#ddd; border-radius:999px; overflow:hidden; width:280px; }
  .progress > div { height:100%; background:#2a7; width:0%; }

#preOverlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000;
}
#preModal   {
  position: fixed; inset: 0; display: none; place-items: center; z-index: 10001;
}
#preCard    {
  width: min(720px, 92vw); max-height: 80vh; background:#fff; border:1px solid #ddd;
  border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.25);
  display:grid; grid-template-rows:auto 1fr;
}
#preHeader  { display:flex; align-items:center; justify-content:space-between; gap:12px;
  padding:12px 14px; border-bottom:1px solid #eee; }
#preBody    { padding:14px 16px; overflow:auto; line-height:1.35; }
#preClose   { background:#eee; border:1px solid #ccc; padding:6px 10px; border-radius:8px; cursor:pointer; }
#preClose:hover { background:#e5e5e5; }


  /* EE Modal */
#eeOverlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 10000;
}

#eeModal {
  position: fixed; inset: 0;
  display: none;           /* toggled by JS */
  place-items: center;     /* grid centering */
  z-index: 10001;
}

#eeCard {
  width: min(720px, 92vw);
  max-height: 80vh;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.25);
  display: grid;
  grid-template-rows: auto 1fr;
}

#eeHeader {
  display: flex; align-items: center; justify-content: space-between;
  gap: 12px;
  padding: 12px 14px;
  border-bottom: 1px solid #eee;
}

#eeBody {
  padding: 14px 16px;
  white-space: pre-wrap;   /* preserve line breaks */
  overflow: auto;
  line-height: 1.35;
}

#eeClose {
  background: #eee; border: 1px solid #ccc;
  padding: 6px 10px; border-radius: 8px; cursor: pointer;
}
#eeClose:hover { background:#e5e5e5; }

#liveChart { width: 100%; height: 260px; display: block; }
</style>
</head>
<body>

<!-- Global Status Bar -->
<div id="statusBar">
  <span id="printerName" class="editable">PRINTER</span>
  <span id="connBadge" class="pill bad">Disconnected</span>
  <span id="activityBadge" class="pill">Idle</span>
  <span id="lastUpdated" class="pill">Last updated: —</span>
<span id="temps">
  <span class="pill idle" id="topHotendPill">Hotend: <span id="topHotend">--°C</span></span>
  <span class="pill idle" id="topBedPill">Bed: <span id="topBed">--°C</span></span>
</span>
<span id="etaPill" class="pill" style="display:none;">ETA: —</span>
<span id="netPill" class="pill" title="Live serial throughput and OK latency">
  TX — · RX — · Lat —
</span>
</div>

<h1>3D Printer Utils</h1>

<!-- Tabs -->
<div id="tabButtons">
  <button data-tab="connectTab" class="active">Connection & Log</button>
  <button data-tab="levelTab">Leveling</button>
  <button data-tab="pidTab">PID Tuning</button>
  <button data-tab="tempTab">Temperature & Fan</button>
  <button data-tab="moveTab">Movement & Axes</button>
  <button data-tab="eepromTab">EEPROM / Config</button>
  <button data-tab="maintTab">Maintenance</button>
  <button data-tab="diagTab">Diagnostics</button>
  <button data-tab="senderTab">G-code Sender</button>
  <button data-tab="aboutTab">About</button>
</div>

<!-- TAB 1: Connection & Log -->
<div id="connectTab" class="tabContent active">
  <div class="tabControls" id="printerNavConnect">
    <label style="margin-left:8px;">
  <input type="checkbox" id="debugToggle">
  Debug
</label>
<label style="margin-left:8px;">
  <input type="checkbox" id="virtualToggle">
  Virtual printer
</label>
<label style="margin-left:8px;">
  Baud:
  <select id="baudSelect">
    <option value="auto" selected>Auto-detect</option>
    <option value="250000">250000</option>
    <option value="115200">115200</option>
    <option value="230400">230400</option>
    <option value="500000">500000</option>
    <option value="1000000">1000000</option>
    <option value="57600">57600</option>
  </select>
</label>
    <button id="connectBtn">Connect</button>
    <button id="disconnectBtn" disabled>Disconnect</button>
    <input id="manualCmd" placeholder="Manual G-code (e.g., M503)" />
    <button id="sendCmdBtn" disabled>Send</button>
    <button id="clearLogBtn" disabled>Clear Log</button>
  </div>

  <h2>Printer Log</h2>
  <div id="printerLog" aria-live="polite"></div>
</div>

<!-- TAB 2: Leveling -->
<div id="levelTab" class="tabContent">
<div class="tabControls" id="printerNavLevel">
  <button id="readMeshBtn" disabled>Home &amp; Probe (G28 → G29 T)</button>
  <button type="button" id="exportMeshBtn">Export Mesh</button>

  <label style="margin-left:auto">
    Printer:
    <select id="levelPrinterSelect">
      <option value="cr6se" selected>CR-6 SE</option>
      <option value="unsupported">Unsupported</option>
    </select>
  </label>
</div>

  <!-- NEW: message for unsupported printers -->
  <div id="unsupportedMsg" class="box" style="display:none; max-width:560px">
    <strong>Printer unsupported.</strong>
    <div class="muted">Leveling helpers are currently only available for the CR-6 SE.</div>
  </div>

  <!-- Wrap all CR-6 SE specific UI so we can show/hide it easily -->
  <div id="cr6seLevelWrap">
    <!-- Mesh Form (manual + populated from printer) -->
    <form id="levelForm">
      <h2>Enter / View Mesh Readings</h2>
      <table><tbody id="meshInput"></tbody></table>
      <button type="submit">Submit Round</button>
      <button type="button" id="resetBtn">Reset Data</button>
    </form>

    <h2>Screw Suggestions</h2>
    <table>
      <thead>
        <tr><th>Screw</th><th>Avg (mm)</th><th>Action</th><th>Turn Strength</th></tr>
      </thead>
      <tbody id="screwTable"></tbody>
    </table>

    <h2>Screw Layout Map</h2>
    <table id="screwMap">
      <tr>
        <td id="A1"></td>
        <td class="gap">GAP</td>
        <td id="A2"></td>
        <td id="A3"></td>
      </tr>
      <tr>
        <td id="B1"></td>
        <td id="B2"></td>
        <td id="B3"></td>
        <td id="B4"></td>
      </tr>
      <tr>
        <td id="C1"></td>
        <td id="C2"></td>
        <td id="C3"></td>
        <td id="C4"></td>
      </tr>
    </table>
  </div>
</div>

<!-- TAB 3: PID Tuning -->
<div id="pidTab" class="tabContent">
  <div class="tabControls" id="printerNavPID">
    <button id="bedPidBtn"    disabled>PID Bed (M303 E-1)</button>
    <button id="hotendPidBtn" disabled>PID Nozzle (M303 E0)</button>
  </div>
  <p>Runs <code>M303</code> autotune with a temperature you choose. After it completes, send <code>M500</code> if your firmware needs it to save to EEPROM.</p>
</div>

<!-- TAB 4: Temperature & Fan -->
<div id="tempTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Hotend</div>
      <div>
        <input type="number" id="hotendSet" value="200" min="0" max="300" /> °C
        <button id="hotendApply" disabled>Set (M104)</button>
        <button id="hotendOff"   disabled>Off (M104 S0)</button>
      </div>
      <div class="muted" id="hotendNow">Current: —</div>
    </div>
    <div class="col">
      <div class="label">Bed</div>
      <div>
        <input type="number" id="bedSet" value="60" min="0" max="130" /> °C
        <button id="bedApply" disabled>Set (M140)</button>
        <button id="bedOff"   disabled>Off (M140 S0)</button>
      </div>
      <div class="muted" id="bedNow">Current: —</div>
    </div>
    <div class="col">
      <div class="label">Part Cooling Fan</div>
      <div>
        <input type="range" id="fanSlider" min="0" max="255" value="0" />
        <span id="fanVal">0</span>/255
      </div>
      <div>
        <button id="fanApply" disabled>Apply (M106)</button>
        <button id="fanOff"   disabled>Off (M107)</button>
      </div>
    </div>
  </div>
  <div class="box">
  <div class="label">Live Telemetry (last 10 min)</div>
  <canvas id="liveChart" width="900" height="260" aria-label="Live temperatures, fan %, and M73 %"></canvas>
  <div class="muted">Left axis: °C · Right axis: % (Fan, M73)</div>
</div>
  <div class="row box">
<div class="col">
  <div class="label">Safety</div>
  <button id="unlockTempsBtn" type="button">Unlock high hotend temps</button>
  <div class="muted" id="unlockHint">Guardrail ON — max 250°C</div>
</div>
    <div class="muted">Polled via M105 every 3s while connected</div>
  </div>
</div>

<!-- TAB 5: Movement & Axes -->
<div id="moveTab" class="tabContent">
  <div class="row box">
    <div>
      <span class="label">Step</span>
      <select id="jogStep">
        <option value="1">1 mm</option>
        <option value="5" selected>5 mm</option>
        <option value="10">10 mm</option>
      </select>
    </div>
    <div>
      <button id="homeAll" disabled>Home All (G28)</button>
      <button id="disableMotors" disabled>Disable Steppers (M84)</button>
    </div>
  </div>
  <div class="row box">
    <div class="col">
      <div class="label">Move X</div>
      <button id="xMinus" disabled>◀ X-</button>
      <button id="xPlus"  disabled>X+ ▶</button>
    </div>
    <div class="col">
      <div class="label">Move Y</div>
      <button id="yMinus" disabled>▼ Y-</button>
      <button id="yPlus"  disabled>▲ Y+</button>
    </div>
    <div class="col">
      <div class="label">Move Z</div>
      <button id="zMinus" disabled>Z-</button>
      <button id="zPlus"  disabled>Z+</button>
    </div>
    <div id="axisPositions">
  <div>X: <span id="posX">—</span></div>
  <div>Y: <span id="posY">—</span></div>
  <div>Z: <span id="posZ">—</span></div>
</div>
  </div>
  <div class="row box">
    <button id="parkHead" disabled>Park Head (X0 Y0 Z10)</button>
  </div>
</div>

<!-- TAB 6: EEPROM / Config -->
<div id="eepromTab" class="tabContent">
  <div class="row box">
    <button id="readCfg" disabled>Read Config (M503)</button>
    <button id="saveCfg" disabled>Save (M500)</button>
    <!-- <button id="resetCfg" disabled>Factory Reset (M502)</button>-->
  </div>
  <textarea id="configBox" class="widen" rows="14" placeholder="Printer configuration will appear here…"></textarea>
</div>

<!-- TAB 7: Maintenance -->
<div id="maintTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Preheat</div>
      <button id="preheatPLA"  disabled>PLA (200/60)</button>
      <button id="preheatPETG" disabled>PETG (240/80)</button>
      <button id="preheatABS"  disabled>ABS (250/100)</button>
    </div>
    <div class="col">
      <div class="label">Cool Down</div>
      <button id="cooldown" disabled>Cool Down (M104 S0; M140 S0)</button>
    </div>
    <div class="col">
      <div class="label">Filament</div>
      <button id="loadFil"  disabled>Load (200°C)</button>
      <button id="unloadFil" disabled>Unload (200°C)</button>
    </div>
        <div class="col">
      <div class="label">Nozzle Prep</div>
      <button id="primeLine" disabled>Wipe + Prime Line</button>
    </div>
  </div>
</div>

<!-- TAB 8: Diagnostics -->
<div id="diagTab" class="tabContent">
  <div class="row box">
    <button id="fwInfo" disabled>Firmware Info (M115)</button>
    <button id="tmcDiag" disabled>TMC Diagnostics (M122)</button>
  </div>
  <textarea id="diagBox" class="widen" rows="14" placeholder="Diagnostics output…"></textarea>
</div>

<!-- TAB 9: G-code Sender -->
<div id="senderTab" class="tabContent">
  <div class="row box">
    <input type="file" id="gcodeFile" accept=".gcode,.gco,.gc,.txt" />
    <button id="sendGcode" disabled>Send File</button>
    <button id="cancelSend" disabled>Cancel</button>
    <div class="progress"><div id="sendProgress"></div></div>
    <span id="sendStatus" class="muted">Idle</span>
    <span id="etaStatus" class="muted" style="margin-left:10px"></span>
  </div>
  <p class="muted">Sends the file line-by-line over serial. Comments/blank lines are skipped. This is best for short jobs, calibration, or macros.</p>
  <!-- Preflight Modal -->
<div id="preOverlay" aria-hidden="true" style="display:none"></div>
<div id="preModal" role="dialog" aria-modal="true" aria-labelledby="preTitle" style="display:none">
  <div id="preCard">
    <div id="preHeader">
      <h3 id="preTitle">Pre-flight checks</h3>
      <button id="preClose" type="button" aria-label="Close">Close</button>
    </div>
    <div id="preBody">
      <div class="muted" style="margin-bottom:8px">
        File: <strong id="preFileName">—</strong> ·
        Guardrail: <strong id="preGuardrail">—</strong> ·
        Temps (hot/bed): <strong id="preTemps">—</strong> ·
        Mode: <strong id="preMode">—</strong> ·
        Homed: <strong id="preHomed">—</strong>
      </div>

      <fieldset style="border:none; padding:0; margin:0 0 8px 0;">
        <legend class="label" style="margin-bottom:6px">Confirm all:</legend>
        <label><input type="checkbox" class="preChk" id="chkBedClear"> Bed is clear (no clips, tools, hands, pets 🐱)</label><br>
        <label><input type="checkbox" class="preChk" id="chkObstructions"> Gantry path clear (cables, spool, camera arms)</label><br>
        <label><input type="checkbox" class="preChk" id="chkFilament"> Correct filament loaded & nozzle clean</label><br>
        <label><input type="checkbox" class="preChk" id="chkAdhesion"> Adhesion ready (sheet, glue, texture)</label><br>
        <label><input type="checkbox" class="preChk" id="chkZSafe"> Z head parked safely (≥10 mm)</label>
      </fieldset>

      <div class="row" style="margin:8px 0 12px">
        <button id="preHome" type="button">Home Now (G28)</button>
        <button id="prePark" type="button">Park Head (X0 Y0 Z10)</button>
        <label style="margin-left:auto">
          <input type="checkbox" id="preSkip"> Don’t ask again (this session)
        </label>
      </div>

      <div class="row" style="justify-content:flex-end; gap:8px">
        <button id="preCancel" type="button">Cancel</button>
        <button id="preStart"  type="button" disabled>Start Print</button>
      </div>
    </div>
  </div>
</div>

</div>

<!-- TAB 10: About -->
<div id="aboutTab" class="tabContent">
  <div class="aboutCard">
    <h2>About</h2>
    <div class="kv"><span>Author: issypup</span></div>
    <div class="kv"><span>Date: 10 August 2025</span></div>
    <p>This tool helps manage 3D printer tasks / maintenance from your browser, it needs a web serial capable browser</p>
  </div>
<!-- Easter Egg Modal -->
<div id="eeOverlay" aria-hidden="true" style="display:none"></div>
<div id="eeModal" role="dialog" aria-modal="true" aria-labelledby="eeTitle" style="display:none">
  <div id="eeCard">
    <div id="eeHeader">
      <h3 id="eeTitle">Still Printing — (Still Alive Parody)</h3>
      <button id="eeClose" type="button" aria-label="Close">Close</button>
    </div>
    <div id="eeBody"></div>
  </div>
</div>
</div>



<div id="footerStatus">
  <span id="lastCmd">Last Cmd: —</span>
  <span>GitHub Pages ready · LocalStorage only</span>
</div>

<script>
'use strict';

/* =========================================================
   1) DOM REFERENCES (all const)
========================================================= */


const BEEP_BROWSER_ON = true;   // browser chime via Web Audio
const BEEP_PRINTER_ON = false;  // send M300 to the printer (off by default)
const primeLine = document.getElementById('primeLine');


//Toggles and core controls
const debugToggle     = document.getElementById('debugToggle');
const virtualToggle = document.getElementById('virtualToggle');
const connectBtn      = document.getElementById('connectBtn');
const disconnectBtn   = document.getElementById('disconnectBtn');
const sendCmdBtn      = document.getElementById('sendCmdBtn');
const clearLogBtn     = document.getElementById('clearLogBtn');

//Log/UI text
const printerLog      = document.getElementById('printerLog');
const lastUpdated     = document.getElementById('lastUpdated');
const lastCmd         = document.getElementById('lastCmd');
const activityBadge   = document.getElementById('activityBadge');
const connBadge       = document.getElementById('connBadge');
const printerNameEl = document.getElementById('printerName');

//Top status pills
const topHotendPill   = document.getElementById('topHotendPill');
const topBedPill      = document.getElementById('topBedPill');
const topHotendText   = document.getElementById('topHotend');
const topBedText      = document.getElementById('topBed');
const etaPill = document.getElementById('etaPill');

//Manual G-code
const manualCmd       = document.getElementById('manualCmd');

//Leveling UI
const readMeshBtn     = document.getElementById('readMeshBtn');
const exportMeshBtn   = document.getElementById('exportMeshBtn');
const meshInput       = document.getElementById('meshInput');
const screwTable      = document.getElementById('screwTable');
const levelPrinterSelect = document.getElementById('levelPrinterSelect');
const unsupportedMsg     = document.getElementById('unsupportedMsg');
const cr6seLevelWrap     = document.getElementById('cr6seLevelWrap');
const resetBtn        = document.getElementById('resetBtn');

//PID UI
const bedPidBtn       = document.getElementById('bedPidBtn');
const hotendPidBtn    = document.getElementById('hotendPidBtn');

//Temps and fan
const hotendSet       = document.getElementById('hotendSet');
const bedSet          = document.getElementById('bedSet');
const hotendApply     = document.getElementById('hotendApply');
const hotendOff       = document.getElementById('hotendOff');
const bedApply        = document.getElementById('bedApply');
const bedOff          = document.getElementById('bedOff');
const hotendNow       = document.getElementById('hotendNow');
const bedNow          = document.getElementById('bedNow');
const fanSlider       = document.getElementById('fanSlider');
const fanVal          = document.getElementById('fanVal');
const fanApply        = document.getElementById('fanApply');
const fanOff          = document.getElementById('fanOff');
const unlockTempsBtn = document.getElementById('unlockTempsBtn');
const unlockHint     = document.getElementById('unlockHint');
const MAX_HOTEND = 250;
const MAX_BED    = 110;

//Movement UI
const jogStep         = document.getElementById('jogStep');
const homeAll         = document.getElementById('homeAll');
const disableMotors   = document.getElementById('disableMotors');
const xMinus          = document.getElementById('xMinus');
const xPlus           = document.getElementById('xPlus');
const yMinus          = document.getElementById('yMinus');
const yPlus           = document.getElementById('yPlus');
const zMinus          = document.getElementById('zMinus');
const zPlus           = document.getElementById('zPlus');
const parkHead        = document.getElementById('parkHead');
const posXEl          = document.getElementById('posX');
const posYEl          = document.getElementById('posY');
const posZEl          = document.getElementById('posZ');

//eeprom and Config
const readCfg         = document.getElementById('readCfg');
const saveCfg         = document.getElementById('saveCfg');
const configBox       = document.getElementById('configBox');

//Diagnostics
const fwInfo          = document.getElementById('fwInfo');
const tmcDiag         = document.getElementById('tmcDiag');
const diagBox         = document.getElementById('diagBox');

//Sender
const gcodeFile       = document.getElementById('gcodeFile');
const sendGcode       = document.getElementById('sendGcode');
const cancelSend      = document.getElementById('cancelSend');
const sendProgress    = document.getElementById('sendProgress');
const sendStatus      = document.getElementById('sendStatus');

//Maintenance controls
const preheatPLA      = document.getElementById('preheatPLA');
const preheatPETG     = document.getElementById('preheatPETG');
const preheatABS      = document.getElementById('preheatABS');
const cooldown        = document.getElementById('cooldown');
const loadFil         = document.getElementById('loadFil');
const unloadFil       = document.getElementById('unloadFil');

//Easter egg
  const eeOverlay = document.getElementById('eeOverlay');
  const eeModal   = document.getElementById('eeModal');
  const eeClose   = document.getElementById('eeClose');
  const eeBody    = document.getElementById('eeBody');

/* =========================================================
   2) CONSTANTS (maps, regex, fixed values)
========================================================= */

const HOME_SIG_DEFAULT = { x: 117, y: 117, z: 10.0, tolX: 2.0, tolY: 2.0, tolZ: 4.0 };







//Mesh and screws map
const screwAffects = {
  A1: [[0,0],[0,1],[1,0],[1,1]],
  A2: [[0,1],[0,2],[1,1],[1,2]],
  A3: [[0,2],[0,3],[1,2],[1,3]],
  B1: [[1,0],[1,1],[2,0],[2,1]],
  B2: [[1,1],[1,2],[2,1],[2,2]],
  B3: [[1,2],[1,3],[2,2],[2,3]],
  B4: [[2,3],[1,3],[3,3]],
  C1: [[2,0],[2,1],[3,0],[3,1]],
  C2: [[2,1],[2,2],[3,1],[3,2]],
  C3: [[2,2],[2,3],[3,2],[3,3]],
  C4: [[3,3]]
};

//Regex
const NOISY_REGEX = /^(?:echo:busy:\s*processing|\/\/action:.*|setnewscreen(?:\s*\([^)]*\))?:?.*|invoking handler for screen.*)/i;
const POS_REGEX   = /X:?\s*([+-]?\d*\.?\d+)\s+Y:?\s*([+-]?\d*\.?\d+)\s+Z:?\s*([+-]?\d*\.?\d+)/i;

//const TEMP_T = /T\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;
//const TEMP_B = /B\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;

const TEMP_T = /\bT\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;
const TEMP_B = /\bB\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;

const TELEMETRY_REGEX =
  /(?:\bT\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\bB\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\b@:\s*\d+)|(?:\bB@:\s*\d+)/i;

//Ambient-detection tuning
const AMBIENT_WINDOW_SEC   = 300;   // track last 5 minutes
const AMBIENT_MIN_SEC      = 240;   // require at least 4 minutes observed
const AMBIENT_MAX_SPREAD   = 0.8;   // max range (°C) over window (±0.4°C)
const AMBIENT_MAX_SLOPE    = 0.01;  // °C per second (~0.6°C/min) max drift

//Buffers
const _ambientBuf = { hot: [], bed: [] }; // arrays of [tsSec, temp]

//Virtual data
const mockMesh = [
  "Bed Topography Report:",
  "    0      1      2      3",
  "0  +0.025  +0.013  -0.002  -0.020",
  "1  +0.018  +0.005  -0.010  -0.022",
  "2  +0.030  +0.015  +0.003  -0.015",
  "3  +0.035  +0.020  +0.010  -0.012",
  "ok"
];

//Virtual printer state object
const vState = {
  hot: 25, hotTarget: null,
  bed: 25, bedTarget: null,
  x: 0, y: 0, z: 0
};

/* =========================================================
   3) STATE (all let)
========================================================= */




let lastHomeHintAt = 0;  // when we last saw a "homing-ish" line

let _audioCtx = null;

let _preflightFile = null;

let net = {
  txBytesTotal: 0,
  rxBytesTotal: 0,
  txSince: 0,
  rxSince: 0,
  lastSample: performance.now(),
  txRate: 0,
  rxRate: 0,
  latencyEMA: null,   // ms
  timer: null
};

let lastSendTs = null; 

let heaterUnlocked = JSON.parse(localStorage.getItem('heaterUnlocked') || 'false');








//UI and State flags
let debugMode      = JSON.parse(localStorage.getItem('debugMode') || 'false');
let criticalDepth = 0;
let pidActiveHotend = false;
let pidActiveBed    = false;
let pidTarget = null; // 'hotend', 'bed', or null
let isHomed = false;

// Leveling / Probing flow control
let probeLatch = null; // resolved when G29 T finishes (grid header or DWIN “Settings Stored”)

//Mesh and Temps
let meshScratch    = Array.from({ length: 4 }, () => Array(4).fill(null));
let temps          = { hot: null, hotTarget: null, bed: null, bedTarget: null };

//Connection lifecycle
let connKind = 'none'; // 'none' | 'virtual' | 'real'
let isConnecting = false;
let isDisconnecting = false;

//Serial — device handles
let port           = null;
let reader         = null;
let writer         = null;
let textDecoder    = null;

//Comms - I/O state, buffers, timers
let reading        = false;
let rxBuffer       = '';
let cancelStream   = false;
let captureMode    = null; // null | 'config' | 'diag'
let tempTimer      = null;
let postPrintTimer = null;

//Read and Telemetry
let waitingResolvers = []; // (kept for compatibility)
let isBusyProcessing  = false;
let lastOkAt          = 0;
let pendingOk      = []; // queue for waitForOk()

//Virtual printer
let virtualMode = false;
let vSimTimer = null;

//Easter Egg
let streak = 0;

/* =========================================================
   4) TABS BOOTSTRAP (runs once)
========================================================= */
(function initTabs(){
  document.querySelectorAll('#tabButtons button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const target = btn.getAttribute('data-tab');
      sessionStorage.setItem('currentTab', target);
      document.querySelectorAll('.tabContent').forEach(tab => {
        tab.classList.toggle('active', tab.id === target);
      });
    });
  });
  const savedTab = sessionStorage.getItem('currentTab');
  if (savedTab && document.getElementById(savedTab)) {
    document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
    document.querySelector(`#tabButtons button[data-tab="${savedTab}"]`)?.classList.add('active');
    document.querySelectorAll('.tabContent').forEach(tab => {
      tab.classList.toggle('active', tab.id === savedTab);
    });
  }
})();

/* =========================================================
   5) HELPERS (pure UI / formatting / state)
========================================================= */


















function getHomeSig() {
  try { return JSON.parse(localStorage.getItem('homeSig')) || HOME_SIG_DEFAULT; }
  catch { return HOME_SIG_DEFAULT; }
}
function setHomeSig(sig) {
  localStorage.setItem('homeSig', JSON.stringify(sig));
}

// Call on every incoming log line to update the “hint” window
function maybeMarkHomingHint(line) {
  if (/\b(Homing|Home\s+all|Taring probe|Preheating)\b/i.test(line)) {
    lastHomeHintAt = performance.now();
  }
}

// Call when you parse a position to decide if we’re homed
function maybeMarkHomedFromPos(x, y, z) {
  const now = performance.now();

  // If we saw a homing-ish line very recently, trust this as homed
  if (now - lastHomeHintAt < 4000) {
    isHomed = true;
    return;
  }

  // Otherwise, compare to a known "home signature" with tolerance
  const sig = getHomeSig();
  const near =
    Math.abs(x - sig.x) <= sig.tolX &&
    Math.abs(y - sig.y) <= sig.tolY &&
    Math.abs(z - sig.z) <= sig.tolZ;

  if (near) isHomed = true;
}

// (optional) learn & persist your printer’s home signature after a known-good G28
function learnHomeSignature(x, y, z) {
  setHomeSig({ x, y, z, tolX: 2.0, tolY: 2.0, tolZ: 4.0 });
}

// === Nozzle Wipe + Prime Line (staged warmup, safe home, purge, cool, exit) ===
async function runPrimeLine() {
  cancelStream = false; // ← clear leftover cancel flag from a previous send
  const HOT_FINAL = 200;
  const BED_FINAL = 60;

  try {
    setActivity('Nozzle prep…', 'warn');

    // Restore mesh & motion defaults
    await sendCmdsSequential(
      'M420 S1',
      'M201 X500.00 Y500.00 Z100.00 E5000.00',
      'M203 X500.00 Y500.00 Z10.00 E50.00',
      'M204 P500.00 R1000.00 T500.00',
      'M205 X8.00 Y8.00 Z0.40 E5.00',
      'M220 S100',
      'M221 S100'
    );

    // Staged warmup to avoid droop before homing (per your script)
    await sendCmd('M190 S50');            await waitForOk(); // bed to 50 (wait)
    await sendCmd('M140 S65');            await waitForOk(); // bed target 65 (no wait)
    await sendCmd('M104 S120');           await waitForOk(); // nozzle 120 (no wait)
    await sendCmd('M190 S65');            await waitForOk(); // bed to 65 (wait)
    await sendCmd('M109 S145');           await waitForOk(); // nozzle to 145 (wait)
    await sendCmd('M105');                await waitForOk();

    // Home while warm (Z sensor happy at ~145)
    await sendCmd('G28');                 await waitForOk();

    // Set final print temps (don’t wait yet), park, then wait to temps
    await sendCmd(`M104 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd(`M140 S${BED_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();
    await sendCmdsSequential('G90', 'G0 Z20', 'G0 X0 Y0');
    await sendCmd(`M190 S${BED_FINAL}`);  await waitForOk();
    await sendCmd(`M109 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();

    // Purge / prime lines
    await sendCmdsSequential(
      'G92 E0',
      'M83',
      'G1 Z2.0 F3000',
      'G1 X10.1 Y20 Z0.28 F5000.0',
      'G1 X10.1 Y200.0 Z0.28 F1500.0 E15',
      'G1 X10.4 Y200.0 Z0.28 F5000.0',
      'G1 X10.4 Y20 Z0.28 F1500.0 E30',
      'G92 E0',
      'G1 Z2.0 F3000',
      'M82'
    );

    // Drain queue, Z hop +10, cool down, then close print screen
    await sendCmd('M400');                await waitForOk().catch(()=>{});
    await sendCmd('G91');                 await waitForOk().catch(()=>{});
    await sendCmd('G1 Z10 F600');         await waitForOk().catch(()=>{});
    await sendCmd('G90');                 await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');             await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');             await waitForOk().catch(()=>{});
    exitPrintScreen(0, { tellHost: false }); 

    isHomed = true;
    setActivity('Wipe + prime complete (cooled)', 'ok');
    logMsg('✅ Homed at 65/145; primed at 200/60; Z+10; heaters OFF; closed print screen.');
    updateLastUpdated();
  } catch (e) {
    setActivity('Prep failed', 'bad');
    logMsg('⚠️ Wipe/prime error: ' + (e?.message || e));
  }
}

// === Nozzle Wipe + Prime Line (staged warmup, safe home, purge, cool, exit) ===
async function runPrimeLine() {
  const HOT_FINAL = 200;
  const BED_FINAL = 60;

  try {
    setActivity('Nozzle prep…', 'warn');

    // Restore mesh & motion defaults
    await sendCmdsSequential(
      'M420 S1',
      'M201 X500.00 Y500.00 Z100.00 E5000.00',
      'M203 X500.00 Y500.00 Z10.00 E50.00',
      'M204 P500.00 R1000.00 T500.00',
      'M205 X8.00 Y8.00 Z0.40 E5.00',
      'M220 S100',
      'M221 S100'
    );

    // Staged warmup to avoid droop before homing (per your script)
    await sendCmd('M190 S50');            await waitForOk(); // bed to 50 (wait)
    await sendCmd('M140 S65');            await waitForOk(); // bed target 65 (no wait)
    await sendCmd('M104 S120');           await waitForOk(); // nozzle 120 (no wait)
    await sendCmd('M190 S65');            await waitForOk(); // bed to 65 (wait)
    await sendCmd('M109 S145');           await waitForOk(); // nozzle to 145 (wait)
    await sendCmd('M105');                await waitForOk();

    // Home while warm (Z sensor happy at ~145)
    await sendCmd('G28');                 await waitForOk();

    // Set final print temps (don’t wait yet), park, then wait to temps
    await sendCmd(`M104 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd(`M140 S${BED_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();
    await sendCmdsSequential('G90', 'G0 Z20', 'G0 X0 Y0');
    await sendCmd(`M190 S${BED_FINAL}`);  await waitForOk();
    await sendCmd(`M109 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();

    // Purge / prime lines
    await sendCmdsSequential(
      'G92 E0',
      'M83',
      'G1 Z2.0 F3000',
      'G1 X10.1 Y20 Z0.28 F5000.0',
      'G1 X10.1 Y200.0 Z0.28 F1500.0 E15',
      'G1 X10.4 Y200.0 Z0.28 F5000.0',
      'G1 X10.4 Y20 Z0.28 F1500.0 E30',
      'G92 E0',
      'G1 Z2.0 F3000',
      'M82'
    );

    // Drain queue, Z hop +10, cool down, then close print screen
    await sendCmd('M400');                await waitForOk().catch(()=>{});
    await sendCmd('G91');                 await waitForOk().catch(()=>{});
    await sendCmd('G1 Z10 F600');         await waitForOk().catch(()=>{});
    await sendCmd('G90');                 await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');             await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');             await waitForOk().catch(()=>{});
    exitPrintScreen(0, { tellHost: false }); 

    isHomed = true;
    setActivity('Wipe + prime complete (cooled)', 'ok');
    logMsg('✅ Homed at 65/145; primed at 200/60; Z+10; heaters OFF; closed print screen.');
    updateLastUpdated();
  } catch (e) {
    setActivity('Prep failed', 'bad');
    logMsg('⚠️ Wipe/prime error: ' + (e?.message || e));
  }
}


function _ensureAudioCtx() {
  if (!_audioCtx) {
    try { _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {}
  }
  if (_audioCtx && _audioCtx.state === 'suspended') _audioCtx.resume();
  return _audioCtx;
}

function _tone(freq=880, ms=120, vol=0.22, when=0) {
  const ctx = _ensureAudioCtx(); if (!ctx) return;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;

  const t0 = ctx.currentTime + when;
  gain.gain.setValueAtTime(0.0001, t0);
  gain.gain.linearRampToValueAtTime(vol, t0 + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.0001, t0 + ms/1000);

  osc.connect(gain).connect(ctx.destination);
  osc.start(t0);
  osc.stop(t0 + ms/1000 + 0.02);
}

function beep(kind='start') {
  try {
    if (!BEEP_BROWSER_ON) return;
    if (kind === 'start') { _tone(880,120,0.24,0); _tone(1100,120,0.24,0.15); }
    else if (kind === 'done') { _tone(784,120,0.24,0); _tone(988,120,0.24,0.16); _tone(1319,160,0.26,0.34); }
    else if (kind === 'cancel') { _tone(220,260,0.28,0); }
    else if (kind === 'error') { _tone(200,160,0.28,0); _tone(150,220,0.28,0.22); }
    if (navigator.vibrate) {
      if (kind === 'start') navigator.vibrate([25]);
      else if (kind === 'done') navigator.vibrate([20,40,20]);
      else if (kind === 'cancel' || kind === 'error') navigator.vibrate([60]);
    }
  } catch {}
}

async function printerBeep(kind='start') {
  if (!BEEP_PRINTER_ON) return;
  // only try if connected
  if (!(connKind === 'virtual' || writer)) return;

  // simple patterns (freq S, duration P)
  const seq = (kind === 'start') ? [[880,120],[1100,120]]
            : (kind === 'done')  ? [[784,120],[988,120],[1319,160]]
            : (kind === 'cancel')? [[220,260]]
            :                      [];
  try {
    for (const [s,p] of seq) {
      await sendCmd(`M300 S${Math.round(s)} P${Math.round(p)}`);
      await waitForOk().catch(()=>{});
      await sleep(10);
    }
  } catch {}
}

/* ===== Live Telemetry Chart (temps, fan %, M73 %) ===== */
const live = {
  el: null, ctx: null, buf: [], maxSec: 600, // 10 minutes
  lastFan255: 0, lastProg: null, raf: 0
};

(function initLiveChart(){
  live.el = document.getElementById('liveChart');
  if (!live.el) return;
  live.ctx = live.el.getContext('2d');

  const resize = () => {
    const dpr = window.devicePixelRatio || 1;
    const cssW = live.el.clientWidth || 900;
    const cssH = live.el.clientHeight || 260;
    live.el.width  = Math.round(cssW * dpr);
    live.el.height = Math.round(cssH * dpr);
    live.ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    queueLiveDraw();
  };
  window.addEventListener('resize', resize);
  resize();
})();

function recordLiveSample() {
  if (!live.ctx) return;
  const now = Date.now()/1000;
  live.buf.push({
    ts: now,
    hot: Number.isFinite(temps.hot) ? temps.hot : null,
    bed: Number.isFinite(temps.bed) ? temps.bed : null,
    fanPct: Number.isFinite(live.lastFan255) ? Math.round(live.lastFan255 * 100 / 255) : null,
    progPct: (live.lastProg != null ? live.lastProg : null)
  });
  // drop old
  const cut = now - live.maxSec;
  while (live.buf.length && live.buf[0].ts < cut) live.buf.shift();
  queueLiveDraw();
}

function queueLiveDraw(){
  if (live.raf) return;
  live.raf = requestAnimationFrame(() => { live.raf = 0; drawLive(); });
}

function drawLive(){
  const el = live.el, ctx = live.ctx;
  if (!ctx) return;
  const W = el.clientWidth || 900, H = el.clientHeight || 260;
  ctx.clearRect(0,0,W,H);

  // Axes and layout
  const padL = 40, padR = 40, padT = 10, padB = 20;
  const plotW = W - padL - padR, plotH = H - padT - padB;

  // Time window
  const now = Date.now()/1000;
  const t0 = now - live.maxSec, t1 = now;

  // Scales
  const tempMin = 0, tempMax = 270;   // °C
  const pctMin  = 0, pctMax  = 100;   // %
  const xOf = ts => padL + ((ts - t0) / (t1 - t0)) * plotW;
  const yTemp = v => padT + (1 - (v - tempMin) / (tempMax - tempMin)) * plotH;
  const yPct  = v => padT + (1 - (v - pctMin)  / (pctMax  - pctMin )) * plotH;

  // Grid
  ctx.globalAlpha = 0.15;
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i=0;i<=5;i++){
    const y = padT + (i/5)*plotH;
    ctx.moveTo(padL, y); ctx.lineTo(W - padR, y);
  }
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Labels
  ctx.fillStyle = '#333';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textAlign = 'left';  ctx.fillText('°C', 4, padT+12);
  ctx.textAlign = 'right'; ctx.fillText('%', W-4, padT+12);

  // Helper to draw a series
  const drawSeries = (key, yFn, color, dash=[]) => {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.setLineDash(dash);
    ctx.lineWidth = 2;
    let started = false;
    ctx.beginPath();
    for (const s of live.buf) {
      const v = s[key];
      if (v == null || !isFinite(v)) continue;
      const x = xOf(s.ts), y = yFn(v);
      if (!started) { ctx.moveTo(x,y); started = true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  };

  // Series
  drawSeries('hot',    yTemp, '#e74c3c');        // Hotend (red)
  drawSeries('bed',    yTemp, '#3498db', [6,4]); // Bed (blue, dashed)
  drawSeries('fanPct', yPct,  '#7f8c8d');        // Fan % (gray)
  drawSeries('progPct',yPct,  '#2ecc71');        // M73 % (green)

  // Frame
  ctx.strokeStyle = '#ccc';
  ctx.strokeRect(padL, padT, plotW, plotH);
}

function openPreflight(file) {
  _preflightFile = file;

  // dynamic bits
  document.getElementById('preFileName').textContent = file?.name || '(unnamed)';
  document.getElementById('preGuardrail').textContent = heaterUnlocked ? 'OFF' : 'ON';
  const ht = (temps.hot ?? NaN), bt = (temps.bed ?? NaN);
  const hT = (temps.hotTarget ?? NaN), bT = (temps.bedTarget ?? NaN);
  const fmt = (v) => Number.isFinite(v) ? (''+ (v % 1 ? v.toFixed(1) : Math.round(v))) : '—';
  document.getElementById('preTemps').textContent = `${fmt(ht)} / ${fmt(hT)} · ${fmt(bt)} / ${fmt(bT)}`;
  document.getElementById('preMode').textContent = (connKind === 'virtual') ? 'Virtual' : 'Serial';
  document.getElementById('preHomed').textContent = isHomed ? 'Yes' : 'No';

  // reset checks & button
  document.querySelectorAll('.preChk').forEach(c => c.checked = false);
  document.getElementById('preStart').disabled = true;
  document.getElementById('preSkip').checked = false;

  // wire buttons
  document.getElementById('preStart').onclick = async () => {
    if (document.getElementById('preSkip').checked) sessionStorage.setItem('skipPreflight','1');
    closePreflight();
    await streamGcode(_preflightFile);
  };
  document.getElementById('preCancel').onclick = closePreflight;
  document.getElementById('preClose').onclick  = closePreflight;

  document.getElementById('preHome').onclick = async () => {
    try {
      await sendCmd('G28'); await waitForOk().catch(()=>{});
      isHomed = true;
      document.getElementById('preHomed').textContent = 'Yes';
    } catch {}
  };
  document.getElementById('prePark').onclick = async () => {
    try { await sendCmdsSequential('G90', 'G1 X0 Y0 Z10 F3000'); } catch {}
  };

  // show
  document.getElementById('preOverlay').style.display = 'block';
  document.getElementById('preModal').style.display   = 'grid';

  // esc to close
  const esc = (e) => { if (e.key === 'Escape') closePreflight(); };
  document.addEventListener('keydown', esc, { once:true });
}

function closePreflight() {
  document.getElementById('preModal').style.display   = 'none';
  document.getElementById('preOverlay').style.display = 'none';
  _preflightFile = null;
}

function updateUnlockUi() {
  const btn  = document.getElementById('unlockTempsBtn');
  const hint = document.getElementById('unlockHint');
  if (!btn) return;

  // Toggle label + aria state
  btn.textContent = heaterUnlocked ? 'Lock high hotend temps' : 'Unlock high hotend temps';
  btn.setAttribute('aria-pressed', heaterUnlocked ? 'true' : 'false');

  // Helper text
  if (hint) {
    hint.textContent = heaterUnlocked
    ? '⚠️ Guardrail OFF — be careful.'
    : '✅ Guardrail ON — 250°C caps active.';
  }
}

function setHeaterUnlocked(on) {
  heaterUnlocked = !!on;
  localStorage.setItem('heaterUnlocked', JSON.stringify(heaterUnlocked));
  updateUnlockUi();

  const msg = heaterUnlocked
    ? '⚠️ Guardrail OFF — be careful.'
    : '✅ Guardrail ON — 250°C caps active.';
  const text = heaterUnlocked ? 'High hotend temps UNLOCKED' : 'High hotend temps LOCKED';
  const cls  = heaterUnlocked ? 'warn' : '';

  setActivity(text, cls);
  logMsg(msg);
}


function onUnlockToggle(e){
  e.preventDefault();
  setHeaterUnlocked(!heaterUnlocked);
  setActivity(heaterUnlocked ? 'High hotend temps UNLOCKED' : 'High hotend temps LOCKED',
              heaterUnlocked ? 'warn' : '');
  logMsg(heaterUnlocked ? '⚠️ Guardrail OFF — be careful.'
                        : '✅ Guardrail ON — 250°C caps active.');
}

if (unlockTempsBtn) unlockTempsBtn.onclick = onUnlockToggle; // bind once

function guardHeaterFromCmd(cmd) {
  if (heaterUnlocked) return true;
  // Only gate heater-set commands with S values
  if (!/^(?:M10(?:4|9)|M1(?:40|90))\b/i.test(cmd)) return true;
  const s = cmd.match(/\bS\s*([0-9.]+)/i);
  if (!s) return true;

  const val = parseFloat(s[1]);
  const isHot = /^M10(?:4|9)\b/i.test(cmd);
  const lim = isHot ? MAX_HOTEND : MAX_BED;

  if (val > lim) {
    setActivity('Heater limit blocked', 'bad');
    logMsg(`⛔ Blocked: ${cmd} (limit ${lim}°C; click “Unlock hotend high temps” to override)`);
    return false;
  }
  return true;
}

function guardHeaterSet(tool, target, sourceLabel='UI') {
  const limit = tool === 'hotend' ? MAX_HOTEND : MAX_BED;
  if (Number.isFinite(target) && target > limit && !heaterUnlocked) {
    setActivity('Blocked by heater guardrail', 'bad');
    alert(`⛔ Limit ${limit}°C. Requested ${target}°C from ${sourceLabel}. Click “Unlock high hotend temps” to allow this.`);
    return false;
  }
  return true;
}

function startNetMeter() {
  if (net.timer) return;
  net.lastSample = performance.now();
  net.timer = setInterval(sampleNet, 1000);
}

function stopNetMeter() {
  if (net.timer) { clearInterval(net.timer); net.timer = null; }
  net.txRate = 0; net.rxRate = 0;
  updateNetUi();
}

function sampleNet() {
  const now = performance.now();
  const dt = (now - net.lastSample) / 1000;
  if (dt <= 0) return;

  const txInstant = net.txSince / dt;
  const rxInstant = net.rxSince / dt;
  const a = 0.30; // EMA smoothing

  net.txRate = net.txRate ? (a * txInstant + (1 - a) * net.txRate) : txInstant;
  net.rxRate = net.rxRate ? (a * rxInstant + (1 - a) * net.rxRate) : rxInstant;

  net.txSince = 0;
  net.rxSince = 0;
  net.lastSample = now;

  updateNetUi();
}

function fmtRate(v) {
  if (!v) return '—';
  if (v < 1024) return `${Math.round(v)} B/s`;
  if (v < 1024 * 1024) return `${(v / 1024).toFixed(1)} KB/s`;
  return `${(v / 1024 / 1024).toFixed(2)} MB/s`;
}

function updateNetUi() {
  const el = document.getElementById('netPill');
  if (!el) return;
  const lat = (net.latencyEMA != null) ? `${Math.round(net.latencyEMA)} ms` : '—';
  el.textContent = `TX ${fmtRate(net.txRate)} · RX ${fmtRate(net.rxRate)} · Lat ${lat}`;
}

function updateLatency(ms) {
  const a = 0.20; // EMA for OK latency
  net.latencyEMA = (net.latencyEMA == null) ? ms : (a * ms + (1 - a) * net.latencyEMA);
  updateNetUi();
}


// --- Baud selection and robust open/probe helpers ---------------------------
function baudSelection() {
  const sel = document.getElementById('baudSelect');
  const v = sel?.value || 'auto';
  if (v !== 'auto') {
    const fixed = parseInt(v, 10);
    return { mode: 'manual', list: Number.isFinite(fixed) ? [fixed] : [115200] };
  }
  // Try common rates (most likely first)
  return { mode: 'auto', list: [250000, 115200, 230400, 500000, 1000000, 57600] };
}

async function nudgeDTRRTS() {
  // Some boards wake/reset on signal toggles
  try {
    await port.setSignals({ dataTerminalReady: true,  requestToSend: true });
    await sleep(80);
    await port.setSignals({ dataTerminalReady: false, requestToSend: false });
  } catch { /* not supported on every driver */}
}

async function openAtBaud(baud) {
  // Clean any prior state
  try { if (reader) await reader.cancel(); } catch {}
  try { if (reader) reader.releaseLock(); } catch {}
  try { if (writer) writer.releaseLock(); } catch {}
  try { if (port && (port.readable || port.writable)) await port.close(); } catch {}

  await port.open({ baudRate: baud });

  // Pipe as strings when available for better perf
  if (typeof TextDecoderStream !== 'undefined') {
    const tds = new TextDecoderStream();
    textDecoder = tds;
    port.readable.pipeTo(tds.writable).catch(() => {});
    reader = tds.readable.getReader();      // yields strings
  } else {
    textDecoder = new TextDecoder();
    reader = port.readable.getReader();     // yields Uint8Array
  }
  writer = port.writable.getWriter();

  await nudgeDTRRTS(); // wake it up a bit
  return { success: true, baud };
}

// Auto-detect helper: open, poke, and look for tokens; otherwise close & fail.
async function probeAtBaud(baud, timeoutMs = 5000) {
  try {
    await openAtBaud(baud);
  } catch (e) {
    return { success: false, error: e };
  }

  const enc = new TextEncoder();
  const poke = async (s) => { try { await writer.write(enc.encode(s)); } catch {} };

  // Send a few CRLFs then M115; some stacks only react to \r\n
  await poke('\r\n\r\nM115\r\n');

  const deadline = performance.now() + timeoutMs;
  let buf = '';

  try {
    while (performance.now() < deadline) {
      const { value, done } = await reader.read();
      if (done) break;

      // Normalize to string
      const chunk = (value instanceof Uint8Array)
        ? textDecoder.decode(value, { stream: true })
        : (value ?? '');

      buf += chunk;

      // Accept any of these as "alive":
      // - Marlin/RepRap M115 banner
      // - a plain "start"
      // - an "ok"
      // - temps like "T:..." or "B:..."
      if (/FIRMWARE_NAME:|^start\b|^ok\b|T:\s*[-+]?\d|B:\s*[-+]?\d/m.test(buf)) {
        return { success: true, baud };
      }
    }
  } catch { /* ignore transient read errors during probing */ }

  // No luck: tear down cleanly
  try { await reader.cancel(); } catch {}
  try { reader.releaseLock(); } catch {}
  try { writer.releaseLock(); } catch {}
  try { await port.close(); } catch {}

  return { success: false };
}
















//Critical section helpers
function beginCritical() { if (criticalDepth++ === 0) stopTempPolling(); }

function endCritical()   { if (criticalDepth > 0 && --criticalDepth === 0) startTempPolling(); }

//Ambient sampling
function _pushAmbientSample(tool, temp, target) {
  const now = Date.now() / 1000;
  const buf = _ambientBuf[tool];
  // Only track when target is off/zero/unknown
  if (target == null || target <= 0) {
    buf.push([now, temp]);
    while (buf.length && (now - buf[0][0]) > AMBIENT_WINDOW_SEC) buf.shift();
  } else {
    // heating/cooling to a target — clear buffer so we don't mislabel
    buf.length = 0;
  }
}

function _ambientPlateau(tool) {
  const buf = _ambientBuf[tool];
  if (buf.length < 2) return null;
  const span = buf[buf.length - 1][0] - buf[0][0];
  if (span < AMBIENT_MIN_SEC) return null;

  let min = +Infinity, max = -Infinity;
  for (const [, t] of buf) { if (t < min) min = t; if (t > max) max = t; }
  const spread = max - min;

  const first = buf[0], last = buf[buf.length - 1];
  const slope = (last[1] - first[1]) / Math.max(1, (last[0] - first[0])); // °C/s
  if (spread <= AMBIENT_MAX_SPREAD && Math.abs(slope) <= AMBIENT_MAX_SLOPE) {
    // use mean as ambient estimate
    const avg = buf.reduce((a, [,t]) => a + t, 0) / buf.length;
    return { ambient: avg, spread, slope, span };
  }
  return null;
}

//ETA helpers
function isCountingLine(g) {
  const s = g.trim();
  if (!s || s.startsWith(';')) return false;

  // Ignore homing/leveling/heating/waits/setup
  if (/^(?:G28|G29|M104|M109|M140|M190|M82|M83|G90|G91|M84|M400)\b/i.test(s)) return false;

  // Count real motion lines; require X or Y or E (ignore pure Z hops)
  if (/^G0?1\b/i.test(s)) {
    const hasXorY = /[XY]/i.test(s);
    const hasE    = /\bE[-+]?\d/i.test(s);
    const hasOnlyZ= /Z[-+]?\d/i.test(s) && !hasXorY && !hasE;
    return (hasE || hasXorY) && !hasOnlyZ;
  }
  return false;
}

function formatETA(seconds) {
  if (!isFinite(seconds) || seconds <= 0) return '0s';
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  if (m > 59) {
    const h = Math.floor(m / 60);
    const mm = m % 60;
    return `${h}h ${mm}m`;
  }
  return m > 0 ? `${m}m ${s}s` : `${s}s`;
}

function showEtaPill(text, cls = 'warn') {
  if (!etaPill) return;
  etaPill.textContent = text;
  etaPill.className = 'pill ' + cls;
  etaPill.style.display = 'inline-flex';
}

function hideEtaPill() {
  if (!etaPill) return;
  etaPill.style.display = 'none';
}

//PID Prefs
function getPidCycles(tool) {
  const key = `pidCycles:${tool}`;            // tool = 'hotend' | 'bed'
  const saved = parseInt(localStorage.getItem(key) || '', 10);
  return Number.isFinite(saved) && saved >= 1 && saved <= 20 ? saved : 5; // default 5
}

function setPidActive(tool, on = true) {
  if (on && pidTarget && pidTarget !== tool) return; // don't flip mid-run
  if (tool === 'hotend') pidActiveHotend = !!on;
  if (tool === 'bed')    pidActiveBed    = !!on;
  pidTarget = on ? tool : null;
  setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
  setTempPill(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget, 'bed');
}

function clearAllPidUi() {
  pidActiveHotend = false;
  pidActiveBed = false;
  pidTarget = null; // <- ensure the orange pulse stops

  topHotendPill.classList.remove('warn', 'pulse');
  topBedPill.classList.remove('warn', 'pulse');

  setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
  setTempPill(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget, 'bed');
}

function setPidCycles(tool, c) {
  const key = `pidCycles:${tool}`;
  localStorage.setItem(key, String(c));
}

function promptCycles(tool) {
  const def = getPidCycles(tool);
  const raw = safePrompt(`How many PID cycles? (1–20)`, String(def));
  if (raw === null) return null;
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n < 1 || n > 20) {
    alert('Invalid cycle count. Enter a whole number between 1 and 20.');
    return null;
  }
  setPidCycles(tool, n);
  return n;
}

//Temp and UI state
function tempState(current, target, tolerance = 0.5) {
  if (target == null || Number.isNaN(target)) return 'idle';
  const diff = target - current;
  if (Math.abs(diff) <= tolerance) return 'ready';
  return diff > 0 ? 'heating' : 'cooling';
}

function setTempPill(pillEl, textEl, curr, target, type /* 'hotend'|'bed' */) {
  // Text (default)
  textEl.textContent =
    (target != null && !Number.isNaN(target))
      ? `${curr.toFixed(1)}°C / ${Math.round(target)}°`
      : `${curr.toFixed(1)}°C`;

  // Reset base classes
  pillEl.classList.remove('offline','idle','ready','heating','cooling','pulse','warn','ok','bad');

  // If PID is running, keep orange pulse
  if (pidTarget && pidTarget === type) {
    pillEl.classList.add('warn','pulse');
    return;
  }

  // ✅ Ambient plateau override: target off/zero and temp has stabilised for ~5 min
  if (target == null || target <= 0) {
    const tool = (type === 'hotend') ? 'hot' : 'bed';
    const amb = _ambientPlateau(tool);
    if (amb) {
      pillEl.classList.add('ready');            // green
      pillEl.classList.remove('pulse');
      textEl.textContent = `${curr.toFixed(1)}°C (ambient≈${amb.ambient.toFixed(1)}°)`;
      return;                                   // don't fall through to 'cooling'
    }
  }

  // Normal state machine
  const state = tempState(curr, target); // 'idle' | 'ready' | 'heating' | 'cooling'
  pillEl.classList.add(state);
  if ((state === 'heating' || state === 'cooling') && !pidTarget) {
    pillEl.classList.add('pulse');
  }
}

// Now updateTempPanel simply calls setTempPill for each
function updateTempPanel() {
  if (temps.hot != null || temps.hotTarget != null) {
setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
    hotendNow.textContent = `Current: ${temps.hot?.toFixed(1) ?? '—'}°C` +
      (temps.hotTarget != null ? ` / ${Math.round(temps.hotTarget)}°` : '');
  } else {
    hotendNow.textContent = 'Current: —';
  }

  if (temps.bed != null || temps.bedTarget != null) {
    setTempPill(topBedPill, topBedText, temps.bed ?? 0, temps.bedTarget, 'bed');
    bedNow.textContent = `Current: ${temps.bed?.toFixed(1) ?? '—'}°C` +
      (temps.bedTarget != null ? ` / ${Math.round(temps.bedTarget)}°` : '');
  } else {
    bedNow.textContent = 'Current: —';
  }
}

function setOfflinePills() {
  topHotendText.textContent = '--°C';
  topBedText.textContent    = '--°C';
  topHotendPill.className   = 'pill offline';
  topBedPill.className      = 'pill offline';
  hotendNow.textContent     = 'Current: —';
  bedNow.textContent        = 'Current: —';
}


//Axis UI
function updateAxisPanel(x, y, z) {
  posXEl.textContent = x.toFixed(3);
  posYEl.textContent = y.toFixed(3);
  posZEl.textContent = z.toFixed(3);
}


//Logging and Format
function normalizeLine(s){
  s = s.replace(/\x1b\[[0-9;]*m/g, '').replace(/[\u0000-\u001F\u007F]/g, '');
  s = s.replace(/\bcontinueing\b/gi, 'continuing');
  return s;
}

function isNoisyLine(s){ return NOISY_REGEX.test(s); }

function isSetNewScreenLine(s){ return /^setnewscreen\b/i.test(s); }

function trace(msg) { console.debug('[TRACE]', msg); }

function _logBase(msg) {
  if (!msg.endsWith('\n')) msg += '\n';
  printerLog.textContent += msg;
  printerLog.scrollTop = printerLog.scrollHeight;
}

function logMsg(msg) {
  const lines = String(msg).split(/\r?\n/);
  for (let line of lines) {
    if (!line) continue;
    line = normalizeLine(line);

    if (!debugMode && (isSetNewScreenLine(line) || isNoisyLine(line))) continue;
    if (!debugMode && TELEMETRY_REGEX.test(line)) continue;

    if (captureMode === 'config') {
      configBox.value += line + '\n';
      configBox.scrollTop = configBox.scrollHeight;
    } else if (captureMode === 'diag') {
      diagBox.value += line + '\n';
      diagBox.scrollTop = diagBox.scrollHeight;
    }
    _logBase(line);
  }
}

//Header and UI
function setActivity(text, cls='') {
  activityBadge.textContent = text;
  activityBadge.className = 'pill ' + cls;
}

function setConnected(connected) {
  if (connected) {
    connBadge.textContent = 'Connected';
    connBadge.className = 'pill ok';

    topHotendPill.classList.remove('offline');
    topBedPill.classList.remove('offline');
    topHotendPill.classList.add('idle');
    topBedPill.classList.add('idle');
    updateTempPanel();
    // reset live net meter on fresh connect
    net.txBytesTotal = net.rxBytesTotal = 0;
    net.txSince = net.rxSince = 0;
    net.txRate = net.rxRate = 0;
    net.latencyEMA = null;
    updateNetUi();
    startTempPolling();
 startNetMeter();   
    hideEtaPill();
  } else {
    connBadge.textContent = 'Disconnected';
    connBadge.className = 'pill bad';
    stopTempPolling();
 stopNetMeter();   
    setOfflinePills();
    if (live) { live.buf.length = 0; live.lastProg = null; queueLiveDraw(); }
  }

  connectBtn.disabled    = connected;
  disconnectBtn.disabled = !connected;
  readMeshBtn.disabled   = !connected;
  sendCmdBtn.disabled    = !connected;
  bedPidBtn.disabled     = !connected;
  hotendPidBtn.disabled  = !connected;
  clearLogBtn.disabled   = !connected;

  hotendApply.disabled = !connected;
  hotendOff.disabled   = !connected;
  bedApply.disabled    = !connected;
  bedOff.disabled      = !connected;
  fanApply.disabled    = !connected;
  fanOff.disabled      = !connected;

  homeAll.disabled      = !connected;
  disableMotors.disabled= !connected;
  xMinus.disabled = xPlus.disabled =
  yMinus.disabled = yPlus.disabled =
  zMinus.disabled = zPlus.disabled = !connected;
  parkHead.disabled     = !connected;

  readCfg.disabled      = !connected;
  saveCfg.disabled      = !connected;

  preheatPLA.disabled = preheatPETG.disabled =
  preheatABS.disabled = cooldown.disabled =
  loadFil.disabled = unloadFil.disabled = !connected;
primeLine.disabled = !connected;

  fwInfo.disabled = tmcDiag.disabled = !connected;

  sendGcode.disabled   = !connected || !gcodeFile.files.length;
  cancelSend.disabled  = true;
}

function updateLastUpdated(){
  lastUpdated.textContent = 'Last updated: ' + new Date().toLocaleTimeString();
  updateTempPanel();
}

function setLastCmd(cmd){ lastCmd.textContent = 'Last Cmd: ' + cmd; }

//Polling
function startTempPolling(){
  if (!tempTimer) tempTimer = setInterval(() => sendCmd('M105', true), 3000);
}

function stopTempPolling(){
  if (tempTimer){ clearInterval(tempTimer); tempTimer = null; }
}

//Printer Name
function loadPrinterName() {
  const saved = localStorage.getItem('printerName');
  printerNameEl.textContent = saved || 'PRINTER';
}

function savePrinterName(name) {
  const cleanName = name.trim() || 'PRINTER';
  printerNameEl.textContent = cleanName;
  localStorage.setItem('printerName', cleanName);
}

function initPrinterName() {
  loadPrinterName();
  printerNameEl.addEventListener('click', () => {
    const currentName = printerNameEl.textContent.trim();
    const newName = safePrompt('Enter your printer name:', currentName);
    if (newName !== null) {
      savePrinterName(newName);
    }
  });
}

//Prompts
function safePrompt(message, def = '') {
  if (typeof window !== 'undefined' && typeof window.prompt === 'function') {
    return window.prompt(message, String(def));
  }
  console.warn('[prompt] not available; using default value.');
  return String(def);
}

function safeConfirm(message) {
  if (typeof window !== 'undefined' && typeof window.confirm === 'function') {
    return window.confirm(message);
  }
  console.warn('[confirm] not available; defaulting to false.');
  return false;
}

//Firmware screen exit
function exitPrintScreen(delayMs = 0, { tellHost = false } = {}) {
  const run = async () => {
    try {
      logMsg('⌛ Tidying up LCD/host state…');
      const cmds = [
        'M400',                   // let moves/ISRs drain
        ...(tellHost ? ['M118 A1 action:cancel'] : []), // host-action for OctoPrint/etc.
        'M524',                   // abort SD print (harmless if none)
        'M117 Ready'              // friendly status on many LCDs
      ];
      await sendCmdsSequential(...cmds);
    } catch (e) {
      // non-fatal
      console.warn('exitPrintScreen failed:', e);
    }
  };

  if (delayMs > 0) setTimeout(() => { run(); }, delayMs);
  else run();
}

//Misc
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function sendCmdsSequential(...cmds) {
  for (const c of cmds) {
    // Skip empty or whitespace-only commands
    if (!c || !c.trim()) continue;

    try {
      await sendCmd(c.trim());       // send the command
      await waitForOk();             // wait for ack from printer
    } catch (err) {
      console.error(`Error sending command "${c}":`, err);
      break; // stop sending further commands if one fails
    }
  }
}


//Easter EGG
  const resetStreak = () => { streak = 0; };

  const openEasterEgg = () => {
    eeBody.textContent = [
      "This was a triumph,",
      "I’m making a note here: “BUILD SUCCESS.”",
      "It’s hard to overstate my satisfaction.",
      "Perfect adhesion,",
      "With just a touch of calibration. 🎵",
      "",
      "But there’s no sense whining when the layer’s too thin,",
      "You just tweak the Z-offset and then try it again.",
      "When the G-code’s complete,",
      "And the model’s elite,",
      "For the projects that are…",
      "Still printing. 🎵",
      "",
      "I’m not even angry,",
      "I’m being so sincere right now,",
      "Even though the extruder jammed and delayed my grand plans",
      "But I tuned the retraction",
      "And got a smooth reaction,",
      "",
      "Now the hours are flying, but I’m still having fun,",
      "Got a ten-hour Benchy and it’s only on run one.",
      "There’s a cat on the bed,",
      "And I’m filled with dread,",
      "For the projects that are…",
      "Still printing. 🎵",
      "",
      "Anyway, this print is great, it’s so dimensionally sweet,",
      "Look at me still sanding when there’s more stuff to complete.",
      "I’ve got spools in a row,",
      "And they’re ready to go,",
      "For the models that are…",
      "Still printing. 🎵"
    ].join('\n');

    eeOverlay.style.display = 'block';
    eeModal.style.display = 'grid';
    eeClose.focus();
  };

  const closeEasterEgg = () => {
    eeModal.style.display = 'none';
    eeOverlay.style.display = 'none';
  };

/* =========================================================
   6) MESH UTILS (parse, store, render)
========================================================= */

//Flow Helpers

function collectMeshFromInputs() {
  const mesh = [];
  for (let y = 0; y < 4; y++) {
    const row = [];
    for (let x = 0; x < 4; x++) {
      const el = document.getElementById(`cell-${y}-${x}`);
      const v = el ? parseFloat(el.value) : NaN;
      row.push(Number.isFinite(v) ? v : null);
    }
    mesh.push(row);
  }
  const complete = mesh.every(r => r.every(v => typeof v === 'number' && !Number.isNaN(v)));
  return complete ? mesh : null;
}

function processMeshLineFromAnywhere(line) {
  const completed = ingestMeshLine(line);
  if (completed) {
    const meshForUi = meshScratch.map(r => r.slice()); // already Y-flipped
    setActivity('Mesh parsed', 'ok');
    saveMeshLS(meshForUi);
    renderMeshInputs(meshForUi);
    renderSuggestions(meshForUi);
    updateLastUpdated();
    resetMeshScratch();
  }
}

async function homeAndProbe() {
  try {
    setActivity('Homing…', 'warn');
    await sendCmd('G28'); await waitForOk();

    // set up latch that will resolve when printer says it's done
    probeLatch = {};
    probeLatch.promise = new Promise((resolve, reject) => {
      probeLatch.resolve = resolve;
      probeLatch.reject  = reject;
    });

    setActivity('Probing…', 'warn');
    await sendCmd('G29 T');            // don't await waitForOk here
    await probeLatch.promise;          // wait for "Settings Stored" / grid header

    await coolToIdle();
    setActivity('Parsing…', 'warn');
  } catch (e) {
    setActivity('Home & probe failed', 'bad');
    logMsg('⚠️ Home & probe error: ' + (e?.message || e));
  }
}

function updateLevelView() {
  const choice = (levelPrinterSelect?.value || 'cr6se');
  const isCR6  = choice === 'cr6se';
  const isConnectedNow = (connKind === 'virtual') || !!writer;

  if (cr6seLevelWrap) cr6seLevelWrap.style.display = isCR6 ? '' : 'none';
  if (unsupportedMsg) unsupportedMsg.style.display = isCR6 ? 'none' : '';

  // Home & Probe button
  if (readMeshBtn) {
    readMeshBtn.style.display = isCR6 ? '' : 'none';
    readMeshBtn.disabled = !isCR6 || !isConnectedNow;
  }

  // Export Mesh button (hide when not CR-6)
  if (exportMeshBtn) {
    exportMeshBtn.style.display = isCR6 ? '' : 'none';
    // optional: only enable if we actually have a mesh to export
    const hasInputs = typeof collectMeshFromInputs === 'function' && !!collectMeshFromInputs();
    const latest = (() => {
      try { return JSON.parse(localStorage.getItem('levels') || '[]').at(-1); } catch { return null; }
    })();
    const hasSaved = Array.isArray(latest) && latest.length === 4;
    exportMeshBtn.disabled = !(hasInputs || hasSaved);
  }
}


//Scratch mgmt.
function meshIsComplete(m = meshScratch) {
  return m.every(row => row.every(v => typeof v === 'number' && !Number.isNaN(v)));
}

function resetMeshScratch() {
  meshScratch = Array.from({ length: 4 }, () => Array(4).fill(null));
}

//Parsing
function ingestMeshLine(line) {
  const s = line.trim();

  // Row-based: "y  v0 v1 v2 v3"
  const row = s.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
  if (row) {
    const fwY = parseInt(row[1], 10);
    const uiY = 3 - fwY; // flip Y for UI
    meshScratch[uiY][0] = parseFloat(row[2]);
    meshScratch[uiY][1] = parseFloat(row[3]);
    meshScratch[uiY][2] = parseFloat(row[4]);
    meshScratch[uiY][3] = parseFloat(row[5]);
    return meshIsComplete();
  }

  // Point formats: "X0 Y1 Z-0.0945", "X: 0; Y: 1 ... Z..."
  const pXY = s.match(/X\s*:?\s*(\d)\s*[,; ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i)
            || s.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
  if (pXY) {
    const x   = parseInt(pXY[1], 10);
    const fwY = parseInt(pXY[2], 10);
    const uiY = 3 - fwY;
    const val = parseFloat(pXY[3]);
    if (x < 4 && fwY < 4 && Number.isFinite(val)) {
      meshScratch[uiY][x] = val;
      return meshIsComplete();
    }
  }

  return false;
}

function tryParseMeshFromLines(lines) {
  const mesh = Array.from({ length: 4 }, () => Array(4).fill(null));

  for (const raw of lines) {
    const line = raw.trim();

    // Row-based
    const m = line.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
    if (m) {
      const fwY = parseInt(m[1], 10);
      const uiY = 3 - fwY;
      const vals = [parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), parseFloat(m[5])];
      mesh[uiY] = vals;
      continue;
    }

    // Point-by-point
    const p1 = line.match(/[\(\[](\d)\s*,\s*(\d)[\)\]]\s+([+-]?\d*\.?\d+)/);
    const p2 = line.match(/X\s*:?\s*(\d)\s*;?\s*[, ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i);
    const p3 = line.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
    const mP = p1 || p2 || p3;
    if (mP) {
      const x   = parseInt(mP[1], 10);
      const fwY = parseInt(mP[2], 10);
      const uiY = 3 - fwY;
      const val = parseFloat(mP[3]);
      if (x < 4 && fwY < 4) mesh[uiY][x] = val;
    }
  }

  const complete = mesh.every(row => row.every(v => typeof v === 'number' && !isNaN(v)));
  return complete ? mesh : null;
}

//Persistence
function loadMeshLS() {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  return hist.at(-1) || Array.from({length:4},()=>Array(4).fill(''));
}

function saveMeshLS(mesh) {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  hist.push(mesh);
  while (hist.length > 10) hist.shift();  // keep last 10
  localStorage.setItem('levels', JSON.stringify(hist));
}

//Presentation
function getScrewData(mesh) {
  const result = {};
  for (const screw in screwAffects) {
    const points = screwAffects[screw];
    const values = points
      .map(([y,x]) => mesh?.[y]?.[x])
      .filter(v => typeof v === 'number' && !isNaN(v));
    const avg = values.length ? values.reduce((a,b)=>a+b,0)/values.length : null;

    let suggestion='N/A', turn='N/A';
    if (avg !== null) {
      if (avg >  0.07)      { suggestion='Tighten (Clockwise)';           turn='Strong (1/4 turn)'; }
      else if (avg > 0.04)  { suggestion='Tighten (Clockwise)';           turn='Moderate (1/8 turn)'; }
      else if (avg > 0.02)  { suggestion='Tighten (Clockwise)';           turn='Slight (1/16 turn)'; }
      else if (avg < -0.07) { suggestion='Loosen (Counterclockwise)';     turn='Strong (1/4 turn)'; }
      else if (avg < -0.04) { suggestion='Loosen (Counterclockwise)';     turn='Moderate (1/8 turn)'; }
      else if (avg < -0.02) { suggestion='Loosen (Counterclockwise)';     turn='Slight (1/16 turn)'; }
      else { suggestion='No change'; }
    }
    result[screw] = { avg: avg?.toFixed(3) ?? 'N/A', suggestion, turn };
  }
  return result;
}

function renderMeshInputs(mesh) {
  meshInput.innerHTML = '';
  for (let y=0; y<4; y++) {
    const tr = document.createElement('tr');
    for (let x=0; x<4; x++) {
      const v = mesh?.[y]?.[x];
      tr.innerHTML += `<td><input type="number" step="0.001" id="cell-${y}-${x}" value="${typeof v==='number'? v.toFixed(3): ''}" required></td>`;
    }
    meshInput.appendChild(tr);
  }
}

function renderSuggestions(mesh) {
  const data = getScrewData(mesh);
  screwTable.innerHTML = '';
  const layout = ['A1','GAP','A2','A3','B1','B2','B3','B4','C1','C2','C3','C4'];
  for (const sName of layout) {
    if (sName === 'GAP') continue;
    const s = data[sName];
    const tr = document.createElement('tr');
    tr.className = s.suggestion.includes('Tighten') ? 'tighten'
               :  s.suggestion.includes('Loosen')  ? 'loosen'
               :  'na';
    tr.innerHTML = `<td>${sName}</td><td>${s.avg}</td><td>${s.suggestion}</td><td>${s.turn}</td>`;
    screwTable.appendChild(tr);
    const cell = document.getElementById(sName);
    if (cell) {
      cell.className = tr.className;
      cell.innerHTML = `<strong>${sName}</strong><br>${s.avg} mm<br>${s.turn!=='N/A'? s.turn : ''}`;
    }
  }
}

//Export and Numeric
function exportMeshAsFile(mesh, label) {
  const blob = new Blob([JSON.stringify(mesh, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `cr6se-mesh-${label}-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function promptNumber(message, def) {
  const raw = safePrompt(message, String(def));
  if (raw === null) return null;
  const n = parseFloat(raw);
  return Number.isFinite(n) ? n : NaN;
}

/* =========================================================
   7) SERIAL / COMMS (connect, read loop, send, waits)
========================================================= */

//Real Connection
//Real Connection
async function connectPrinter() {
  if (isConnecting) return;
  isConnecting = true;

  try {
    // Virtual path
    if (virtualMode) {
      await connectVirtual();
      connKind = 'virtual';
      return;
    }

    // Real serial path
    if (!('serial' in navigator)) {
      setConnected(false);
      setActivity('Web Serial not supported', 'bad');
      logMsg('❌ Web Serial API not supported. Use Chrome/Edge/Brave on desktop.');
      alert('Web Serial API not supported. Use Chrome/Edge/Brave on desktop.');
      connKind = 'none';
      return;
    }

    setActivity('Connecting...', 'warn');

    if (!port) {
      const granted = await navigator.serial.getPorts();
      port = granted[0] || await navigator.serial.requestPort();
    }

    const sel = baudSelection();
    let connectedAt = null;

    if (sel.mode === 'manual') {
      // Open immediately at the selected baud (no handshake gating)
      const b = sel.list[0];
      await openAtBaud(b);
      connectedAt = b;
    } else {
      // Auto-detect: probe each candidate with a longer timeout
      for (const b of sel.list) {
        setActivity(`Trying ${b}…`, 'warn');
        const res = await probeAtBaud(b, 5000);
        if (res.success) { connectedAt = res.baud; break; }
        await sleep(180); // brief pause before the next try
      }
    }

    if (!connectedAt) {
      setConnected(false);
      setActivity('Connect error', 'bad');
      logMsg('❌ No response at tried baud rates. Try selecting 115200 manually or another cable/port.');
      connKind = 'none';
      return;
    }

    // We're open with reader/writer from openAtBaud()/probeAtBaud()
    setConnected(true);
    cancelStream = false; // ← clear leftover cancel flag from a previous send
    sendCmd('M105', true); // prime a latency sample
    updateLevelView();
    hideEtaPill();
    updateTempPanel();
    startTempPolling();
    updateLastUpdated();
    setActivity(`Connected @ ${connectedAt}`, 'ok');
    logMsg(`Connected at ${connectedAt} baud.`);
    if (!reading) readLoop();

    connKind = 'real';
  } catch (err) {
    setConnected(false);
    setActivity('Connect error', 'bad');
    logMsg(String(err?.message || err));
    _rejectAllOk(new Error('Connect failed'));
    hideEtaPill();
    connKind = 'none';
  } finally {
    isConnecting = false;
  }
}

async function disconnectPrinter(reason = 'user') {
  if (isDisconnecting) return;
  isDisconnecting = true;

  const lost = reason === 'lost';
  try {
    // Fail any pending waits / streams immediately
    _rejectAllOk(new Error(lost ? 'Connection lost' : 'Disconnected'));
    if (probeLatch) {
      try { probeLatch.reject(new Error(lost ? 'lost' : 'disconnected')); }
      finally { probeLatch = null; }
    }

    // Put sender into a cancelled/abort state during teardown
    cancelStream = true;

    // Reset sender UI + ETA
    if (sendProgress) sendProgress.style.width = '0%';
    if (sendStatus)   sendStatus.textContent = 'Idle';
    hideEtaPill();
    clearAllPidUi();

    // Virtual path
    if (connKind === 'virtual' || virtualMode) {
      await disconnectVirtual();  // handles setConnected(false)
      connKind = 'none';
      stopTempPolling();
      setActivity(lost ? 'Connection lost (virtual)' : 'Disconnected', lost ? 'bad' : 'ok');
      if (lost) logMsg('❌ Connection lost (virtual).'); else logMsg('🔌 Virtual printer disconnected.');
      return; // finally{} will still run
    }

    // Real serial path
    setConnected(false); // also stops temp polling + net meter + sets offline pills
    setActivity(lost ? 'Connection lost…' : 'Disconnecting…', lost ? 'bad' : 'warn');
    stopTempPolling();

    try { if (reader) await reader.cancel(); } catch {}
    try { if (reader) reader.releaseLock(); } catch {}
    try { if (writer) writer.releaseLock(); } catch {}
    try { if (port)   await port.close();   } catch {}

    port = null;
    reader = null;
    writer = null;

    if (postPrintTimer) { clearTimeout(postPrintTimer); postPrintTimer = null; }

    setActivity(lost ? 'Connection lost' : 'Disconnected', lost ? 'bad' : 'ok');
    logMsg(lost ? '❌ Connection to printer was lost.' : '🔌 Disconnected.');
    connKind = 'none';
  } catch (err) {
    logMsg('❌ Disconnect error: ' + (err?.message || err));
    setActivity('Disconnect error', 'bad');
    connKind = 'none';
  } finally {
    // IMPORTANT: don’t let a previous cancel poison future one-shot macros
    cancelStream = false;      // ← reset the sticky flag
    isDisconnecting = false;
  }
}


//Virtual Connection
async function connectVirtual() {
  if (connKind === 'virtual') { logMsg('🧪 Already in virtual mode.'); return; }
  setConnected(true);
updateLevelView();
  setActivity('Connected (virtual)', 'ok');
  logMsg('🧪 Virtual printer connected.');
  startVirtualSim();
  startTempPolling();
  updateLastUpdated();
}

async function disconnectVirtual() {
  if (connKind !== 'virtual') { logMsg('🧪 Virtual not active.'); }
  stopVirtualSim();
  setConnected(false);
  setActivity('Disconnected', 'ok');
  logMsg('🔌 Virtual printer disconnected.');
}

//Virtual temps and sim
function refreshVirtualTemps() {
  // Mirror vState → temps
  temps.hot = vState.hot;
  temps.hotTarget = vState.hotTarget;
  temps.bed = vState.bed;
  temps.bedTarget = vState.bedTarget;

  // ✅ ADD THESE:
  _pushAmbientSample('hot', temps.hot ?? 0, temps.hotTarget);
  _pushAmbientSample('bed', temps.bed ?? 0, temps.bedTarget);

  // Update the pills + panel (normally done by readLoop in real mode)
  setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
  setTempPill(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget, 'bed');
  updateTempPanel();
}

function startVirtualSim() {
  if (vSimTimer) return;
  vSimTimer = setInterval(() => {
    const stepHot = 0.6, stepBed = 0.35;
    if (Number.isFinite(vState.hotTarget)) {
      const d = vState.hotTarget - vState.hot;
      vState.hot += Math.sign(d) * Math.min(Math.abs(d), stepHot);
    }
    if (Number.isFinite(vState.bedTarget)) {
      const d = vState.bedTarget - vState.bed;
      vState.bed += Math.sign(d) * Math.min(Math.abs(d), stepBed);
    }
    // keep temps in sync and refresh UI
    refreshVirtualTemps();
    recordLiveSample();
  }, 100);
}

function stopVirtualSim() {
  if (vSimTimer) { clearInterval(vSimTimer); vSimTimer = null; }
}

//Send paths
async function sendCmd(cmd, quiet = false) {
  // Route to virtual path if active
  if (connKind === 'virtual') {
    return sendCmdVirtual(cmd, quiet);
  }

  // Heater guardrail (blocks M104/M109 or M140/M190 over limits unless unlocked)
  if (!guardHeaterFromCmd(cmd)) {
    throw new Error('Heater guardrail blocked high temperature command');
  }

  if (!writer) {
    setActivity('Not connected', 'bad');
    throw new Error('Not connected');
  }

  const line = String(cmd).trim();

  setLastCmd(line);
  setActivity('Sending…', 'warn');

  // --- Live graph taps: fan (M106/M107) + progress (M73) -------------------
  // Fan set
  if (/^M106\b/i.test(line)) {
    const m = line.match(/\bS\s*([0-9.]+)/i);
    if (m) {
      const s = Math.max(0, Math.min(255, parseInt(m[1], 10) || 0));
      if (typeof live !== 'undefined') live.lastFan255 = s;
      if (typeof queueLiveDraw === 'function') queueLiveDraw();
    }
  }
  if (/^M107\b/i.test(line)) {
    if (typeof live !== 'undefined') live.lastFan255 = 0;
    if (typeof queueLiveDraw === 'function') queueLiveDraw();
  }
  // M73 progress (Prusa/Marlin)
  if (/^M73\b/i.test(line)) {
    const p = line.match(/\bP\s*([0-9]+)/i);
    if (p && typeof live !== 'undefined') {
      live.lastProg = Math.max(0, Math.min(100, parseInt(p[1], 10) || 0));
      if (typeof queueLiveDraw === 'function') queueLiveDraw();
    }
    const r = line.match(/\bR\s*([0-9]+)/i); // optional ETA minutes
    if (r) {
      const mins = Math.max(0, parseInt(r[1], 10) || 0);
      showEtaPill('ETA: ' + formatETA(mins * 60), 'warn');
    }
  }
  // -------------------------------------------------------------------------

  const payload = new TextEncoder().encode(line + '\n');

  // Stamp send time so "ok" without a waiter can update latency
  lastSendTs = performance.now();

  await writer.write(payload);
  if (!quiet) logMsg('>> ' + line);

  // TX metering
  net.txBytesTotal += payload.length;
  net.txSince      += payload.length;

  updateLastUpdated();
  setActivity('Waiting…', 'warn');
}


async function sendCmdVirtual(cmd, quiet = false) {
  const line = String(cmd).trim();

  // Heater guardrail (blocks M104/M109 or M140/M190 over limits unless unlocked)
  if (!guardHeaterFromCmd(line)) {
    throw new Error('Heater guardrail blocked high temperature command');
  }

  setLastCmd(line);
  setActivity('Sending…', 'warn');
  if (!quiet) logMsg('>> ' + line);

  // Approximate TX size for virtual path (no real serial)
  const approxLen = line.length + 1; // + '\n'
  if (typeof net !== 'undefined') {
    net.txBytesTotal += approxLen;
    net.txSince      += approxLen;
  }

  // Stamp send time for latency EMA in no-waiter cases
  lastSendTs = performance.now();

  // --- Live graph taps: fan (M106/M107) + progress (M73) -------------------
  // Fan set
  if (/^M106\b/i.test(line)) {
    const m = line.match(/\bS\s*([0-9.]+)/i);
    if (m) {
      const s = Math.max(0, Math.min(255, parseInt(m[1], 10) || 0));
      if (typeof live !== 'undefined') live.lastFan255 = s;
      if (typeof queueLiveDraw === 'function') queueLiveDraw();
    }
  }
  if (/^M107\b/i.test(line)) {
    if (typeof live !== 'undefined') live.lastFan255 = 0;
    if (typeof queueLiveDraw === 'function') queueLiveDraw();
  }
  // M73 progress
  if (/^M73\b/i.test(line)) {
    const p = line.match(/\bP\s*([0-9]+)/i);
    if (p && typeof live !== 'undefined') {
      live.lastProg = Math.max(0, Math.min(100, parseInt(p[1], 10) || 0));
      if (typeof queueLiveDraw === 'function') queueLiveDraw();
    }
    const r = line.match(/\bR\s*([0-9]+)/i);
    if (r) {
      const mins = Math.max(0, parseInt(r[1], 10) || 0);
      showEtaPill('ETA: ' + formatETA(mins * 60), 'warn');
    }
  }
  // -------------------------------------------------------------------------

  const ok = () => {
    setActivity('Waiting…', 'warn');
    setTimeout(() => {
      // suppress visible "ok" for quiet calls and for M105 polls
      if (!quiet && !/^M105\b/i.test(line)) logMsg('ok');
      _resolveNextOk();          // updates latency EMA if a waiter is present
      updateLastUpdated();
      setActivity('Idle');
    }, 60);
  };

  const emitTelemetry = () => {
    const ht = Number.isFinite(vState.hotTarget) ? vState.hotTarget : 0;
    const bt = Number.isFinite(vState.bedTarget) ? vState.bedTarget : 0;
    const telem = `T:${vState.hot.toFixed(1)} / ${Math.round(ht)} B:${vState.bed.toFixed(1)} / ${Math.round(bt)} @:0 B@:0`;
    logMsg(telem);
    refreshVirtualTemps();
  };

  switch (true) {
    // --- Telemetry ---
    case /^M105\b/i.test(line): {
      emitTelemetry();
      ok();
      break;
    }

    // --- PID autotune sim ---
    case /^M303\b/i.test(line): {
      const eParam = line.match(/\bE\s*(-?\d+)/i);
      const cParam = line.match(/\bC\s*(\d+)/i);
      const tool = eParam ? (parseInt(eParam[1], 10) === -1 ? 'bed' : 'hotend') : 'hotend';
      const cycles = cParam ? Math.max(1, Math.min(20, parseInt(cParam[1], 10))) : 5;

      logMsg(`PID Autotune start (${tool}) C=${cycles}`);
      setPidActive(tool, true);
      setTimeout(() => logMsg('PID Autotune finished'), Math.round(cycles * 600));
      ok();
      break;
    }

    // --- Targets / basic controls ---
    case /^M104\b/i.test(line): {
      const s = line.match(/S\s*([0-9.]+)/i);
      vState.hotTarget = s ? parseFloat(s[1]) : null;
      refreshVirtualTemps();
      ok();
      break;
    }
    case /^M140\b/i.test(line): {
      const s = line.match(/S\s*([0-9.]+)/i);
      vState.bedTarget = s ? parseFloat(s[1]) : null;
      refreshVirtualTemps();
      ok();
      break;
    }
    case /^M106\b/i.test(line):
    case /^M107\b/i.test(line):
    case /^M400\b/i.test(line):
    case /^M82\b/i.test(line):
    case /^M83\b/i.test(line):
    case /^M500\b/i.test(line):
    case /^M84\b/i.test(line):
    case /^G90\b/i.test(line):
    case /^G91\b/i.test(line):
      ok(); break;

    // --- Homing / movement ---
    case /^G28\b/i.test(line): {
      vState.x = 0; vState.y = 0; vState.z = 0;
      logMsg('X:0.000 Y:0.000 Z:0.000');
      ok();
      break;
    }
    case /^G1\b/i.test(line): {
      const x = line.match(/X\s*([-+]?\d*\.?\d+)/i);
      const y = line.match(/Y\s*([-+]?\d*\.?\d+)/i);
      const z = line.match(/Z\s*([-+]?\d*\.?\d+)/i);
      if (x) vState.x = parseFloat(x[1]);
      if (y) vState.y = parseFloat(y[1]);
      if (z) vState.z = parseFloat(z[1]);
      logMsg(`X:${vState.x.toFixed(3)} Y:${vState.y.toFixed(3)} Z:${vState.z.toFixed(3)}`);
      ok();
      break;
    }

    // --- Mesh report (G29 T) ---
    case /^G29\b/i.test(line) && /\bT\b/i.test(line): {
      const hasMock = Array.isArray(mockMesh) && mockMesh.length > 0;
      if (hasMock) {
        for (const raw of mockMesh) {
          const l = String(raw).trim();
          if (!l || /^ok\b/i.test(l)) continue;
          logMsg(l);
          processMeshLineFromAnywhere(l);
        }
      } else {
        const rows = [
          [ -0.120, -0.080, -0.035, -0.010 ],
          [ -0.075, -0.030,  0.005,  0.020 ],
          [ -0.040,  0.000,  0.030,  0.050 ],
          [ -0.010,  0.020,  0.055,  0.070 ],
        ];
        rows.forEach((vals, y) => {
          const l = `${y}  ${vals.map(v => (v >= 0 ? `+${v.toFixed(3)}` : v.toFixed(3))).join('  ')}`;
          logMsg(l);
          processMeshLineFromAnywhere(l);
        });
      }
      ok();
      break;
    }

    // --- Info / diagnostics ---
    case /^M115\b/i.test(line): {
      logMsg('FIRMWARE_NAME:VirtualPrinter PROTOCOL_VERSION:1.0 MACHINE_TYPE:Simulated EXTRUDER_COUNT:1');
      ok();
      break;
    }
    case /^M122\b/i.test(line): {
      logMsg('Driver diag (virtual): all good.');
      ok();
      break;
    }
    case /^M503\b/i.test(line): {
      logMsg('echo:  Steps per unit: M92 X80.00 Y80.00 Z400.00 E93.00');
      logMsg('echo:  Maximum feedrates: M203 X500.00 Y500.00 Z12.00 E25.00');
      ok();
      break;
    }

    // --- UI cancel hook ---
    case /^\/\/action:cancel/i.test(line): {
      logMsg('//action:cancel (virtual ack)');
      setTimeout(() => { _resolveNextOk(); updateLastUpdated(); }, 10);
      break;
    }

    // --- Fallback ---
    default:
      ok();
  }
}


//Read and parse loop
async function readLoop() {
  reading = true;
  try {
    while (true) {
      const { value, done } = await reader.read();

      // stream closed -> treat as lost connection
      if (done) {
        if (!isDisconnecting) await disconnectPrinter('lost');
        break;
      }
      if (value == null) continue;

      // --- RX metering ---
      if (value instanceof Uint8Array) {
        net.rxBytesTotal += value.length;
        net.rxSince      += value.length;
      } else if (typeof value === 'string') {
        net.rxBytesTotal += value.length;
        net.rxSince      += value.length;
      }

      // normalize to string
      const chunk = (value instanceof Uint8Array)
        ? textDecoder.decode(value, { stream: true })
        : value;

      rxBuffer += chunk;
      const parts = rxBuffer.split(/\r?\n/);
      rxBuffer = parts.pop(); // keep incomplete tail

      for (const raw of parts) {
        const line = raw.trim();
        if (!line) continue;

        // --- temps (M105-style) ---
        const tMatch = !captureMode && line.match(TEMP_T);
        const bMatch = !captureMode && line.match(TEMP_B);

        if (tMatch) {
          const tCur = parseFloat(tMatch[1]);
          const tTar = tMatch[2] !== undefined ? parseFloat(tMatch[2]) : null;
          if (Number.isFinite(tCur)) {
            temps.hot = tCur;
            temps.hotTarget = Number.isFinite(tTar) ? tTar : null;
            _pushAmbientSample('hot', temps.hot ?? 0, temps.hotTarget);
            setTempPill(topHotendPill, topHotendText, temps.hot, temps.hotTarget, 'hotend');
          }
        }
        if (bMatch) {
          const bCur = parseFloat(bMatch[1]);
          const bTar = bMatch[2] !== undefined ? parseFloat(bMatch[2]) : null;
          if (Number.isFinite(bCur)) {
            temps.bed = bCur;
            temps.bedTarget = Number.isFinite(bTar) ? bTar : null;
            _pushAmbientSample('bed', temps.bed ?? 0, temps.bedTarget);
            setTempPill(topBedPill, topBedText, temps.bed, temps.bedTarget, 'bed');
          }
        }
        if (tMatch || bMatch) updateTempPanel();

        // --- positions (e.g., "X:.. Y:.. Z:..") ---
        const posMatch = line.match(POS_REGEX);
        if (posMatch) {
          const x = parseFloat(posMatch[1]);
          const y = parseFloat(posMatch[2]);
          const z = parseFloat(posMatch[3]);
          if ([x, y, z].every(Number.isFinite)) {
            updateAxisPanel(x, y, z);
            // NEW: infer homed if it looks like the post-home coordinates
            maybeMarkHomedFromPos(x, y, z);
          }
        }

        // --- logging (respect noisy/telemetry filters & debug) ---
        const isTelemetry = TELEMETRY_REGEX.test(line);
        const out = normalizeLine(line);

        // track “homing-ish” hints for printer-panel homes
        maybeMarkHomingHint(out);

        if (!debugMode && (isSetNewScreenLine(out) || isNoisyLine(out))) {
          // skip
        } else if (debugMode) {
          if (tMatch || bMatch) {
            const hotStr = temps.hot != null
              ? `${temps.hot.toFixed(1)}${temps.hotTarget != null ? ' / ' + Math.round(temps.hotTarget) : ''}`
              : '--';
            const bedStr = temps.bed != null
              ? `${temps.bed.toFixed(1)}${temps.bedTarget != null ? ' / ' + Math.round(temps.bedTarget) : ''}`
              : '--';
            logMsg(`🌡 Hotend ${hotStr} · Bed ${bedStr}`);
          } else {
            logMsg(out);
          }
        } else {
          if (!isTelemetry) logMsg(out);
        }

        // --- mesh ingestion (G29 T variants) ---
        const meshCompleted = ingestMeshLine(out);
        if (meshCompleted) {
          const meshForUi = meshScratch.map(r => r.slice()); // already Y-flipped
          setActivity('Mesh parsed', 'ok');
          saveMeshLS(meshForUi);
          renderMeshInputs(meshForUi);
          renderSuggestions(meshForUi);
          updateLastUpdated();
          resetMeshScratch();
        }

        // --- probe completion latch ---
        if (probeLatch) {
          if (
            out.includes('//action:notification Settings Stored') ||  // DWIN save event
            /Bilinear Leveling Grid:/i.test(out)                      // fallback
          ) {
            try { probeLatch.resolve(); } finally { probeLatch = null; }
          }
        }

        // --- PID hints ---
        if (/PID Autotune start/i.test(out)) {
          setActivity('PID tuning…', 'warn');
          if (!pidTarget) {
            if (/\(bed\)/i.test(out) || /\bE-?1\b/i.test(out) || /\bBED\b/i.test(out)) {
              setPidActive('bed', true);
            } else {
              setPidActive('hotend', true);
            }
          }
        }
        if (/PID Autotune finished/i.test(out)) {
          setActivity('PID tuning complete', 'ok');
          clearAllPidUi();
        }
        if (/PID Autotune failed/i.test(out)) {
          setActivity('PID tuning failed', 'bad');
          clearAllPidUi();
        }

        // --- ok resolver ---
        if (/^ok\b/i.test(out)) {
          updateLastUpdated();
          if (captureMode) { captureMode = null; startTempPolling(); }
          _resolveNextOk();
        }
      }
    }
  } catch (err) {
    logMsg('⚠️ Read error: ' + (err?.message || err));
    if (!isDisconnecting) await disconnectPrinter('lost');
  } finally {
    reading = false;
  }
}



//Wait plumbing
function waitForOk() {
  beginCritical();
  return new Promise((resolve, reject) => {
    const wrapResolve = () => { try { resolve(); } finally { if (pendingOk.length === 0) endCritical(); } };
    const wrapReject  = (err) => { try { reject(err); }  finally { if (pendingOk.length === 0) endCritical(); } };

    // Real serial requires a live port/writer; virtual can proceed.
    const isReal = (connKind === 'real');
    if (isReal && (!port || !writer)) { wrapReject(new Error('Disconnected')); return; }
    if (cancelStream) { wrapReject(new Error('Cancelled')); return; }

    pendingOk.push({ resolve: wrapResolve, reject: wrapReject, startedAt: performance.now() });
  });
}

function _resolveNextOk() {
  const waiter = pendingOk.shift();
  if (waiter) {
    const ms = (typeof waiter.startedAt === 'number')
      ? (performance.now() - waiter.startedAt)
      : null;

    try { waiter.resolve(); } finally {
      if (ms != null && typeof updateLatency === 'function') {
        updateLatency(ms);
      }
      // ✅ avoid stale measurements on the next ok
      lastSendTs = null;

      if (pendingOk.length === 0) endCritical();
    }
  } else {
    if (lastSendTs != null) {
      const ms = performance.now() - lastSendTs;
      lastSendTs = null;                 // consume this measurement
      if (ms > 0 && isFinite(ms) && typeof updateLatency === 'function') {
        updateLatency(ms);
      }
    }
  }
}



function _rejectAllOk(err) {
  const all = pendingOk.splice(0);
  for (const w of all) {
    try { w.reject(err || new Error('Aborted')); } catch {}
  }

  // also reject an in-flight probe latch
  if (probeLatch) {
    try { probeLatch.reject(err || new Error('disconnected')); }
    finally { probeLatch = null; }
  }

  // Ensure we don't leave polling paused
  criticalDepth = 0;
  startTempPolling();
}

//Heater waiters
async function waitForHotend(target, tol = 1.0) {
  await sendCmd(`M104 S${Math.round(target)}`);
  await waitForOk().catch(()=>{});
  return new Promise(resolve => {
    let timer;
    const check = async () => {
      await sendCmd('M105', true);
      if (temps.hot != null && Math.abs(temps.hot - target) <= tol) {
        clearInterval(timer); resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}

async function waitForBed(target, tol = 1.0) {
  await sendCmd(`M140 S${Math.round(target)}`);
  await waitForOk().catch(()=>{});
  return new Promise(resolve => {
    let timer;
    const check = async () => {
      await sendCmd('M105', true);
      if (temps.bed != null && Math.abs(temps.bed - target) <= tol) {
        clearInterval(timer); resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}

/* =========================================================
   8) UI ACTIONS (PID, leveling, movement, sender, config)
========================================================= */

//PID
async function runBedPID() {
  const t = promptNumber('Enter bed PID target temp (S):', 60);
  if (t === null || !Number.isFinite(t)) return alert('Invalid temperature.');
  const c = promptCycles('bed');
  if (c === null) return;

  setActivity(`PID bed @ ${t}°C (C=${c})…`, 'warn');
  pidTarget = 'bed';
  try {
    await sendCmd(`M303 C${c} E-1 S${t} U`);
    await waitForOk();
  } finally {
    pidTarget = null;
  }
  logMsg('ℹ️ PID tuning can take a few minutes. Send M500 to save if required.');
}

async function runHotendPID() {
  const t = promptNumber('Enter nozzle PID target temp (S):', 220);
  if (t === null || !Number.isFinite(t)) return alert('Invalid temperature.');
  const c = promptCycles('hotend');
  if (c === null) return;

  setActivity(`PID hotend @ ${t}°C (C=${c})…`, 'warn');
  pidTarget = 'hotend';
  try {
    await sendCmd(`M303 C${c} E0 S${t} U`);
    await waitForOk();
  } finally {
    pidTarget = null;
  }
  logMsg('ℹ️ PID tuning can take a few minutes. Send M500 to save if required.');
}

//Leveling Shortcuts
async function readMesh(){
  await sendCmd('G29 T');
  setActivity('Parsing…', 'warn');
}

async function reprobe(){
  await sendCmdsSequential('G28', 'G29 T');
  setActivity('Probing…', 'warn');
}

//Manual
function sendManual(){
  const cmd = manualCmd.value.trim();
  if (!cmd) return;
  sendCmd(cmd).catch(err => logMsg('⚠️ ' + (err?.message || 'Send failed')));
  manualCmd.value = '';
}

//Jog and move
async function jog(axis, dir) {
  const step = parseFloat(jogStep.value) || 1;
  const dist = (dir * step).toFixed(3);
  const feed = (axis === 'Z') ? 300 : 3000;

  try {
    // Auto-home once if needed
    if (!isHomed) {
      setActivity('Auto-homing before jog…', 'warn');
      await sendCmd('G28'); await waitForOk().catch(()=>{});
      isHomed = true;

      // ⬇️ Cool to 0 after auto-home triggered by a jog
      await coolToIdle();

      setActivity('Jogging…', 'warn');
    }

    // Relative move, then back to absolute
    await sendCmd('G91');                        await waitForOk().catch(()=>{});
    await sendCmd(`G1 ${axis}${dist} F${feed}`); await waitForOk().catch(()=>{});
    await sendCmd('G90');                        await waitForOk().catch(()=>{});
    setActivity('Idle');

    // Update position readout
    await sendCmd('M114', true);                 await waitForOk().catch(()=>{});
  } catch (e) {
    setActivity('Jog failed', 'bad');
    logMsg('⚠️ Jog error: ' + (e?.message || e));
  }
}

//Sender
async function streamGcode(file) {
  if (!(connKind === 'virtual' || writer)) {
    alert('Not connected.');
    return;
  }

  cancelStream = false;
  cancelSend.disabled = true;
  hideEtaPill();

  if (sendProgress) sendProgress.style.width = '0%';
  if (sendStatus)   sendStatus.textContent   = 'Homing…';

  try {
    beep('start');
printerBeep('start');
    const text  = await file.text();
    const lines = text
      .split(/\r?\n/)
      .map(l => l.replace(/;.*/, '').trim())
      .filter(Boolean);

    if (!lines.length) { sendStatus.textContent = 'No G-code lines found'; return; }

    // Precompute "counting" stats for ETA
    const countingMask   = lines.map(isCountingLine);
    const countingTotal  = countingMask.reduce((a,b)=>a+(b?1:0),0);
    const warmupCount    = Math.min(400, Math.max(50, Math.floor(countingTotal * 0.01))); // 1% (50–400)

    // EMA for time/line (s), starts after first counting line
    let emaSecPerLine    = 0;
    const alpha          = 0.15;  // smoothing
    let sentCounting     = 0;
    let lastCountTs      = 0;
    let startedETA       = false;

    // Home before sending
    logMsg('🏠 Homing all axes (G28)…');
    await sendCmd('G28'); await waitForOk();

    let sent = 0;
    const total = lines.length;

    cancelSend.disabled = false;
    sendStatus.textContent = 'Sending…';
    showEtaPill('ETA: heating/preamble…', 'warn');

    for (let i = 0; i < lines.length; i++) {
      if (cancelStream) break;

      const line = lines[i];

      // Send + wait
      await sendCmd(line);
      const t0 = Date.now();
      await waitForOk();
      const t1 = Date.now();

      sent++;

      // Progress bar remains based on all lines
      const pct = Math.round((sent / total) * 100);
      sendProgress.style.width = pct + '%';
      sendStatus.textContent = `Sent ${sent}/${total} (${pct}%)`;

      // ---- ETA: count only real "print" lines ----
      if (countingMask[i]) {
        const deltaSec = (t1 - (lastCountTs || t1)) / 1000;
        lastCountTs = t1;

        if (!startedETA) {
          // First counting line establishes the clock
          startedETA = true;
          emaSecPerLine = Math.max(0.001, deltaSec);
          sentCounting = 1;
          showEtaPill('ETA: estimating…', 'warn');
        } else {
          sentCounting++;
          // Skip warmup lines from ETA display (but keep training EMA)
          emaSecPerLine = alpha * deltaSec + (1 - alpha) * emaSecPerLine;

          if (sentCounting >= warmupCount) {
            const remaining = Math.max(0, countingTotal - sentCounting);
            const remainingSec = emaSecPerLine * remaining;
            showEtaPill('ETA: ' + formatETA(remainingSec), 'warn');
          } else {
            showEtaPill(`ETA: stabilising… (${sentCounting}/${warmupCount})`, 'warn');
          }
        }
      } else {
        // While still in setup/heating, keep the pill clear and honest
        if (!startedETA) showEtaPill('ETA: heating/preamble…', 'warn');
      }

      // Small pacing delay to avoid flooding slower boards
      await new Promise(r => setTimeout(r, 10));
    }

    cancelSend.disabled = true;

    if (cancelStream) {
      sendStatus.textContent = 'Cancelled';
      showEtaPill('ETA: —', 'bad');
      beep('cancel');
printerBeep('cancel');
      exitPrintScreen(0, { tellHost: false }); 
      hideEtaPill();
      clearAllPidUi();
    } else {
      sendProgress.style.width = '100%';
      sendStatus.textContent = 'Done';
      showEtaPill('Complete', 'ok');
      beep('done');
printerBeep('done');
      exitPrintScreen(0, { tellHost: false }); 
    }

    setTimeout(hideEtaPill, 2500);
  } catch (err) {
    cancelSend.disabled = true;
    sendStatus.textContent = 'Error during send';
    showEtaPill('Error', 'bad');
    beep('error');
printerBeep('cancel');
    logMsg('❌ Send error: ' + (err?.message || err));
    setTimeout(hideEtaPill, 2500);
  }
}

//Quick helpers
async function coolToIdle(opts = {}) {
  const { force = false, postSync = false } = opts;

  try {
    // If we're calling right after G29 T, let firmware settle
    if (postSync) {
      await sendCmd('M400');              // wait for all moves/ISR queue
      await waitForOk().catch(()=>{});
      await sleep(150);                   // tiny UI/EEPROM settle
    }

    // Don’t spam heat-off if already “off” unless forced
    const wantHot = force || ((temps.hotTarget ?? 0) > 0);
    const wantBed = force || ((temps.bedTarget ?? 0) > 0);

    if (wantHot) { await sendCmd('M104 S0'); await waitForOk().catch(()=>{}); }
    if (wantBed) { await sendCmd('M140 S0'); await waitForOk().catch(()=>{}); }
  } finally {
    clearAllPidUi();
    setActivity('Temps set to 0', 'ok');
    updateLastUpdated();
  }
}

async function markHomedAfterG28() {
  await sendCmd('G28');
  await waitForOk().catch(()=>{});
  isHomed = true;

  // Ask for current pos and learn the signature
  await sendCmd('M114', true);
  await waitForOk().catch(()=>{});
}

/* =========================================================
   9) EVENT LISTENERS
========================================================= */

primeLine.addEventListener('click', runPrimeLine);

// --- Unlock button: remove any old listeners, bind once ---
(function bindUnlockClean(){
  const oldBtn = document.getElementById('unlockTempsBtn'); // correct id
  if (!oldBtn) return;
  const newBtn = oldBtn.cloneNode(true);          // drop any old listeners
  oldBtn.parentNode.replaceChild(newBtn, oldBtn);

  newBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
    setHeaterUnlocked(!heaterUnlocked);           // ← this alone
  });
})();





//Connection
connectBtn.addEventListener('click', () => { trace('Connect button'); connectPrinter(); });

disconnectBtn.addEventListener('click', () => {
  trace('Disconnect button');
  disconnectPrinter('user');
});

//Leveling
exportMeshBtn.addEventListener('click', () => {
  const fromInputs = collectMeshFromInputs();
  if (fromInputs) {
    exportMeshAsFile(fromInputs, 'current');
    return;
  }
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  const latest = hist.at(-1);
  if (latest && Array.isArray(latest) && latest.length === 4) {
    exportMeshAsFile(latest, 'latest');
  } else {
    alert('⚠️ No mesh available to export yet.');
  }
});

resetBtn.addEventListener('click', () => {
if (safeConfirm('Reset all saved data?')) { localStorage.clear(); location.reload(); }
});

readMeshBtn.addEventListener('click', homeAndProbe);

document.getElementById('levelForm').addEventListener('submit', (e) => {
  e.preventDefault();
  const mesh = [];
  for (let y=0; y<4; y++) {
    const row = [];
    for (let x=0; x<4; x++) {
      const v = parseFloat(document.getElementById(`cell-${y}-${x}`).value);
      row.push(isNaN(v) ? 0 : v);
    }
    mesh.push(row);
  }
  saveMeshLS(mesh);
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  alert('✅ Round submitted!');
});

//Manual
sendCmdBtn.addEventListener('click', sendManual);

manualCmd.addEventListener('input', () => { captureMode = null; });

clearLogBtn.addEventListener('click', () => { printerLog.textContent = ''; });

//Temps and fan
hotendApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(3000, parseInt(hotendSet.value) || 0)); // clamp silly inputs
  if (!guardHeaterSet('hotend', val, 'Hotend Set')) return;
  sendCmd(`M104 S${val}`);
});

hotendOff.addEventListener('click',   () => sendCmd('M104 S0'));

bedApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(3000, parseInt(bedSet.value) || 0));
  if (!guardHeaterSet('bed', val, 'Bed Set')) return;
  sendCmd(`M140 S${val}`);
});

bedOff.addEventListener('click',      () => sendCmd('M140 S0'));

fanSlider.addEventListener('input',   () => { fanVal.textContent = fanSlider.value; });

fanApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(255, parseInt(fanSlider.value)||0));
  live.lastFan255 = val;                  // ← add this
  sendCmd(`M106 S${val}`);
});

fanOff.addEventListener('click', () => {
  live.lastFan255 = 0;                    // ← add this
  sendCmd('M107');
});

//Movement
homeAll.addEventListener('click', async () => {
  try {
    setActivity('Homing…', 'warn');
    await sendCmd('G28'); await waitForOk().catch(()=>{});
    isHomed = true; // <-- mark homed
    await sendCmd('M104 S0'); await waitForOk().catch(()=>{});
    await sendCmd('M140 S0'); await waitForOk().catch(()=>{});
    setActivity('Homed & cooled', 'ok');
    updateLastUpdated();
  } catch (e) {
    setActivity('Home failed', 'bad');
    logMsg('⚠️ Home error: ' + (e?.message || e));
  }
});

disableMotors.addEventListener('click', () => sendCmd('M84'));

xMinus.addEventListener('click', () => jog('X', -1));

xPlus .addEventListener('click', () => jog('X', +1));

yMinus.addEventListener('click', () => jog('Y', -1));

yPlus .addEventListener('click', () => jog('Y', +1));

zMinus.addEventListener('click', () => jog('Z', -1));

zPlus .addEventListener('click', () => jog('Z', +1));

parkHead.addEventListener('click', () =>sendCmdsSequential('G90', 'G1 X0 Y0 Z10 F3000')
);

//EEPROM and Diag
readCfg.addEventListener('click', async () => {
  configBox.value = '';
  captureMode = 'config';
  stopTempPolling();
  await sendCmd('M503');
});

saveCfg.addEventListener('click', async () => { await sendCmd('M500'); });

fwInfo.addEventListener('click', () => {
  diagBox.value = '';
  captureMode = 'diag';
  stopTempPolling();
  sendCmd('M115');
});

tmcDiag.addEventListener('click', () => {
  diagBox.value = '';
  captureMode = 'diag';
  stopTempPolling();
  sendCmd('M122');
});


// Maintenance
preheatPLA .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S200', 'M140 S60');
});
preheatPETG.addEventListener('click', async () => {
  await sendCmdsSequential('M104 S240', 'M140 S80');
});
preheatABS .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S250', 'M140 S100');
});
cooldown   .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S0', 'M140 S0');
});

loadFil.addEventListener('click', async () => {
  const mm   = parseFloat(safePrompt('How many mm to LOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(safePrompt('Hotend temp for load (°C)?', '200'));
if (!guardHeaterSet('hotend', temp, 'Filament Load')) return;
  if (!Number.isFinite(temp) || temp <= 0) return;
  try {
    await sendCmd('G28');                    await waitForOk().catch(()=>{});
    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});
    await waitForHotend(temp, 1.0).catch(()=>{});
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{});
    await sendCmd('M82');                    await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});
    sendStatus.textContent = 'Filament load complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Load failed';
    console.error(e);
  }
});

unloadFil.addEventListener('click', async () => {
  const mm   = parseFloat(safePrompt('How many mm to UNLOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(safePrompt('Hotend temp for unload (°C)?', '200'));
if (!guardHeaterSet('hotend', temp, 'Filament Unload')) return;
  if (!Number.isFinite(temp) || temp <= 0) return;
  try {
    await sendCmd('G28');                    await waitForOk().catch(()=>{});
    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});
    await waitForHotend(temp, 1.0).catch(()=>{});
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E-${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{});
    await sendCmd('M82');                    await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});
    sendStatus.textContent = 'Filament unload complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Unload failed';
    console.error(e);
  }
});

//Sender
gcodeFile.addEventListener('change', () => {
  const connected = (connKind === 'virtual') || !!writer;
  sendGcode.disabled = !gcodeFile.files.length || !connected;
});

sendGcode.addEventListener('click', (e) => {
  e.preventDefault();
  e.stopImmediatePropagation();

  const file = gcodeFile?.files?.[0];
  if (!file) { gcodeFile.click(); return; }

  if (sessionStorage.getItem('skipPreflight') === '1') {
    streamGcode(file);
    return;
  }
  openPreflight(file);
});

cancelSend.addEventListener('click', async () => {
  if (sendStatus) sendStatus.textContent = 'Cancelling…';
  cancelSend.disabled = true;
  showEtaPill('Cancelling…', 'warn');

  cancelStream = true;
  _rejectAllOk(new Error('Cancelled'));

  await sendCmd('M104 S0'); await waitForOk().catch(() => {});
  await sendCmd('M140 S0'); await waitForOk().catch(() => {});
  await sendCmd('G90');     await waitForOk().catch(() => {});
  await sendCmd('G1 X0 Y0 Z10 F3000'); await waitForOk().catch(() => {});
  exitPrintScreen(0, { tellHost: false }); 
  hideEtaPill();
  clearAllPidUi();

  cancelStream = false; // ← reset so future macros work
});


//PID Tab
bedPidBtn.addEventListener('click', runBedPID);

hotendPidBtn.addEventListener('click', runHotendPID);

//APP lifecycle
window.addEventListener('unload', () => {
  if (postPrintTimer) clearTimeout(postPrintTimer);
});

document.addEventListener('DOMContentLoaded', () => {
  const aboutBtn = document.querySelector('#tabButtons button[data-tab="aboutTab"]');
  const allTabBtns = Array.from(document.querySelectorAll('#tabButtons button'));


  if (!aboutBtn || !eeOverlay || !eeModal || !eeClose || !eeBody) {
    console.warn('[EE] Modal wiring skipped (missing elements).');
    return;
  }

  // Any other tab click resets
  allTabBtns.forEach(btn => {
    if (btn !== aboutBtn) btn.addEventListener('click', resetStreak);
  });

  aboutBtn.addEventListener('click', () => {
    streak += 1;
    if (streak >= 5) {
      openEasterEgg();
      streak = 0;
    }
  });

    allTabBtns.forEach(btn => {
    if (btn !== aboutBtn) btn.addEventListener('click', () => { streak = 0; });
  });

  // Close handlers
  eeClose.addEventListener('click', closeEasterEgg);
  eeOverlay.addEventListener('click', closeEasterEgg);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && eeModal.style.display !== 'none') closeEasterEgg();
  });
});


const preBody  = document.getElementById('preBody');
const preStart = document.getElementById('preStart');
if (preBody && preStart) {
  preBody.addEventListener('change', (e) => {
    if (!(e.target instanceof HTMLInputElement) || !e.target.classList.contains('preChk')) return;
    const all = Array.from(preBody.querySelectorAll('.preChk')).every(c => c.checked);
    preStart.disabled = !all;
  });
}


//Selectors and toggles
if (levelPrinterSelect) {
  const saved = localStorage.getItem('levelPrinterChoice');
  if (saved) levelPrinterSelect.value = saved;

  levelPrinterSelect.addEventListener('change', () => {
    localStorage.setItem('levelPrinterChoice', levelPrinterSelect.value);
    updateLevelView();
  });
}

if (debugToggle) {
  debugToggle.checked = !!debugMode;
  debugToggle.addEventListener('change', () => {
    debugMode = debugToggle.checked;
    localStorage.setItem('debugMode', JSON.stringify(debugMode));
  });
}

if (virtualToggle) {
  virtualMode = JSON.parse(localStorage.getItem('virtualMode') || 'false');
  virtualToggle.checked = virtualMode;

  virtualToggle.addEventListener('change', () => {
    virtualMode = virtualToggle.checked;
    localStorage.setItem('virtualMode', JSON.stringify(virtualMode));
    // If user flips on while connected to real printer, we keep the current connection
    // The "Connect" button will use virtual when not already connected.
  });
}

/* =========================================================
   10) INIT (runs once)
========================================================= */
(function init() {
  const mesh = loadMeshLS();
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  setConnected(false);
  setOfflinePills();
  updateLevelView();
  initPrinterName();
  updateUnlockUi();
})();
</script>
</body>
</html>
