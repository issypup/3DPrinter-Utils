<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Printer Utils</title>
<meta name="author" content="issypup">
<meta name="date" content="2025-08-10">
<style>
  :root { --bar-h: 42px; }
  body {
    font-family: sans-serif;
    padding: calc(var(--bar-h) + 12px) 12px 56px;
    background: #f4f4f4;
  }
  h1, h2 { margin-top: 1rem; }
  table { border-collapse: collapse; margin-top: 0.5rem; }
  td, th { border: 1px solid #ccc; padding: 0.4rem; text-align: center; }
  input[type="number"], input[type="text"] { width: 100px; }
  button { padding: 0.45rem 0.9rem; margin: 0.25rem 0.25rem 0.25rem 0; cursor: pointer; }
  .tighten { background: #ffe0e0; }
  .loosen  { background: #e0f0ff; }
  .na      { background: #eaeaea; }
  .gap { border: none; background: transparent; color: #888; font-weight: bold; }
  #screwMap td { width: 110px; height: 60px; vertical-align: top; font-size: 0.85em; }

  /* Status bar (always visible) */
  #statusBar {
    position: fixed; top: 0; left: 0; right: 0; height: var(--bar-h);
    background: #222; color: #fff; display: flex; align-items: center;
    gap: 12px; padding: 0 12px; z-index: 9999; font-weight: 600;
  }
#statusBar .pill { 
  /* background:#444; */  /* remove this line if needed */
  transition: background-color 200ms ease, filter 200ms ease, transform 200ms ease;
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 10px; border-radius:999px; font-weight:600;
}

/* state colors – more specific than #statusBar .pill */
#statusBar .pill.idle    { background:#555; }     /* no target / idle */
#statusBar .pill.ready   { background:#2ecc71; }  /* green, stable */
#statusBar .pill.heating { background:#e74c3c; }  /* red, heating */
#statusBar .pill.cooling { background:#3498db; }  /* blue, cooling */
#statusBar .pill.offline { background:#444; color:#fff; }

/* pulse effect (used for heating/cooling) */
.pulse { animation: pillPulse 1.0s ease-in-out infinite; }
@keyframes pillPulse {
  0%   { transform:none; filter:brightness(100%); }
  50%  { transform:scale(1.05); filter:brightness(115%); }
  100% { transform:none; filter:brightness(100%); }
}

/* keep hotend/bed pills nicely spaced */
#temps { display: inline-flex; gap: 8px; }

  #statusBar .ok    { background: #2a7; }
  #statusBar .warn  { background: #f39c12; }
  #statusBar .bad   { background: #c0392b; }

  /* Tabs */
  #tabButtons { display:flex; flex-wrap: wrap; gap:6px; margin: 8px 0 4px; }
  #tabButtons button {
    padding: 0.45rem 1rem; cursor: pointer; background: #eee; border: 1px solid #ccc;
  }
  #tabButtons button.active { background: #ddd; font-weight: bold; }
  .tabContent { display: none; }
  .tabContent.active { display: block; }

  /* Controls rows inside tabs */
  .tabControls { display:flex; flex-wrap:wrap; gap:8px; margin: 8px 0 8px; align-items: center; }

  /* Printer log */
  #printerLog {
    background:#111; color:#ddd; border:1px solid #333;
    height: 220px; overflow:auto; padding:8px; white-space:pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    border-radius: 6px;
  }


  /* Footer status */
  #footerStatus {
    position: fixed; bottom: 0; left: 0; right: 0;
    background: #222; color: #fff; padding: 6px 10px;
    display:flex; justify-content: space-between; font-size: 0.9em;
  }

#aboutTab .aboutCard {
  background: #fff;
  border: 1px solid #ddd;
  padding: 16px 18px;
  border-radius: 8px;
  max-width: 560px;
  margin: 20px auto;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

#aboutTab .aboutCard h2 {
  margin: 0 0 10px;
  font-size: 1.3em;
  color: #333;
  border-bottom: 2px solid #eee;
  padding-bottom: 6px;
}

#aboutTab .aboutCard p { margin: 10px 0 0; color: #555; }

#aboutTab .kv {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  margin-top: 8px;
  font-size: 0.95em;
}
#aboutTab .kv span:first-child { color: #666; }
#aboutTab .kv span:last-child  { font-weight: 600; color: #111; }

  /* Small UI helpers */
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .col { display:flex; flex-direction:column; gap:6px; }
  .box { background:#fff; border:1px solid #ddd; padding:8px; border-radius:6px; }
  .label { font-weight:600; }
  .muted { color:#666; font-size:0.9em; }
  .widen { width: 220px; }
  .progress { height: 10px; background:#ddd; border-radius:999px; overflow:hidden; width:280px; }
  .progress > div { height:100%; background:#2a7; width:0%; }
</style>
</head>
<body>

<!-- Global Status Bar -->
<div id="statusBar">
  <span>PRINTER</span>
  <span id="connBadge" class="pill bad">Disconnected</span>
  <span id="activityBadge" class="pill">Idle</span>
  <span id="lastUpdated" class="pill">Last updated: —</span>
<span id="temps">
  <span class="pill idle" id="topHotendPill">Hotend: <span id="topHotend">--°C</span></span>
  <span class="pill idle" id="topBedPill">Bed: <span id="topBed">--°C</span></span>
</span>
</div>

<h1>3D Printer Utils</h1>

<!-- Tabs -->
<div id="tabButtons">
  <button data-tab="connectTab" class="active">Connection & Log</button>
  <button data-tab="levelTab">Leveling</button>
  <button data-tab="pidTab">PID Tuning</button>
  <button data-tab="tempTab">Temperature & Fan</button>
  <button data-tab="moveTab">Movement & Axes</button>
  <button data-tab="eepromTab">EEPROM / Config</button>
  <button data-tab="maintTab">Maintenance</button>
  <button data-tab="diagTab">Diagnostics</button>
  <button data-tab="senderTab">G-code Sender</button>
  <button data-tab="aboutTab">About</button>
</div>

<!-- TAB 1: Connection & Log -->
<div id="connectTab" class="tabContent active">
  <div class="tabControls" id="printerNavConnect">
    <label style="margin-left:8px;">
  <input type="checkbox" id="debugToggle">
  Debug
</label>
    <button id="connectBtn">Connect</button>
    <button id="disconnectBtn" disabled>Disconnect</button>
    <input id="manualCmd" placeholder="Manual G-code (e.g., M503)" />
    <button id="sendCmdBtn" disabled>Send</button>
    <button id="clearLogBtn" disabled>Clear Log</button>
  </div>

  <h2>Printer Log</h2>
  <div id="printerLog" aria-live="polite"></div>
</div>

<!-- TAB 2: Leveling -->
<div id="levelTab" class="tabContent">
  <div class="tabControls" id="printerNavLevel">
    <button id="readMeshBtn" disabled>Read Mesh (G29 T)</button>
    <button id="reprobeBtn" disabled>Re-Probe (G28 → G29 → G29 T)</button>
    <button type="button" id="exportManualBtn">Export Manual Mesh</button>
    <button type="button" id="exportPrinterBtn">Export Last Printer Mesh</button>
  </div>

  <!-- Mesh Form (manual + populated from printer) -->
  <form id="levelForm">
    <h2>Enter / View Mesh Readings</h2>
    <table><tbody id="meshInput"></tbody></table>
    <button type="submit">Submit Round</button>
    <button type="button" id="resetBtn">Reset Data</button>
  </form>

  <h2>Screw Suggestions</h2>
  <table>
    <thead>
      <tr><th>Screw</th><th>Avg (mm)</th><th>Action</th><th>Turn Strength</th></tr>
    </thead>
    <tbody id="screwTable"></tbody>
  </table>

  <h2>Screw Layout Map</h2>
  <table id="screwMap">
    <tr>
      <td id="A1"></td>
      <td class="gap">GAP</td>
      <td id="A2"></td>
      <td id="A3"></td>
    </tr>
    <tr>
      <td id="B1"></td>
      <td id="B2"></td>
      <td id="B3"></td>
      <td id="B4"></td>
    </tr>
    <tr>
      <td id="C1"></td>
      <td id="C2"></td>
      <td id="C3"></td>
      <td id="C4"></td>
    </tr>
  </table>
</div>

<!-- TAB 3: PID Tuning -->
<div id="pidTab" class="tabContent">
  <div class="tabControls" id="printerNavPID">
    <button id="bedPidBtn"    disabled>PID Bed (M303 E-1)</button>
    <button id="hotendPidBtn" disabled>PID Nozzle (M303 E0)</button>
  </div>
  <p>Runs <code>M303</code> autotune with a temperature you choose. After it completes, send <code>M500</code> if your firmware needs it to save to EEPROM.</p>
</div>

<!-- TAB 4: Temperature & Fan -->
<div id="tempTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Hotend</div>
      <div>
        <input type="number" id="hotendSet" value="200" min="0" max="300" /> °C
        <button id="hotendApply" disabled>Set (M104)</button>
        <button id="hotendOff"   disabled>Off (M104 S0)</button>
      </div>
      <div class="muted" id="hotendNow">Current: —</div>
    </div>
    <div class="col">
      <div class="label">Bed</div>
      <div>
        <input type="number" id="bedSet" value="60" min="0" max="130" /> °C
        <button id="bedApply" disabled>Set (M140)</button>
        <button id="bedOff"   disabled>Off (M140 S0)</button>
      </div>
      <div class="muted" id="bedNow">Current: —</div>
    </div>
    <div class="col">
      <div class="label">Part Cooling Fan</div>
      <div>
        <input type="range" id="fanSlider" min="0" max="255" value="0" />
        <span id="fanVal">0</span>/255
      </div>
      <div>
        <button id="fanApply" disabled>Apply (M106)</button>
        <button id="fanOff"   disabled>Off (M107)</button>
      </div>
    </div>
  </div>
  <div class="row box">
    <div class="label">Live Temperatures</div>
    <div class="muted">Polled via M105 every 3s while connected</div>
  </div>
</div>

<!-- TAB 5: Movement & Axes -->
<div id="moveTab" class="tabContent">
  <div class="row box">
    <div>
      <span class="label">Step</span>
      <select id="jogStep">
        <option value="1">1 mm</option>
        <option value="5" selected>5 mm</option>
        <option value="10">10 mm</option>
      </select>
    </div>
    <div>
      <button id="homeAll" disabled>Home All (G28)</button>
      <button id="disableMotors" disabled>Disable Steppers (M84)</button>
    </div>
  </div>
  <div class="row box">
    <div class="col">
      <div class="label">Move X</div>
      <button id="xMinus" disabled>◀ X-</button>
      <button id="xPlus"  disabled>X+ ▶</button>
    </div>
    <div class="col">
      <div class="label">Move Y</div>
      <button id="yMinus" disabled>▼ Y-</button>
      <button id="yPlus"  disabled>▲ Y+</button>
    </div>
    <div class="col">
      <div class="label">Move Z</div>
      <button id="zMinus" disabled>Z-</button>
      <button id="zPlus"  disabled>Z+</button>
    </div>
    <div id="axisPositions">
  <div>X: <span id="posX">—</span></div>
  <div>Y: <span id="posY">—</span></div>
  <div>Z: <span id="posZ">—</span></div>
</div>
  </div>
  <div class="row box">
    <button id="parkHead" disabled>Park Head (X0 Y0 Z10)</button>
  </div>
</div>

<!-- TAB 6: EEPROM / Config -->
<div id="eepromTab" class="tabContent">
  <div class="row box">
    <button id="readCfg" disabled>Read Config (M503)</button>
    <button id="saveCfg" disabled>Save (M500)</button>
    <!-- <button id="resetCfg" disabled>Factory Reset (M502)</button>-->
  </div>
  <textarea id="configBox" class="widen" rows="14" placeholder="Printer configuration will appear here…"></textarea>
</div>

<!-- TAB 7: Maintenance -->
<div id="maintTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Preheat</div>
      <button id="preheatPLA"  disabled>PLA (200/60)</button>
      <button id="preheatPETG" disabled>PETG (240/80)</button>
      <button id="preheatABS"  disabled>ABS (250/100)</button>
    </div>
    <div class="col">
      <div class="label">Cool Down</div>
      <button id="cooldown" disabled>Cool Down (M104 S0; M140 S0)</button>
    </div>
    <div class="col">
      <div class="label">Filament</div>
      <button id="loadFil"  disabled>Load (200°C)</button>
      <button id="unloadFil" disabled>Unload (200°C)</button>
    </div>
  </div>
</div>

<!-- TAB 8: Diagnostics -->
<div id="diagTab" class="tabContent">
  <div class="row box">
    <button id="fwInfo" disabled>Firmware Info (M115)</button>
    <button id="tmcDiag" disabled>TMC Diagnostics (M122)</button>
  </div>
  <textarea id="diagBox" class="widen" rows="14" placeholder="Diagnostics output…"></textarea>
</div>

<!-- TAB 9: G-code Sender -->
<div id="senderTab" class="tabContent">
  <div class="row box">
    <input type="file" id="gcodeFile" accept=".gcode,.gco,.gc,.txt" />
    <button id="sendGcode" disabled>Send File</button>
    <button id="cancelSend" disabled>Cancel</button>
    <div class="progress"><div id="sendProgress"></div></div>
    <span id="sendStatus" class="muted">Idle</span>
  </div>
  <p class="muted">Sends the file line-by-line over serial. Comments/blank lines are skipped. This is best for short jobs, calibration, or macros.</p>
</div>

<!-- TAB 10: About -->
<div id="aboutTab" class="tabContent">
  <div class="aboutCard">
    <h2>About</h2>
    <div class="kv"><span>Author: issypup</span></div>
    <div class="kv"><span>Date: 10 August 2025</span></div>
    <p>This tool helps manage 3D printer tasks / maintenance from your browser, it needs a web serial capable browser</p>
  </div>
</div>

<div id="footerStatus">
  <span id="lastCmd">Last Cmd: —</span>
  <span>GitHub Pages ready · LocalStorage only</span>
</div>

<script>
'use strict';
/* =============================
   Tabs (with session memory)
============================= */
(function initTabs(){
  document.querySelectorAll('#tabButtons button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const target = btn.getAttribute('data-tab');
      sessionStorage.setItem('currentTab', target);
      document.querySelectorAll('.tabContent').forEach(tab => {
        tab.classList.toggle('active', tab.id === target);
      });
    });
  });
  const savedTab = sessionStorage.getItem('currentTab');
  if (savedTab && document.getElementById(savedTab)) {
    document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
    document.querySelector(`#tabButtons button[data-tab="${savedTab}"]`)?.classList.add('active');
    document.querySelectorAll('.tabContent').forEach(tab => {
      tab.classList.toggle('active', tab.id === savedTab);
    });
  }
})();

/* =============================
   Global refs & state
============================= */
// UI elements

const debugToggle = document.getElementById('debugToggle');
let debugMode = JSON.parse(localStorage.getItem('debugMode') || 'false');
if (debugToggle) {
  debugToggle.checked = !!debugMode;
  debugToggle.addEventListener('change', () => {
    debugMode = debugToggle.checked;
    localStorage.setItem('debugMode', JSON.stringify(debugMode));
  });
}

// Lines that are noisy and should be hidden unless Debug is ON
const NOISY_REGEX =
  /^(?:echo:busy:\s*processing|\/\/action:.*|setnewscreen(?:\s*\([^)]*\))?:?.*|invoking handler for screen.*)/i;

function isNoisyLine(s) { return NOISY_REGEX.test(s); }

// Extra guard: catch any future SetNewScreen format
function isSetNewScreenLine(s) {
  return /^setnewscreen\b/i.test(s);
}

function normalizeLine(s) {
  // strip ANSI colors / odd control chars just in case
  s = s.replace(/\x1b\[[0-9;]*m/g, '').replace(/[\u0000-\u001F\u007F]/g, '');
  // fix common firmware typos
  s = s.replace(/\bcontinueing\b/gi, 'continuing');
  return s;
}

const posXEl = document.getElementById('posX');
const posYEl = document.getElementById('posY');
const posZEl = document.getElementById('posZ');

const POS_REGEX = /X:?\s*([+-]?\d*\.?\d+)\s+Y:?\s*([+-]?\d*\.?\d+)\s+Z:?\s*([+-]?\d*\.?\d+)/i;

const meshInput = document.getElementById('meshInput');
const screwTable = document.getElementById('screwTable');
const printerLog = document.getElementById('printerLog');

const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const readMeshBtn = document.getElementById('readMeshBtn');
const reprobeBtn = document.getElementById('reprobeBtn');
const sendCmdBtn = document.getElementById('sendCmdBtn');
const manualCmd = document.getElementById('manualCmd');
const clearLogBtn = document.getElementById('clearLogBtn');
const resetBtn = document.getElementById('resetBtn');
const bedPidBtn = document.getElementById('bedPidBtn');
const hotendPidBtn = document.getElementById('hotendPidBtn');

const hotendSet = document.getElementById('hotendSet');
const bedSet = document.getElementById('bedSet');
const hotendApply = document.getElementById('hotendApply');
const hotendOff   = document.getElementById('hotendOff');
const bedApply    = document.getElementById('bedApply');
const bedOff      = document.getElementById('bedOff');
const hotendNow   = document.getElementById('hotendNow');
const bedNow      = document.getElementById('bedNow');
const fanSlider   = document.getElementById('fanSlider');
const fanVal      = document.getElementById('fanVal');
const fanApply    = document.getElementById('fanApply');
const fanOff      = document.getElementById('fanOff');

const jogStep = document.getElementById('jogStep');
const homeAll = document.getElementById('homeAll');
const disableMotors = document.getElementById('disableMotors');
const xMinus = document.getElementById('xMinus');
const xPlus  = document.getElementById('xPlus');
const yMinus = document.getElementById('yMinus');
const yPlus  = document.getElementById('yPlus');
const zMinus = document.getElementById('zMinus');
const zPlus  = document.getElementById('zPlus');
const parkHead = document.getElementById('parkHead');

const readCfg = document.getElementById('readCfg');
const saveCfg = document.getElementById('saveCfg');
// const resetCfg= document.getElementById('resetCfg');
const configBox = document.getElementById('configBox');

const preheatPLA  = document.getElementById('preheatPLA');
const preheatPETG = document.getElementById('preheatPETG');
const preheatABS  = document.getElementById('preheatABS');
const cooldown    = document.getElementById('cooldown');
const loadFil     = document.getElementById('loadFil');
const unloadFil   = document.getElementById('unloadFil');

const fwInfo = document.getElementById('fwInfo');
const tmcDiag = document.getElementById('tmcDiag');
const diagBox = document.getElementById('diagBox');

const gcodeFile = document.getElementById('gcodeFile');
const sendGcode = document.getElementById('sendGcode');
const cancelSend= document.getElementById('cancelSend');
const sendProgress = document.getElementById('sendProgress');
const sendStatus   = document.getElementById('sendStatus');

const connBadge = document.getElementById('connBadge');
const activityBadge = document.getElementById('activityBadge');
const lastUpdated = document.getElementById('lastUpdated');
const lastCmd = document.getElementById('lastCmd');

let meshScratch = Array.from({ length: 4 }, () => Array(4).fill(null));

// Serial state
let port = null;
let reader = null;
let writer = null;
let textDecoder = null;
let reading = false;
let tempTimer = null;     // M105 poll timer
let cancelStream = false; // gcode sender cancel flag
let captureMode = null;   // null | 'config' | 'diag'
let postPrintTimer = null;

/* =============================
   Constants & maps
============================= */
const screwAffects = {
  A1: [[0,0],[0,1],[1,0],[1,1]],
  A2: [[0,1],[0,2],[1,1],[1,2]],
  A3: [[0,2],[0,3],[1,2],[1,3]],
  B1: [[1,0],[1,1],[2,0],[2,1]],
  B2: [[1,1],[1,2],[2,1],[2,2]],
  B3: [[1,2],[1,3],[2,2],[2,3]],
  B4: [[2,3],[1,3],[3,3]],
  C1: [[2,0],[2,1],[3,0],[3,1]],
  C2: [[2,1],[2,2],[3,1],[3,2]],
  C3: [[2,2],[2,3],[3,2],[3,3]],
  C4: [[3,3]]
};

// --- Temperature line matcher & polling helpers ---

const topHotendPill = document.getElementById('topHotendPill');
const topBedPill    = document.getElementById('topBedPill');
const topHotendText = document.getElementById('topHotend');
const topBedText    = document.getElementById('topBed');

function exitPrintScreen(delayMs = 0) {
  if (postPrintTimer) { clearTimeout(postPrintTimer); postPrintTimer = null; }

  const fire = () => {
    if (port && writer) {
      logMsg('⌛ Closing print screen in firmware…');
      // Quiet; firmware usually doesn’t send an OK for this
      sendCmd('//action:cancel', true);
    }
  };

  if (delayMs > 0) {
    postPrintTimer = setTimeout(() => {
      fire();
      postPrintTimer = null;
    }, delayMs);
  } else {
    fire();
  }
}

// Clear pending timer when the page unloads
window.addEventListener('unload', () => { 
  if (postPrintTimer) clearTimeout(postPrintTimer); 
});

function setOfflinePills() {
  topHotendText.textContent = '--°C';
  topBedText.textContent = '--°C';
  topHotendPill.className = 'pill offline';
  topBedPill.className = 'pill offline';
  hotendNow.textContent = 'Current: —';
  bedNow.textContent = 'Current: —';
}

// Support lines with only T or only B (in any order)
const TEMP_T = /T\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;
const TEMP_B = /B\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;

const TELEMETRY_REGEX = /(?:\bT\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\bB\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\b@:\s*\d+)|(?:\bB@:\s*\d+)/i;
function isTelemetryLine(s) { return TELEMETRY_REGEX.test(s); }

// Simple helpers for the top-bar pills
function setTempPill(pillEl, textEl, curr, target) {
  // text
  textEl.textContent = (target != null && !Number.isNaN(target))
    ? `${curr.toFixed(1)}°C / ${Math.round(target)}°`
    : `${curr.toFixed(1)}°C`;

  // state
  const state = tempState(curr, target); // 'idle' | 'ready' | 'heating' | 'cooling'
  pillEl.classList.remove('offline','idle','ready','heating','cooling','pulse'); // <-- remove offline too
  pillEl.classList.add(state);
  if (state === 'heating' || state === 'cooling') pillEl.classList.add('pulse');
}

function startTempPolling() {
  if (!tempTimer) tempTimer = setInterval(() => sendCmd('M105', true), 3000);
}
function stopTempPolling() {
  if (tempTimer) { clearInterval(tempTimer); tempTimer = null; }
}

/* =============================
   UI helpers & logging
============================= */

// Accepts *one* G29-related line and updates meshScratch.
// Supports: "X0 Y1 Z-0.0945" and row lines like "1 -0.095 -0.057 +0.006 +0.025"
function ingestMeshLine(line) {
  const s = line.trim();

  // Row-based: "0  -0.148  -0.107  -0.074  -0.012"
  const row = s.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
  if (row) {
    const fwY = parseInt(row[1], 10);
    const uiY = 3 - fwY;                          // <-- flip Y here
    meshScratch[uiY][0] = parseFloat(row[2]);
    meshScratch[uiY][1] = parseFloat(row[3]);
    meshScratch[uiY][2] = parseFloat(row[4]);
    meshScratch[uiY][3] = parseFloat(row[5]);
    return meshIsComplete();
  }

  // Point formats: "X0 Y1 Z-0.0945" / "X: 0; Y: 1; ... Z..." / "X0 Y1 Z..."
  const pXY = s.match(/X\s*:?\s*(\d)\s*[,; ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i)
            || s.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
  if (pXY) {
    const x = parseInt(pXY[1], 10);
    const fwY = parseInt(pXY[2], 10);
    const uiY = 3 - fwY;                          // <-- flip Y here
    const val = parseFloat(pXY[3]);
    if (x < 4 && fwY < 4 && Number.isFinite(val)) {
      meshScratch[uiY][x] = val;
      return meshIsComplete();
    }
  }

  return false;
}



function resetMeshScratch() {
  meshScratch = Array.from({ length: 4 }, () => Array(4).fill(null));
}
function meshIsComplete(m = meshScratch) {
  return m.every(row => row.every(v => typeof v === 'number' && !Number.isNaN(v)));
}

function updateAxisPanel(x, y, z) {
  posXEl.textContent = x.toFixed(3);
  posYEl.textContent = y.toFixed(3);
  posZEl.textContent = z.toFixed(3);
}

function updateTempPanel() {
  if (temps.hot != null) {
    hotendNow.textContent = `Current: ${temps.hot.toFixed(1)}°C` +
      (temps.hotTarget != null ? ` / ${Math.round(temps.hotTarget)}°` : '');
  } else {
    hotendNow.textContent = 'Current: —';
  }

  if (temps.bed != null) {
    bedNow.textContent = `Current: ${temps.bed.toFixed(1)}°C` +
      (temps.bedTarget != null ? ` / ${Math.round(temps.bedTarget)}°` : '');
  } else {
    bedNow.textContent = 'Current: —';
  }
}

// Decide state from current vs target
function tempState(current, target, tolerance = 0.5) {
  if (target == null || Number.isNaN(target)) return 'idle';
  const diff = target - current;
  if (Math.abs(diff) <= tolerance) return 'ready';
  return diff > 0 ? 'heating' : 'cooling';
}

function stateFromTemps(curr, target, eps = 0.5) {
  if (target == null || isNaN(target)) return 'idle';
  if (curr < target - eps) return 'heating';
  if (curr > target + eps) return 'cooling';
  return 'ready';
}

// Apply classes to a pill (and pulse only when heating/cooling)
function setPillState(pillEl, state) {
  pillEl.classList.remove('idle','ready','heating','cooling','pulse');
  pillEl.classList.add(state);
  if (state === 'heating' || state === 'cooling') pillEl.classList.add('pulse');
}

// Track previous temps to detect direction if you ever want trend-based logic
const temps = { hot: null, hotTarget: null, bed: null, bedTarget: null };

function setActivity(text, cls='') {
  activityBadge.textContent = text;
  activityBadge.className = 'pill ' + cls;
}
function setConnected(connected) {
  if (connected) {
    connBadge.textContent = 'Connected';
    connBadge.className = 'pill ok';

    // Clear offline state for temp pills
    topHotendPill.classList.remove('offline');
    topBedPill.classList.remove('offline');
    topHotendPill.classList.add('idle');
    topBedPill.classList.add('idle');
    updateTempPanel();
    startTempPolling();
  } else {
    connBadge.textContent = 'Disconnected';
    connBadge.className = 'pill bad';

    stopTempPolling();
    setOfflinePills(); // reset temps to --°C
  }

  // Tab/button enabling/disabling
  connectBtn.disabled   = connected;
  disconnectBtn.disabled= !connected;
  readMeshBtn.disabled  = !connected;
  reprobeBtn.disabled   = !connected;
  sendCmdBtn.disabled   = !connected;
  bedPidBtn.disabled    = !connected;
  hotendPidBtn.disabled = !connected;
  clearLogBtn.disabled  = !connected;

  hotendApply.disabled = !connected;
  hotendOff.disabled   = !connected;
  bedApply.disabled    = !connected;
  bedOff.disabled      = !connected;
  fanApply.disabled    = !connected;
  fanOff.disabled      = !connected;

  homeAll.disabled = !connected;
  disableMotors.disabled = !connected;
  xMinus.disabled = xPlus.disabled =
  yMinus.disabled = yPlus.disabled =
  zMinus.disabled = zPlus.disabled = !connected;
  parkHead.disabled = !connected;

  readCfg.disabled = !connected;
  saveCfg.disabled = !connected;

  preheatPLA.disabled = preheatPETG.disabled =
  preheatABS.disabled = cooldown.disabled =
  loadFil.disabled = unloadFil.disabled = !connected;

  fwInfo.disabled = tmcDiag.disabled = !connected;

  sendGcode.disabled = !connected || !gcodeFile.files.length;
  cancelSend.disabled= true;
}

function _logBase(msg) {
  if (!msg.endsWith('\n')) msg += '\n';
  printerLog.textContent += msg;
  printerLog.scrollTop = printerLog.scrollHeight;
}
function logMsg(msg) {
  const lines = String(msg).split(/\r?\n/);
  for (let line of lines) {
    if (!line) continue;
    line = normalizeLine(line);

    if (!debugMode && (isSetNewScreenLine(line) || isNoisyLine(line))) continue;
    if (!debugMode && isTelemetryLine(line)) continue;

    if (captureMode === 'config') {
      configBox.value += line + '\n';
      configBox.scrollTop = configBox.scrollHeight;
    } else if (captureMode === 'diag') {
      diagBox.value += line + '\n';
      diagBox.scrollTop = diagBox.scrollHeight;
    }
    _logBase(line);
  }
}



function updateLastUpdated() { 
  lastUpdated.textContent = 'Last updated: ' + new Date().toLocaleTimeString(); 
  updateTempPanel();
}

function setLastCmd(cmd) { lastCmd.textContent = 'Last Cmd: ' + cmd; }

/* =============================
   Mesh parsing & persistence
============================= */
function tryParseMeshFromLines(lines) {
  const mesh = Array.from({ length: 4 }, () => Array(4).fill(null));

  for (const raw of lines) {
    const line = raw.trim();

    // Row-based
    const m = line.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
    if (m) {
      const fwY = parseInt(m[1], 10);
      const uiY = 3 - fwY; // flip Y
      const vals = [parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), parseFloat(m[5])];
      mesh[uiY] = vals;
      continue;
    }

    // Point-by-point
    const p1 = line.match(/[\(\[](\d)\s*,\s*(\d)[\)\]]\s+([+-]?\d*\.?\d+)/);
    const p2 = line.match(/X\s*:?\s*(\d)\s*;?\s*[, ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i);
    const p3 = line.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
    const mP = p1 || p2 || p3;
    if (mP) {
      const x   = parseInt(mP[1], 10);
      const fwY = parseInt(mP[2], 10);
      const uiY = 3 - fwY; // flip Y
      const val = parseFloat(mP[3]);
      if (x < 4 && fwY < 4) mesh[uiY][x] = val;
    }
  }

  const complete = mesh.every(row => row.every(val => typeof val === 'number' && !isNaN(val)));
  return complete ? mesh : null;
}

function loadMeshLS() {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  return hist.at(-1) || Array.from({length:4},()=>Array(4).fill(''));
}
function saveMeshLS(mesh) {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  hist.push(mesh);
  localStorage.setItem('levels', JSON.stringify(hist));
}

/* =============================
   Mesh calculations & rendering
============================= */
function getScrewData(mesh) {
  const result = {};
  for (const screw in screwAffects) {
    const points = screwAffects[screw];
    const values = points.map(([y,x]) => mesh?.[y]?.[x]).filter(v => typeof v === 'number' && !isNaN(v));
    const avg = values.length ? values.reduce((a,b)=>a+b,0)/values.length : null;
    let suggestion='N/A', turn='N/A';
    if (avg !== null) {
      if (avg >  0.07) { suggestion='Tighten (Clockwise)';        turn='Strong (1/4 turn)'; }
      else if (avg > 0.04) { suggestion='Tighten (Clockwise)';    turn='Moderate (1/8 turn)'; }
      else if (avg > 0.02) { suggestion='Tighten (Clockwise)';    turn='Slight (1/16 turn)'; }
      else if (avg < -0.07){ suggestion='Loosen (Counterclockwise)'; turn='Strong (1/4 turn)'; }
      else if (avg < -0.04){ suggestion='Loosen (Counterclockwise)'; turn='Moderate (1/8 turn)'; }
      else if (avg < -0.02){ suggestion='Loosen (Counterclockwise)'; turn='Slight (1/16 turn)'; }
      else { suggestion='No change'; }
    }
    result[screw] = { avg: avg?.toFixed(3) ?? 'N/A', suggestion, turn };
  }
  return result;
}
function renderMeshInputs(mesh) {
  meshInput.innerHTML = '';
  for (let y=0; y<4; y++) {
    const tr = document.createElement('tr');
    for (let x=0; x<4; x++) {
      const v = mesh?.[y]?.[x];
      tr.innerHTML += `<td><input type="number" step="0.001" id="cell-${y}-${x}" value="${typeof v==='number'? v.toFixed(3): ''}" required></td>`;
    }
    meshInput.appendChild(tr);
  }
}
function renderSuggestions(mesh) {
  const data = getScrewData(mesh);
  screwTable.innerHTML = '';
  const layout = ['A1','GAP','A2','A3','B1','B2','B3','B4','C1','C2','C3','C4'];
  for (const sName of layout) {
    if (sName === 'GAP') continue;
    const s = data[sName];
    const tr = document.createElement('tr');
    tr.className = s.suggestion.includes('Tighten') ? 'tighten' :
                   s.suggestion.includes('Loosen') ? 'loosen' : 'na';
    tr.innerHTML = `<td>${sName}</td><td>${s.avg}</td><td>${s.suggestion}</td><td>${s.turn}</td>`;
    screwTable.appendChild(tr);
    const cell = document.getElementById(sName);
    if (cell) {
      cell.className = tr.className;
      cell.innerHTML = `<strong>${sName}</strong><br>${s.avg} mm<br>${s.turn!=='N/A'? s.turn : ''}`;
    }
  }
}

console.log('SYNC CHECK REACHED');

/* =============================
   Serial I/O
============================= */
async function connectPrinter() {
  try {
    if (!('serial' in navigator)) {
      alert('Web Serial API not supported. Use Chrome/Edge/Brave on desktop.');
      return;
    }

    setActivity('Connecting...', 'warn');

    if (!port) {
      const granted = await navigator.serial.getPorts();
      port = granted[0] || await navigator.serial.requestPort();
    }

    if (!port.readable || !port.writable) {
      try {
        await port.open({ baudRate: 115200 });
      } catch (e) {
        if (!/already open/i.test(String(e))) throw e;
        logMsg('Port is already open; reusing existing connection.');
      }
    }

    // clean up old streams (no optional chaining)
    try { if (reader) await reader.cancel(); } catch (e) {}
    try { if (reader) reader.releaseLock(); } catch (e) {}
    try { if (writer) writer.releaseLock(); } catch (e) {}

    const tds = new TextDecoderStream();
    textDecoder = tds;
    port.readable.pipeTo(tds.writable).catch(function() {});
    reader = tds.readable.getReader();
    writer = port.writable.getWriter();

    setConnected(true);
    updateTempPanel();
    startTempPolling();
    updateLastUpdated();
    setActivity('Connected', 'ok');
    logMsg('Connected.');

    if (!reading) readLoop();
  } catch (err) {
    setConnected(false);
    setActivity('Connect error', 'bad');
    logMsg('' + err.message);
  }
}


async function disconnectPrinter() {
  try {
    setConnected(false);
    setActivity('Disconnecting…', 'warn');

    try { await reader?.cancel(); } catch {}
    try { reader?.releaseLock(); } catch {}
    try { writer?.releaseLock(); } catch {}
    try { await port?.close(); } catch {}

    port = null;
    reader = null;
    writer = null;

    // 🧹 Clear any pending post-print exit timers
    if (postPrintTimer) {
      clearTimeout(postPrintTimer);
      postPrintTimer = null;
    }

    setActivity('Disconnected', 'ok');
    logMsg('🔌 Disconnected.');
  } catch (err) {
    logMsg('❌ Disconnect error: ' + err.message);
  }
}

let rxBuffer = '';

// --- ACK / flow control state ---
let waitingResolvers = [];       // array of resolve() for waitForOk()
let isBusyProcessing = false;    // set when "busy: processing" seen
let lastOkAt = 0;

// ---- OK waiters (no-timeout) ----
let pendingOk = []; // queue of resolvers waiting for 'ok'
function _resolveNextOk() {
  const waiter = pendingOk.shift();
  if (waiter) waiter.resolve();
}
function _rejectAllOk(err) {
  const all = pendingOk.splice(0);
  for (const w of all) w.reject(err || new Error('Aborted'));
}

function resolveAllWaiting() {
  lastOkAt = Date.now();
  waitingResolvers.splice(0).forEach(fn => { try { fn(); } catch {} });
}

// Wait forever until the next 'ok' arrives.
// Aborts only if: disconnect happens or cancelSend is pressed.
function waitForOk() {
  return new Promise((resolve, reject) => {
    // If already disconnected, fail fast
    if (!port || !writer) {
      reject(new Error('Disconnected'));
      return;
    }
    // If user has requested cancel, also abort
    if (cancelStream) {
      reject(new Error('Cancelled'));
      return;
    }
    pendingOk.push({ resolve, reject });
  });
}

async function waitForHotend(target, tol = 1.0) {
  // tell the printer what we want (non-blocking)
  await sendCmd(`M104 S${Math.round(target)}`);
  await waitForOk().catch(() => {});

  // poll until within tolerance (uses existing M105 poll, but we also kick it)
  return new Promise((resolve) => {
    let timer;
    const check = async () => {
      // nudge a temp report so UI and temps[] keep updating
      await sendCmd('M105', true);

      if (temps.hot != null && Math.abs(temps.hot - target) <= tol) {
        clearInterval(timer);
        resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}


async function waitForBed(target, tol = 1.0) {
  // tell the printer what we want (non-blocking)
  await sendCmd(`M140 S${Math.round(target)}`);
  await waitForOk().catch(() => {});

  // poll until within tolerance (uses existing M105 poll, but we also kick it)
  return new Promise((resolve) => {
    let timer;
    const check = async () => {
      // nudge a temp report so UI and temps[] keep updating
      await sendCmd('M105', true);

      if (temps.bed != null && Math.abs(temps.bed - target) <= tol) {
        clearInterval(timer);
        resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}

async function readLoop() {
  reading = true;
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      if (value == null) continue;

      // accumulate until full lines
      rxBuffer += value;
      const parts = rxBuffer.split(/\r?\n/);
      rxBuffer = parts.pop(); // keep incomplete tail

      for (const raw of parts) {
        const line = raw.trim();
        if (!line) continue;

        // 👇 declare per-line matches *here*
        const tMatch = line.match(TEMP_T);
        const bMatch = line.match(TEMP_B);

        let prettyTempLog = null;

        // --- 1) TEMP UPDATE FIRST (robust to T:/B: arriving separately) ---
        if (tMatch) {
          const tCur = parseFloat(tMatch[1]);
          const tTar = tMatch[2] !== undefined ? parseFloat(tMatch[2]) : null;
          if (Number.isFinite(tCur)) {
            temps.hot = tCur;
            temps.hotTarget = Number.isFinite(tTar) ? tTar : null;
            setTempPill(topHotendPill, topHotendText, temps.hot, temps.hotTarget);
          }
        }

        if (bMatch) {
          const bCur = parseFloat(bMatch[1]);
          const bTar = bMatch[2] !== undefined ? parseFloat(bMatch[2]) : null;
          if (Number.isFinite(bCur)) {
            temps.bed = bCur;
            temps.bedTarget = Number.isFinite(bTar) ? bTar : null;
            setTempPill(topBedPill, topBedText, temps.bed, temps.bedTarget);
          }
        }

        if (tMatch || bMatch) updateTempPanel();

        // If Debug is ON and this was a telemetry line, prepare pretty format
        if (debugMode && (tMatch || bMatch)) {
          const hotStr = temps.hot != null
            ? `${temps.hot.toFixed(1)}${temps.hotTarget != null ? ' / ' + Math.round(temps.hotTarget) : ''}`
            : '--';
          const bedStr = temps.bed != null
            ? `${temps.bed.toFixed(1)}${temps.bedTarget != null ? ' / ' + Math.round(temps.bedTarget) : ''}`
            : '--';
          prettyTempLog = `🌡 Hotend ${hotStr} · Bed ${bedStr}`;
        }

        // --- 2) Hide telemetry spam from the main log/capture (but show when Debug is ON) ---
        const isTelemetry = TELEMETRY_REGEX.test(line);
        let out = normalizeLine(line);

        const posMatch = line.match(POS_REGEX);
        if (posMatch) {
          const x = parseFloat(posMatch[1]);
          const y = parseFloat(posMatch[2]);
          const z = parseFloat(posMatch[3]);
          if ([x, y, z].every(Number.isFinite)) {
            updateAxisPanel(x, y, z);
          }
        }

        // 🔇 hard skip for screen chatter when Debug is OFF
        if (!debugMode && (isSetNewScreenLine(out) || isNoisyLine(out))) {
          continue;
        }

        // ✅ If Debug ON: log pretty temp if available, else log raw line
        // ✅ If Debug OFF: skip telemetry but log others
        if (debugMode) {
          if (prettyTempLog) {
            logMsg(prettyTempLog);
          } else {
            logMsg(out);
          }
        } else if (!isTelemetry) {
          logMsg(out);
        }

        // --- 3) Mesh parse from this single line (covers point formats) ---
        const justCompleted = ingestMeshLine(out);
if (justCompleted) {
  const meshForUi = meshScratch.map(r => r.slice());     // orientation already correct
  setActivity('Mesh parsed', 'ok');
  saveMeshLS(meshForUi);
  renderMeshInputs(meshForUi);
  renderSuggestions(meshForUi);
  updateLastUpdated();
  resetMeshScratch();
}

        // --- 4) PID status lights ---
        if (/PID Autotune start/i.test(line))    setActivity('PID tuning…', 'warn');
        if (/PID Autotune finished/i.test(line)) setActivity('PID tuning complete', 'ok');
        if (/PID Autotune failed/i.test(line))   setActivity('PID tuning failed', 'bad');

        // --- 5) Handle 'ok' ---
        if (/^ok\b/i.test(line)) {
          updateLastUpdated();
          if (captureMode) {
            captureMode = null;
            startTempPolling();
          }
          _resolveNextOk(); // unblocks waitForOk() callers
        }
      }
    }
  } catch (err) {
    logMsg('⚠️ Read error: ' + err.message);
  } finally {
    reading = false;
  }
}

async function sendCmd(cmd, quiet = false) {
  if (!writer) { logMsg('⚠️ Not connected.'); return; }
  setLastCmd(cmd);
  setActivity('Sending…', 'warn');

  await writer.write(new TextEncoder().encode(cmd + '\n'));
  if (!quiet) logMsg('>> ' + cmd);

  // 🔸 update the clock right after we issue the command
  updateLastUpdated();

  setActivity('Waiting…', 'warn');
}

/* =============================
   PID, Leveling & other actions
============================= */
function promptNumber(message, def) {
  const raw = prompt(message, String(def));
  if (raw === null) return null;
  const n = parseFloat(raw);
  return Number.isFinite(n) ? n : NaN;
}
async function runBedPID() {
  const t = promptNumber('Enter bed PID target temp (S):', 60);
  if (t === null) return;
  if (!Number.isFinite(t)) return alert('Invalid temperature.');
  setActivity(`PID bed @ ${t}°C…`, 'warn');
  await sendCmd(`M303 C5 E-1 S${t} U`);
  logMsg('ℹ️ PID tuning can take a few minutes. After success, send M500 to save if required.');
}
async function runHotendPID() {
  const t = promptNumber('Enter nozzle PID target temp (S):', 220);
  if (t === null) return;
  if (!Number.isFinite(t)) return alert('Invalid temperature.');
  setActivity(`PID hotend @ ${t}°C…`, 'warn');
  await sendCmd(`M303 C5 E0 S${t} U`);
  logMsg('ℹ️ PID tuning can take a few minutes. After success, send M500 to save if required.');
}
async function readMesh() {
  await sendCmd('G29 T');
  setActivity('Parsing…', 'warn');
}
async function reprobe() {
  await sendCmd('G28');
  await sendCmd('G29 T');
  setActivity('Probing…', 'warn');
}
function sendManual() {
  const cmd = manualCmd.value.trim();
  if (!cmd) return;
  sendCmd(cmd);
  manualCmd.value = '';
}

/* =============================
   Movement & G-code sender
============================= */
function jog(axis, dir) {
  const step = parseFloat(jogStep.value);
  const dist = dir * step;
  // relative move then back to absolute
  sendCmd('G91');
  const feed = (axis === 'Z') ? 300 : 3000;
  sendCmd(`G1 ${axis}${dist.toFixed(3)} F${feed}`);
  sendCmd('G90');
}

async function streamGcode(file) {
  if (!writer) { alert('Not connected.'); return; }

  cancelStream = false;
  sendStatus.textContent = 'Homing…';
  cancelSend.disabled = true;

  logMsg('🏠 Homing all axes (G28)…');
  await sendCmd('G28');
  await waitForOk().catch(err => { throw err; });

  const text = await file.text();
  const lines = text
    .split(/\r?\n/)
    .map(l => l.replace(/;.*/, '').trim())
    .filter(Boolean);

  let sent = 0;
  cancelSend.disabled = false;
  sendStatus.textContent = 'Sending…';

  for (const line of lines) {
    if (cancelStream) break;

    await sendCmd(line);
    await waitForOk().catch(err => { throw err; });

    sent++;
    const pct = Math.round((sent / lines.length) * 100);
    sendProgress.style.width = pct + '%';
    sendStatus.textContent = `Sent ${sent}/${lines.length} (${pct}%)`;

    await new Promise(r => setTimeout(r, 10));
  }

  if (cancelStream) {
    sendStatus.textContent = 'Cancelled';
    exitPrintScreen(0);
  } else {
    sendStatus.textContent = 'Done';
    exitPrintScreen(0);
  }
  cancelSend.disabled = true;

  // ⬇️ Post-print auto-close timer (safe inside this function)
  if (postPrintTimer) { clearTimeout(postPrintTimer); postPrintTimer = null; }
  if (!cancelStream) {
    postPrintTimer = setTimeout(() => {
      if (port && writer) {
        logMsg('⌛ Auto-closing print screen in firmware…');
        sendCmd('//action:cancel', true); // quiet; no ok expected
      }
      postPrintTimer = null;
    }, 60_000);
  }
}

/* =============================
   Export helpers
============================= */
function exportMeshAsFile(mesh, label) {
  const blob = new Blob([JSON.stringify(mesh, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `cr6se-mesh-${label}-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

/* =============================
   Event listeners
============================= */
// Connection
connectBtn.addEventListener('click', connectPrinter);
disconnectBtn.addEventListener('click', disconnectPrinter);

// Leveling
readMeshBtn.addEventListener('click', readMesh);
reprobeBtn.addEventListener('click', reprobe);

// Manual command & log
sendCmdBtn.addEventListener('click', sendManual);
manualCmd.addEventListener('input', () => { captureMode = null; });
clearLogBtn.addEventListener('click', () => { printerLog.textContent = ''; });

// Level form & export
document.getElementById('levelForm').addEventListener('submit', (e) => {
  e.preventDefault();
  const mesh = [];
  for (let y=0; y<4; y++) {
    const row = [];
    for (let x=0; x<4; x++) {
      const v = parseFloat(document.getElementById(`cell-${y}-${x}`).value);
      row.push(isNaN(v) ? 0 : v);
    }
    mesh.push(row);
  }
  saveMeshLS(mesh);
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  alert('✅ Round submitted!');
});
document.getElementById('exportManualBtn').addEventListener('click', () => {
  const mesh = [];
  for (let y = 0; y < 4; y++) {
    const row = [];
    for (let x = 0; x < 4; x++) {
      const v = parseFloat(document.getElementById(`cell-${y}-${x}`).value);
      row.push(isNaN(v) ? 0 : v);
    }
    mesh.push(row);
  }
  exportMeshAsFile(mesh, 'manual');
});
document.getElementById('exportPrinterBtn').addEventListener('click', () => {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  const latest = hist.at(-1);
  if (latest && Array.isArray(latest) && latest.length === 4) {
    exportMeshAsFile(latest, 'printer');
  } else {
    alert('⚠️ No valid printer mesh to export.');
  }
});
resetBtn.addEventListener('click', () => { if (confirm('Reset all saved data?')) { localStorage.clear(); location.reload(); } });

// Temperature & Fan
hotendApply.addEventListener('click', () => sendCmd(`M104 S${Math.max(0, Math.min(300, parseInt(hotendSet.value)||0))}`));
hotendOff.addEventListener('click',   () => sendCmd('M104 S0'));
bedApply.addEventListener('click',    () => sendCmd(`M140 S${Math.max(0, Math.min(130, parseInt(bedSet.value)||0))}`));
bedOff.addEventListener('click',      () => sendCmd('M140 S0'));
fanSlider.addEventListener('input',   () => { fanVal.textContent = fanSlider.value; });
fanApply.addEventListener('click',    () => sendCmd(`M106 S${Math.max(0, Math.min(255, parseInt(fanSlider.value)||0))}`));
fanOff.addEventListener('click',      () => sendCmd('M107'));

// Movement
homeAll.addEventListener('click', async () => {
  try {
    setActivity('Homing…', 'warn');
    await sendCmd('G28');
    await waitForOk().catch(()=>{});      // no-timeout wait

    // Per request: cool down right after homing
    await sendCmd('M104 S0'); await waitForOk().catch(()=>{});
    await sendCmd('M140 S0'); await waitForOk().catch(()=>{});

    setActivity('Homed & cooled', 'ok');
    updateLastUpdated();
  } catch (e) {
    setActivity('Home failed', 'bad');
    logMsg('⚠️ Home error: ' + (e?.message || e));
  }
});
disableMotors.addEventListener('click', () => sendCmd('M84'));
xMinus.addEventListener('click', () => jog('X', -1));
xPlus .addEventListener('click', () => jog('X', +1));
yMinus.addEventListener('click', () => jog('Y', -1));
yPlus .addEventListener('click', () => jog('Y', +1));
zMinus.addEventListener('click', () => jog('Z', -1));
zPlus .addEventListener('click', () => jog('Z', +1));
parkHead.addEventListener('click', () => sendCmd('G90\nG1 X0 Y0 Z10 F3000'));

// EEPROM / Config
readCfg.addEventListener('click', async () => {
  configBox.value = '';
  captureMode = 'config';
  stopTempPolling();
  await sendCmd('M503');
});
saveCfg.addEventListener('click', async () => { await sendCmd('M500'); });
// resetCfg.addEventListener('click', async () => {
//   if (confirm('Reset EEPROM to factory defaults (M502)?')) await sendCmd('M502');
// });

// Maintenance
preheatPLA.addEventListener('click',  () => sendCmd('M104 S200\nM140 S60'));
preheatPETG.addEventListener('click', () => sendCmd('M104 S240\nM140 S80'));
preheatABS.addEventListener('click',  () => sendCmd('M104 S250\nM140 S100'));
cooldown.addEventListener('click',    () => sendCmd('M104 S0\nM140 S0'));
loadFil.addEventListener('click', async () => {
  const mm = parseFloat(prompt('How many mm to LOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(prompt('Hotend temp for load (°C)?', '200'));
  if (!Number.isFinite(temp) || temp <= 0) return;

  try {

    // 🔹 Home all axes first
    await sendCmd('G28');                    await waitForOk().catch(()=>{});

    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});

    // heat without triggering Printing screen
    await waitForHotend(temp, 1.0).catch(()=>{}); // waits until within 1°C

    // relative extrusion only, then flush
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{}); // ensure done
    await sendCmd('M82');                    await waitForOk().catch(()=>{});

    // cool down, do not move/park
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});

    sendStatus.textContent = 'Filament load complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Load failed';
    console.error(e);
  }
});
unloadFil.addEventListener('click', async () => {
  const mm = parseFloat(prompt('How many mm to UNLOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(prompt('Hotend temp for unload (°C)?', '200'));
  if (!Number.isFinite(temp) || temp <= 0) return;

  try {

    // 🔹 Home all axes first
    await sendCmd('G28');                    await waitForOk().catch(()=>{});

    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});

    await waitForHotend(temp, 1.0).catch(()=>{});

    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E-${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{}); // ensure done
    await sendCmd('M82');                    await waitForOk().catch(()=>{});

    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});

    sendStatus.textContent = 'Filament unload complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Unload failed';
    console.error(e);
  }
});

// Diagnostics
fwInfo.addEventListener('click', () => {
  diagBox.value = '';
  captureMode = 'diag';
  stopTempPolling();
  sendCmd('M115');
});
tmcDiag.addEventListener('click', () => {
  diagBox.value = '';
  captureMode = 'diag';
  stopTempPolling();
  sendCmd('M122');
});

// G-code Sender
gcodeFile.addEventListener('change', () => {
  sendGcode.disabled = !gcodeFile.files.length || !writer;
});
sendGcode.addEventListener('click',  () => { if (gcodeFile.files[0]) streamGcode(gcodeFile.files[0]); });
cancelSend.addEventListener('click', async () => {
  cancelStream = true;
  _rejectAllOk(new Error('Cancelled')); // abort any waits right now

  // Stop heaters & park head
  await sendCmd('M104 S0');
  await waitForOk().catch(()=>{});
  await sendCmd('M140 S0');
  await waitForOk().catch(()=>{});
  await sendCmd('G90');
  await waitForOk().catch(()=>{});
  await sendCmd('G1 X0 Y0 Z10 F3000');
  await waitForOk().catch(()=>{});
  exitPrintScreen(0);
});

/* =============================
   Init
============================= */
(function init() {
  const mesh = loadMeshLS();
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  setConnected(false);
  setOfflinePills(); 
})();

</script>
</body>
</html>
