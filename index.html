<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Printer Utils</title>
<meta name="author" content="issypup">
<meta name="date" content="2025-08-10">
<style>
/* === G-code Preview === */
.gp-wrap {
  display: grid; gap: 8px;
  background: var(--panel); border: 1px solid var(--border);
  border-radius: 12px; padding: 10px; box-shadow: var(--shadow);
}
.gp-bar { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
.gp-bar label { display:flex; align-items:center; gap:6px; font-size: 14px; color: var(--text); }
.gp-bar input[type="range"] { width: 280px; }
.gp-canvas {
  position: relative; height: 360px; border: 1px dashed var(--border);
  border-radius: 8px; background: color-mix(in oklab, var(--panel) 90%, var(--text) 10%);
  overflow: hidden;
}
#gcodeCanvas { width: 100%; height: 100%; display: block; }
.gp-legend { font-size:12px; color: var(--muted); display:flex; gap:12px; }
.gp-chip { display:inline-flex; align-items:center; gap:6px; }
.gp-dot { width:10px; height:10px; border-radius:999px; display:inline-block; }
.gp-dot.prev { background: color-mix(in oklab, var(--text) 20%, transparent); }
.gp-dot.curr { background: var(--accent); }
.gp-dot.travel { background: color-mix(in oklab, var(--text) 35%, transparent); }

  :root { --bar-h: 42px; }
  body {
    font-family: sans-serif;
    padding: calc(var(--bar-h) + 12px) 12px 56px;
    background: #f4f4f4;
  }
  h1, h2 { margin-top: 1rem; }
  table { border-collapse: collapse; margin-top: 0.5rem; }
  td, th { border: 1px solid #ccc; padding: 0.4rem; text-align: center; }
  input[type="number"], input[type="text"] { width: 100px; }
  button { padding: 0.45rem 0.9rem; margin: 0.25rem 0.25rem 0.25rem 0; cursor: pointer; }
  .tighten { background: #ffe0e0; }
  .loosen  { background: #e0f0ff; }
  .na      { background: #eaeaea; }
  .gap { border: none; background: transparent; color: #888; font-weight: bold; }
  #screwMap td { width: 110px; height: 60px; vertical-align: top; font-size: 0.85em; }

  /* Status bar (always visible) */
  #statusBar {
    position: fixed; top: 0; left: 0; right: 0; height: var(--bar-h);
    background: #222; color: #fff; display: flex; align-items: center;
    gap: 12px; padding: 0 12px; z-index: 9999; font-weight: 600;
  }
#statusBar .pill { 
  /* background:#444; */  /* remove this line if needed */
  transition: background-color 200ms ease, filter 200ms ease, transform 200ms ease;
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 10px; border-radius:999px; font-weight:600;
}

/* state colors – more specific than #statusBar .pill */
#statusBar .pill.idle    { background:#555; }     /* no target / idle */
#statusBar .pill.ready   { background:#2ecc71; }  /* green, stable */
#statusBar .pill.heating { background:#e74c3c; }  /* red, heating */
#statusBar .pill.cooling { background:#3498db; }  /* blue, cooling */
#statusBar .pill.offline { background:#444; color:#fff; }
#statusBar .pill.pid { background:#f39c12; } /* orange */

/* pulse effect (used for heating/cooling) */
.pulse { animation: pillPulse 1.0s ease-in-out infinite; }
@keyframes pillPulse {
  0%   { transform:none; filter:brightness(100%); }
  50%  { transform:scale(1.05); filter:brightness(115%); }
  100% { transform:none; filter:brightness(100%); }
}

/* keep hotend/bed pills nicely spaced */
#temps { display: inline-flex; gap: 24px; }

  #statusBar .ok    { background: #2a7; }
  #statusBar .warn  { background: #f39c12; }
  #statusBar .bad   { background: #c0392b; }

  /* Tabs */
  #tabButtons { display:flex; flex-wrap: wrap; gap:6px; margin: 8px 0 4px; }
  #tabButtons button {
    padding: 0.45rem 1rem; cursor: pointer; background: #eee; border: 1px solid #ccc;
  }
  #tabButtons button.active { background: #ddd; font-weight: bold; }
  .tabContent { display: none; }
  .tabContent.active { display: block; }

  /* Controls rows inside tabs */
  .tabControls { display:flex; flex-wrap:wrap; gap:8px; margin: 8px 0 8px; align-items: center; }

  /* Printer log */
  #printerLog {
    background:#111; color:#ddd; border:1px solid #333;
    height: 220px; overflow:auto; padding:8px; white-space:pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    border-radius: 6px;
  }

#printerName.editable {
  cursor: pointer;
}
#printerName.editable:hover {
  text-decoration: underline;
}

  /* Footer status */
  #footerStatus {
    position: fixed; bottom: 0; left: 0; right: 0;
    background: #222; color: #fff; padding: 6px 10px;
    display:flex; justify-content: space-between; font-size: 0.9em;
  }

#aboutTab .aboutCard {
  background: #fff;
  border: 1px solid #ddd;
  padding: 16px 18px;
  border-radius: 8px;
  max-width: 560px;
  margin: 20px auto;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

#aboutTab .aboutCard h2 {
  margin: 0 0 10px;
  font-size: 1.3em;
  color: #333;
  border-bottom: 2px solid #eee;
  padding-bottom: 6px;
}

#aboutTab .aboutCard p { margin: 10px 0 0; color: #555; }

#aboutTab .kv {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  margin-top: 8px;
  font-size: 0.95em;
}
#aboutTab .kv span:first-child { color: #666; }
#aboutTab .kv span:last-child  { font-weight: 600; color: #111; }

  /* Small UI helpers */
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .col { display:flex; flex-direction:column; gap:6px; }
  .box { background:#fff; border:1px solid #ddd; padding:8px; border-radius:6px; }
  .label { font-weight:600; }
  .muted { color:#666; font-size:0.9em; }
  .widen { width: 220px; }
  .progress { height: 10px; background:#ddd; border-radius:999px; overflow:hidden; width:280px; }
  .progress > div { height:100%; background:#2a7; width:0%; }

#preOverlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000;
}
#preModal   {
  position: fixed; inset: 0; display: none; place-items: center; z-index: 10001;
}
#preCard    {
  width: min(720px, 92vw); max-height: 80vh; background:#fff; border:1px solid #ddd;
  border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.25);
  display:grid; grid-template-rows:auto 1fr;
}
#preHeader  { display:flex; align-items:center; justify-content:space-between; gap:12px;
  padding:12px 14px; border-bottom:1px solid #eee; }
#preBody    { padding:14px 16px; overflow:auto; line-height:1.35; }
#preClose   { background:#eee; border:1px solid #ccc; padding:6px 10px; border-radius:8px; cursor:pointer; }
#preClose:hover { background:#e5e5e5; }


  /* EE Modal */
#eeOverlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 10000;
}

#eeModal {
  position: fixed; inset: 0;
  display: none;           /* toggled by JS */
  place-items: center;     /* grid centering */
  z-index: 10001;
}

#eeCard {
  width: min(720px, 92vw);
  max-height: 80vh;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.25);
  display: grid;
  grid-template-rows: auto 1fr;
}

#eeHeader {
  display: flex; align-items: center; justify-content: space-between;
  gap: 12px;
  padding: 12px 14px;
  border-bottom: 1px solid #eee;
}

#eeBody {
  padding: 14px 16px;
  white-space: pre-wrap;   /* preserve line breaks */
  overflow: auto;
  line-height: 1.35;
}

#eeClose {
  background: #eee; border: 1px solid #ccc;
  padding: 6px 10px; border-radius: 8px; cursor: pointer;
}
#eeClose:hover { background:#e5e5e5; }

#liveChart { width: 100%; height: 260px; display: block; }


/* ===== HELP DRAWER ===== */
.help-drawer {
  position: fixed; right: 0; top: var(--bar-h, 42px);
  width: min(420px, 88vw); height: calc(100vh - var(--bar-h, 42px));
  background: var(--panel); color: var(--text);
  border-left: 1px solid var(--border);
  box-shadow: var(--shadow);
  display: none; flex-direction: column; z-index: 9998;
}
.help-drawer.open { display: flex; }

.help-head {
  display:flex; align-items:center; gap:8px; padding:10px 12px;
  border-bottom:1px solid var(--border);
}
.help-head h3 { margin:0; font-size:16px; flex:1; }
.help-actions { display:flex; gap:8px; }
.help-actions input[type="search"] { width: 180px; }

.help-body {
  overflow: auto; padding: 12px 14px; line-height: 1.45;
}
.help-body h4 { margin: 1em 0 .4em; }
.help-body p { margin: .5em 0; }
.help-body code, .help-body kbd {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border); padding: .1em .35em; border-radius: 6px;
}
.help-body pre {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border); padding: 8px; border-radius: 8px;
  overflow: auto;
}
.help-resize {
  position: absolute; left: -6px; top: 0; bottom: 0; width: 8px; cursor: ew-resize;
}
.help-toggle-btn {
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; border:1px solid var(--border);
  background: var(--panel); border-radius: 8px; cursor: pointer;
}
/* ============ Docked Help layout ============ */

/* Two-column grid that holds the whole app area (tabs + tabContent) and the Help aside */
.app-layout {
  display: grid;
  grid-template-columns: 1fr minmax(300px, 420px);
  gap: 12px;
  align-items: start;
  margin-top: 8px; /* tiny breathing room under the tab bar */
}

/* Make the drawer live "in flow" when docked */
.app-layout .help-drawer {
  position: sticky;      /* stays visible while you scroll */
  top: calc(var(--bar-h, 42px) + 8px);
  height: calc(100vh - var(--bar-h, 42px) - 24px);
  border-left: 1px solid var(--border);
  box-shadow: var(--shadow);
  display: none;         /* hidden until Help is toggled */
}

/* Visible when toggled */
.app-layout .help-drawer.open { display: flex; }

/* The main content column */
#appMain { min-width: 0; } /* allow content to shrink and not overflow */

/* Responsiveness: on small screens, fall back to the original overlay behavior */
@media (max-width: 1000px) {
  .app-layout {
    grid-template-columns: 1fr; /* single column */
  }
  .app-layout .help-drawer {
    position: fixed;
    right: 0; top: var(--bar-h, 42px);
    width: min(420px, 88vw);
    height: calc(100vh - var(--bar-h, 42px));
    display: none; /* still controlled by .open */
  }
  .app-layout .help-drawer.open { display: flex; }
}

/* Position vars the JS will update */
:root {
  --help-top: calc(var(--bar-h, 42px) + 8px);
}
.help-drawer {
  position: fixed;
  right: 0;
  top: var(--help-top);
  height: calc(100vh - var(--help-top) - 16px);
  width: min(420px, 88vw);
}

#helpCard {
  width: min(760px, 92vw); max-height: 82vh;
  background: var(--panel); color: var(--text);
  border: 1px solid var(--border); border-radius: 12px; box-shadow: var(--shadow);
  display: grid; grid-template-rows: auto 1fr;
}
#helpHead {
  display:flex; align-items:center; gap:8px;
  padding:12px 14px; border-bottom:1px solid var(--border); cursor: move; /* draggable handle */
}
#helpHead h3 { margin:0; font-size:16px; flex:1; }
#helpActions { display:flex; gap:8px; align-items:center; }
#helpBodyWrap { overflow:auto; padding: 12px 14px; }

/* Reuse existing help content styles */
#helpBodyWrap .help-body h4 { margin: 1em 0 .4em; }
#helpBodyWrap .help-body p  { margin: .5em 0; }
#helpBodyWrap .help-body code, 
#helpBodyWrap .help-body kbd {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border); padding: .1em .35em; border-radius: 6px;
}
#helpBodyWrap .help-body pre {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border); padding: 8px; border-radius: 8px; overflow:auto;
}

/* ==== HELP MODAL (fixed) ==== */
#helpOverlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.45);
  display: none; z-index: 10000;
}
#helpModal {
  position: fixed; inset: 0; display: none; place-items: center; z-index: 10001;
}

/* show */
#helpOverlay.open, #helpModal.open { display: grid; }

/* Force a clean, white Help modal regardless of theme */
#helpCard {
  background: #fff !important;
  color: #111 !important;
  border: 1px solid #e5e7eb !important;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.25);
}
#helpHead { background: transparent; }
#helpBodyWrap { background: transparent; }

#helpActions input[type="search"] { width: 220px; }

/* Reuse your help body typography */
#helpBodyWrap .help-body h4 { margin: 1em 0 .4em; }
#helpBodyWrap .help-body p  { margin: .5em 0; }
#helpBodyWrap .help-body code, 
#helpBodyWrap .help-body kbd {
  background: #f4f6f8;
  border: 1px solid #e5e7eb; padding: .1em .35em; border-radius: 6px;
}
#helpBodyWrap .help-body pre {
  background: #f4f6f8;
  border: 1px solid #e5e7eb; padding: 8px; border-radius: 8px; overflow:auto;
}

/* Doc typography */
#helpBody code,#helpBody kbd{background:#f4f6f8;border:1px solid #e5e7eb;padding:.1em .35em;border-radius:6px;}
#helpBody pre{background:#f4f6f8;border:1px solid #e5e7eb;padding:8px;border-radius:8px;overflow:auto;}

</style>
</head>
<body>

<!-- Global Status Bar -->
<div id="statusBar">
  <span id="printerName" class="editable">PRINTER</span>
  <span id="connBadge" class="pill bad">Disconnected</span>
  <span id="activityBadge" class="pill">Idle</span>
  <span id="lastUpdated" class="pill">Last updated: —</span>
<span id="temps">
  <span class="pill idle" id="topHotendPill">Hotend: <span id="topHotend">--°C</span></span>
  <span class="pill idle" id="topBedPill">Bed: <span id="topBed">--°C</span></span>
</span>
<span id="etaPill" class="pill" style="display:none;">ETA: —</span>
<span id="netPill" class="pill" title="Live serial throughput and OK latency">
  TX — · RX — · Lat —
</span>
</div>

<h1>3D Printer Utils</h1>

<!-- Tabs -->
<div id="tabButtons">
  <button data-tab="connectTab" class="active">Connection & Log</button>
  <button data-tab="levelTab">Leveling</button>
  <button data-tab="pidTab">PID Tuning</button>
  <button data-tab="tempTab">Temperature & Fan</button>
  <button data-tab="moveTab">Movement & Axes</button>
  <button data-tab="eepromTab">EEPROM / Config</button>
  <button data-tab="maintTab">Maintenance</button>
  <button data-tab="filamentTab">Filament</button>
  <button data-tab="diagTab">Diagnostics</button>
  <button data-tab="senderTab">G-code Sender</button>
  <button data-tab="aboutTab">About</button>
</div>

<!-- TAB 1: Connection & Log -->
<div id="connectTab" class="tabContent active">
  <div class="tabControls" id="printerNavConnect">
    <label style="margin-left:8px;">
  <input type="checkbox" id="debugToggle">
  Debug
</label>
<label style="margin-left:8px;">
  <input type="checkbox" id="virtualToggle">
  Virtual printer
</label>
<label style="margin-left:8px;">
  Baud:
  <select id="baudSelect">
    <option value="auto" selected>Auto-detect</option>
    <option value="250000">250000</option>
    <option value="115200">115200</option>
    <option value="230400">230400</option>
    <option value="500000">500000</option>
    <option value="1000000">1000000</option>
    <option value="57600">57600</option>
  </select>
</label>
    <button id="connectBtn">Connect</button>
    <button id="disconnectBtn" disabled>Disconnect</button>
    <input id="manualCmd" placeholder="Manual G-code (e.g., M503)" />
    <button id="sendCmdBtn" disabled>Send</button>
    <button id="clearLogBtn" disabled>Clear Log</button>
  </div>

  <h2>Printer Log</h2>
  <div id="printerLog" aria-live="polite"></div>
</div>

<!-- TAB 2: Leveling -->
<div id="levelTab" class="tabContent">
<div class="tabControls" id="printerNavLevel">
  <button id="readMeshBtn" disabled>Home &amp; Probe (G28 → G29 T)</button>
  <button type="button" id="exportMeshBtn">Export Mesh</button>

  <label style="margin-left:auto">
    Printer:
    <select id="levelPrinterSelect">
      <option value="cr6se" selected>CR-6 SE</option>
      <option value="unsupported">Unsupported</option>
    </select>
  </label>
</div>

  <!-- NEW: message for unsupported printers -->
  <div id="unsupportedMsg" class="box" style="display:none; max-width:560px">
    <strong>Printer unsupported.</strong>
    <div class="muted">Leveling helpers are currently only available for the CR-6 SE.</div>
  </div>

  <!-- Wrap all CR-6 SE specific UI so we can show/hide it easily -->
  <div id="cr6seLevelWrap">
    <!-- Mesh Form (manual + populated from printer) -->
    <form id="levelForm">
      <h2>Enter / View Mesh Readings</h2>
      <table><tbody id="meshInput"></tbody></table>
      <button type="submit">Submit Round</button>
      <button type="button" id="resetBtn">Reset Data</button>
    </form>

    <h2>Screw Suggestions</h2>
    <table>
      <thead>
        <tr><th>Screw</th><th>Avg (mm)</th><th>Action</th><th>Turn Strength</th></tr>
      </thead>
      <tbody id="screwTable"></tbody>
    </table>

    <h2>Screw Layout Map</h2>
    <table id="screwMap">
      <tr>
        <td id="A1"></td>
        <td class="gap">GAP</td>
        <td id="A2"></td>
        <td id="A3"></td>
      </tr>
      <tr>
        <td id="B1"></td>
        <td id="B2"></td>
        <td id="B3"></td>
        <td id="B4"></td>
      </tr>
      <tr>
        <td id="C1"></td>
        <td id="C2"></td>
        <td id="C3"></td>
        <td id="C4"></td>
      </tr>
    </table>
  </div>
</div>

<!-- TAB 3: PID Tuning -->
<div id="pidTab" class="tabContent">
  <div class="tabControls" id="printerNavPID">
    <button id="bedPidBtn"    disabled>PID Bed (M303 E-1)</button>
    <button id="hotendPidBtn" disabled>PID Nozzle (M303 E0)</button>
  </div>
  <p>Runs <code>M303</code> autotune with a temperature you choose. After it completes, send <code>M500</code> if your firmware needs it to save to EEPROM.</p>
</div>

<!-- TAB 4: Temperature & Fan -->
<div id="tempTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Hotend</div>
      <div>
        <input type="number" id="hotendSet" value="200" min="0" max="300" /> °C
        <button id="hotendApply" disabled>Set (M104)</button>
        <button id="hotendOff"   disabled>Off (M104 S0)</button>
      </div>
      <div class="muted" id="hotendNow">Current: —</div>
    </div>
    <div class="col">
      <div class="label">Bed</div>
      <div>
        <input type="number" id="bedSet" value="60" min="0" max="130" /> °C
        <button id="bedApply" disabled>Set (M140)</button>
        <button id="bedOff"   disabled>Off (M140 S0)</button>
      </div>
      <div class="muted" id="bedNow">Current: —</div>
    </div>
    <div class="col">
      <div class="label">Part Cooling Fan</div>
      <div>
        <input type="range" id="fanSlider" min="0" max="255" value="0" />
        <span id="fanVal">0</span>/255
      </div>
      <div>
        <button id="fanApply" disabled>Apply (M106)</button>
        <button id="fanOff"   disabled>Off (M107)</button>
      </div>
    </div>
  </div>
  <div class="box">
  <div class="label">Live Telemetry (last 10 min)</div>
  <canvas id="liveChart" width="900" height="260" aria-label="Live temperatures, fan %, and M73 %"></canvas>
  <div class="muted">Left axis: °C · Right axis: % (Fan, M73)</div>
</div>
  <div class="row box">
<div class="col">
  <div class="label">Safety</div>
  <button id="unlockTempsBtn" type="button">Unlock high hotend temps</button>
  <div class="muted" id="unlockHint">Guardrail ON — max 250°C</div>
</div>
    <div class="muted">Polled via M105 every 3s while connected</div>
  </div>
</div>

<!-- TAB 5: Movement & Axes -->
<div id="moveTab" class="tabContent">
  <div class="row box">
    <div>
      <span class="label">Step</span>
      <select id="jogStep">
        <option value="1">1 mm</option>
        <option value="5" selected>5 mm</option>
        <option value="10">10 mm</option>
      </select>
    </div>
    <div>
      <button id="homeAll" disabled>Home All (G28)</button>
      <button id="disableMotors" disabled>Disable Steppers (M84)</button>
    </div>
  </div>
  <div class="row box">
    <div class="col">
      <div class="label">Move X</div>
      <button id="xMinus" disabled>◀ X-</button>
      <button id="xPlus"  disabled>X+ ▶</button>
    </div>
    <div class="col">
      <div class="label">Move Y</div>
      <button id="yMinus" disabled>▼ Y-</button>
      <button id="yPlus"  disabled>▲ Y+</button>
    </div>
    <div class="col">
      <div class="label">Move Z</div>
      <button id="zMinus" disabled>Z-</button>
      <button id="zPlus"  disabled>Z+</button>
    </div>
    <div id="axisPositions">
  <div>X: <span id="posX">—</span></div>
  <div>Y: <span id="posY">—</span></div>
  <div>Z: <span id="posZ">—</span></div>
</div>
  </div>
  <div class="row box">
    <button id="parkHead" disabled>Park Head (X0 Y0 Z10)</button>
  </div>
</div>

<!-- TAB 6: EEPROM / Config -->
<div id="eepromTab" class="tabContent">
  <div class="row box">
  <button id="parseM503Btn" type="button">Parse M503 → Fields</button>
  <button id="exportCfgBtn" type="button">Export JSON</button>
  <span class="muted">Paste/receive M503 below, then Parse.</span>
    <!-- <button id="resetCfg" disabled>Factory Reset (M502)</button>-->
  </div>
  <table class="box" style="width:100%; max-width:900px; margin-bottom:8px">
  <thead>
    <tr><th style="width:220px">Setting</th><th>Value</th></tr>
  </thead>
<table id="m503Table" style="border-collapse:collapse;width:100%;max-width:900px">
  <thead><tr><th style="text-align:left;width:240px">Field</th><th style="text-align:left">Value</th></tr></thead>
  <tbody></tbody>
</table>
</table>
</div>

<!-- TAB 7: Maintenance -->
<div id="maintTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Preheat</div>
      <button id="preheatPLA"  disabled>PLA (200/60)</button>
      <button id="preheatPETG" disabled>PETG (240/80)</button>
      <button id="preheatABS"  disabled>ABS (250/100)</button>
    </div>
    <div class="col">
      <div class="label">Cool Down</div>
      <button id="cooldown" disabled>Cool Down (M104 S0; M140 S0)</button>
    </div>
    <div class="col">
      <div class="label">Filament</div>
      <button id="loadFil"  disabled>Load (200°C)</button>
      <button id="unloadFil" disabled>Unload (200°C)</button>
    </div>
        <div class="col">
      <div class="label">Nozzle Prep</div>
      <button id="primeLine" disabled>Wipe + Prime Line</button>
    </div>
      <div class="box col" style="margin-top:8px; max-width:840px">
    <div class="label">Maintenance logbook</div>
    <form id="maintForm" class="row" style="align-items:flex-start">
      <input id="maintDate" type="date" />
      <textarea id="maintNote" class="widen" rows="2" placeholder="What did you do? (e.g., Cleaned bed, lubed Z lead screw)"></textarea>
      <button id="maintSave" type="submit">Save</button>
      <button id="maintReset" type="button">Reset</button>
    </form>

    <div class="row" style="justify-content:space-between; margin-top:4px">
      <div class="muted" id="maintSummary">—</div>
      <div class="row">
        <button id="maintExport" type="button">Export JSON</button>
        <button id="maintClearAll" type="button">Clear all</button>
      </div>
    </div>

    <table style="width:100%; margin-top:8px">
      <thead>
        <tr><th style="width:120px">Date</th><th>Note</th><th style="width:160px">Actions</th></tr>
      </thead>
      <tbody id="maintTable"></tbody>
    </table>
  </div>
  </div>
</div>

<!-- TAB 8: Filament -->
<div id="filamentTab" class="tabContent">
  <div class="row" style="gap:12px; align-items:flex-start">
    <!-- Form: Add/Edit spool -->
    <form id="spoolForm" class="box col" style="min-width:300px; max-width:420px">
      <div class="label">Spool details</div>
      <div class="row">
        <input id="spBrand"  class="widen" placeholder="Brand (e.g., eSun)"/>
        <input id="spMaterial" class="widen" list="matList" placeholder="Material (PLA/PETG/ABS/TPU/Nylon/…)" />
        <datalist id="matList">
          <option>PLA</option><option>PETG</option><option>ABS</option>
          <option>TPU</option><option>Nylon</option><option>PC</option><option>PVA</option>
        </datalist>
      </div>

      <div class="row">
        <label>Ø
          <select id="spDiameter">
            <option value="1.75" selected>1.75</option>
            <option value="2.85">2.85</option>
          </select> mm
        </label>
        <label>Density
          <input id="spDensity" type="number" step="0.01" min="0.5" max="3" value="1.24" style="width:110px"/> g/cm³
        </label>
      </div>

      <div class="row">
        <input id="spColorName" class="widen" placeholder="Color name (e.g., Deep Black)"/>
        <label>Hex <input id="spColorHex" type="color" value="#000000" /></label>
        <input id="spFinish" class="widen" placeholder="Finish (matte/silk/carbon/glow)"/>
      </div>

      <div class="row">
        <label>Tare <input id="spTare" type="number" step="1" min="0" value="250" style="width:120px"/> g</label>
        <label>Capacity <input id="spCapacity" type="number" step="1" min="0" value="1000" style="width:120px"/> g</label>
      </div>

      <div class="row">
        <label>Total $ <input id="spCostTotal" type="number" step="0.01" min="0" style="width:110px"/></label>
        <label>$/kg <input id="spCostPerKg" type="number" step="0.01" min="0" style="width:110px"/></label>
      </div>

      <div class="row">
        <input id="spLot" class="widen" placeholder="Lot / batch"/>
        <label>Date <input id="spDate" type="date" style="width:160px"/></label>
      </div>

      <input id="spVendor" class="widen" placeholder="Vendor link (https://…)" />

      <div class="row" style="justify-content:flex-end; gap:8px; margin-top:8px">
        <button id="spReset" type="button">Reset</button>
        <button id="spSave"  type="submit">Save spool</button>
      </div>

      <div class="muted" id="spFormHint">Spool ID: <span id="spIdShow">— (new)</span></div>
    </form>

    <!-- Library / List -->
    <div class="box col" style="flex:1 1 420px">
      <div class="row" style="gap:8px; flex-wrap:wrap">
        <input id="spSearch" class="widen" placeholder="Search brand/color/ID…"/>
        <select id="spMatFilter">
          <option value="">All materials</option>
          <option>PLA</option><option>PETG</option><option>ABS</option>
          <option>TPU</option><option>Nylon</option><option>PC</option><option>PVA</option>
        </select>
        <label><input id="spOnlyRemaining" type="checkbox" checked/> Only with remaining</label>
        <select id="spSort">
          <option value="remainingDesc" selected>Sort: Most remaining</option>
          <option value="brandAsc">Brand A→Z</option>
          <option value="materialAsc">Material A→Z</option>
          <option value="createdDesc">Newest first</option>
        </select>
        <label style="margin-left:auto">Active:
          <select id="spActiveSel" style="min-width:200px"></select>
        </label>
        <button id="spPrintLbl" type="button">Print label</button>
      </div>

      <div class="row" style="gap:8px; margin-top:6px">
        <button id="spWeigh"  type="button">Weigh now</button>
        <button id="spDeduct5" type="button">Deduct…</button>
        <button id="spMarkEmpty" type="button">Mark as empty</button>
      </div>

      <table style="width:100%; margin-top:10px">
        <thead>
          <tr>
            <th>ID</th><th>Brand</th><th>Mat</th><th>Color</th>
            <th>Ø</th><th>Remain (g)</th><th>Cap (g)</th><th>Actions</th>
          </tr>
        </thead>
        <tbody id="spTable"></tbody>
      </table>
      <div class="muted" id="spSummary" style="margin-top:6px">—</div>
    </div>
  </div>
</div>

<!-- TAB 9: Diagnostics -->
<div id="diagTab" class="tabContent">
  <div class="row box">
    <button id="parseM115Btn" type="button">Parse M115 → Fields</button>
    <button id="parseM122Btn" type="button">Parse M122 → Fields</button>
  </div>
<table id="m115Table" style="border-collapse:collapse;width:100%;max-width:900px">
  <thead><tr><th style="text-align:left;width:240px">Field</th><th style="text-align:left">Value</th></tr></thead>
  <tbody></tbody>
</table>
<h3>TMC Diagnostics (M122)</h3>
<table id="tmcTable" style="border-collapse:collapse; width:100%; max-width:900px">
  <thead>
    <tr>
      <th style="width:60px">Axis</th>
      <th>Driver</th>
      <th>RMS (mA)</th>
      <th>Microsteps</th>
      <th>stealthChop</th>
      <th>spreadCycle</th>
      <th>OTPW</th>
      <th>Error</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>X</td><td id="tmc_X_drv">—</td><td id="tmc_X_rms">—</td><td id="tmc_X_ms">—</td><td id="tmc_X_sc">—</td><td id="tmc_X_sp">—</td><td id="tmc_X_ot">—</td><td id="tmc_X_er">—</td></tr>
    <tr><td>Y</td><td id="tmc_Y_drv">—</td><td id="tmc_Y_rms">—</td><td id="tmc_Y_ms">—</td><td id="tmc_Y_sc">—</td><td id="tmc_Y_sp">—</td><td id="tmc_Y_ot">—</td><td id="tmc_Y_er">—</td></tr>
    <tr><td>Z</td><td id="tmc_Z_drv">—</td><td id="tmc_Z_rms">—</td><td id="tmc_Z_ms">—</td><td id="tmc_Z_sc">—</td><td id="tmc_Z_sp">—</td><td id="tmc_Z_ot">—</td><td id="tmc_Z_er">—</td></tr>
    <tr><td>E</td><td id="tmc_E_drv">—</td><td id="tmc_E_rms">—</td><td id="tmc_E_ms">—</td><td id="tmc_E_sc">—</td><td id="tmc_E_sp">—</td><td id="tmc_E_ot">—</td><td id="tmc_E_er">—</td></tr>
  </tbody>
</table>
</div>

<!-- TAB 10: G-code Sender -->
<div id="senderTab" class="tabContent">
  <div class="row box">
    <input type="file" id="gcodeFile" accept=".gcode,.gco,.gc,.txt" />
    <button id="sendGcode" disabled>Send File</button>
    <button id="cancelSend" disabled>Cancel</button>
    <div class="progress"><div id="sendProgress"></div></div>
    <span id="sendStatus" class="muted">Idle</span>
    <span id="etaStatus" class="muted" style="margin-left:10px"></span>
  </div>
  <p class="muted">Sends the file line-by-line over serial. Comments/blank lines are skipped. This is best for short jobs, calibration, or macros.</p>


<div class="gp-wrap" id="gcodePreview">
  <div class="gp-bar">
    <label>File
      <input type="file" id="gcodeFilePreview" accept=".gcode,.gco,.nc,.txt">
    </label>
    <label>Layer
      <input type="range" id="layerScrub" min="0" max="0" value="0" step="1">
      <span id="layerInfo">—</span>
    </label>
    <label>
      <input type="checkbox" id="showTravel" checked>
      Show travel
    </label>
    <button id="zoomFit">Fit</button>
    <button id="zoom1">1:1</button>
    <button id="resetPan">Center</button>
  </div>

  <div class="gp-canvas">
    <canvas id="gcodeCanvas"></canvas>
  </div>

  <div class="gp-legend">
    <span class="gp-chip"><span class="gp-dot prev"></span> Previous layers</span>
    <span class="gp-chip"><span class="gp-dot curr"></span> Current layer</span>
    <span class="gp-chip"><span class="gp-dot travel"></span> Travel moves</span>
  </div>
</div>



  <!-- Preflight Modal -->
<div id="preOverlay" aria-hidden="true" style="display:none"></div>
<div id="preModal" role="dialog" aria-modal="true" aria-labelledby="preTitle" style="display:none">
  <div id="preCard">
    <div id="preHeader">
      <h3 id="preTitle">Pre-flight checks</h3>
      <button id="preClose" type="button" aria-label="Close">Close</button>
    </div>
    <div id="preBody">
      <div class="muted" style="margin-bottom:8px">
        File: <strong id="preFileName">—</strong> ·
        Guardrail: <strong id="preGuardrail">—</strong> ·
        Temps (hot/bed): <strong id="preTemps">—</strong> ·
        Mode: <strong id="preMode">—</strong> ·
        Homed: <strong id="preHomed">—</strong>
      </div>

      <fieldset style="border:none; padding:0; margin:0 0 8px 0;">
        <legend class="label" style="margin-bottom:6px">Confirm all:</legend>
        <label><input type="checkbox" class="preChk" id="chkBedClear"> Bed is clear (no clips, tools, hands, pets 🐱)</label><br>
        <label><input type="checkbox" class="preChk" id="chkObstructions"> Gantry path clear (cables, spool, camera arms)</label><br>
        <label><input type="checkbox" class="preChk" id="chkFilament"> Correct filament loaded & nozzle clean</label><br>
        <label><input type="checkbox" class="preChk" id="chkAdhesion"> Adhesion ready (sheet, glue, texture)</label><br>
        <label><input type="checkbox" class="preChk" id="chkZSafe"> Z head parked safely (≥10 mm)</label>
      </fieldset>

      <div class="row" style="margin:8px 0 12px">
        <button id="preHome" type="button">Home Now (G28)</button>
        <button id="prePark" type="button">Park Head (X0 Y0 Z10)</button>
        <label style="margin-left:auto">
          <input type="checkbox" id="preSkip"> Don’t ask again (this session)
        </label>
      </div>

      <div class="row" style="justify-content:flex-end; gap:8px">
        <button id="preCancel" type="button">Cancel</button>
        <button id="preStart"  type="button" disabled>Start Print</button>
      </div>
    </div>
  </div>
</div>

</div>

<!-- TAB 11: About -->
<div id="aboutTab" class="tabContent">
  <div class="aboutCard">
    <h2>About</h2>
    <div class="kv"><span>Author: issypup</span></div>
    <div class="kv"><span>Date: 10 August 2025</span></div>
    <p>This tool helps manage 3D printer tasks / maintenance from your browser, it needs a web serial capable browser</p>
  </div>
<!-- Easter Egg Modal -->
<div id="eeOverlay" aria-hidden="true" style="display:none"></div>
<div id="eeModal" role="dialog" aria-modal="true" aria-labelledby="eeTitle" style="display:none">
  <div id="eeCard">
    <div id="eeHeader">
      <h3 id="eeTitle">Still Printing — (Still Alive Parody)</h3>
      <button id="eeClose" type="button" aria-label="Close">Close</button>
    </div>
    <div id="eeBody"></div>
  </div>
</div>
</div>

<div id="footerStatus">
  <span id="lastCmd">Last Cmd: —</span>
  <span>GitHub Pages ready · LocalStorage only</span>
</div>

<script>
'use strict';

/* =========================================================
   1) DOM REFERENCES (all const)
========================================================= */

let oneShotCapture = null;

function captureReplyOnce({ doneOnOk = true } = {}) {
  if (oneShotCapture) throw new Error('capture already active');
  return new Promise((resolve, reject) => {
    oneShotCapture = { buf: [], resolve, reject, doneOnOk };
  });
}



let lastHomeHintAt = 0;  // when we last saw a "homing-ish" line

let _audioCtx = null;

let _preflightFile = null;

let net = {
  txBytesTotal: 0,
  rxBytesTotal: 0,
  txSince: 0,
  rxSince: 0,
  lastSample: performance.now(),
  txRate: 0,
  rxRate: 0,
  latencyEMA: null,   // ms
  timer: null
};

let lastSendTs = null; 

let heaterUnlocked = JSON.parse(localStorage.getItem('heaterUnlocked') || 'false');

//Filament
let spools = [];
let activeSpoolId = null;
let editingId = null;
let _pendingFilament = null;

//UI and State flags
let debugMode      = JSON.parse(localStorage.getItem('debugMode') || 'false');
let criticalDepth = 0;
let pidActiveHotend = false;
let pidActiveBed    = false;
let pidTarget = null; // 'hotend', 'bed', or null
let isHomed = false;

// Leveling / Probing flow control
let probeLatch = null; // resolved when G29 T finishes (grid header or DWIN “Settings Stored”)

//Mesh and Temps
let meshScratch    = Array.from({ length: 4 }, () => Array(4).fill(null));
let temps          = { hot: null, hotTarget: null, bed: null, bedTarget: null };

//Connection lifecycle
let connKind = 'none'; // 'none' | 'virtual' | 'real'
let isConnecting = false;
let isDisconnecting = false;

//Serial — device handles
let port           = null;
let reader         = null;
let writer         = null;
let textDecoder    = null;

//Comms - I/O state, buffers, timers
let reading        = false;
let rxBuffer       = '';
let cancelStream   = false;
let captureMode    = null; // null | 'config' | 'diag'
let tempTimer      = null;
let postPrintTimer = null;

//Read and Telemetry
let waitingResolvers = []; // (kept for compatibility)
let isBusyProcessing  = false;
let lastOkAt          = 0;
let pendingOk      = []; // queue for waitForOk()

//Virtual printer
let virtualMode = false;
let vSimTimer = null;

//Easter Egg
let streak = 0;

const BEEP_BROWSER_ON = true;   // browser chime via Web Audio
const BEEP_PRINTER_ON = false;  // send M300 to the printer (off by default)
const primeLine = document.getElementById('primeLine');

// =============== FILAMENT: DOM refs ===============
const spoolForm = document.getElementById('spoolForm');
const spIdShow = document.getElementById('spIdShow');
const spBrand = document.getElementById('spBrand');
const spMaterial = document.getElementById('spMaterial');
const spDiameter = document.getElementById('spDiameter');
const spDensity = document.getElementById('spDensity');
const spColorName = document.getElementById('spColorName');
const spColorHex = document.getElementById('spColorHex');
const spFinish = document.getElementById('spFinish');
const spTare = document.getElementById('spTare');
const spCapacity = document.getElementById('spCapacity');
const spCostTotal = document.getElementById('spCostTotal');
const spCostPerKg = document.getElementById('spCostPerKg');
const spLot = document.getElementById('spLot');
const spDate = document.getElementById('spDate');
const spVendor = document.getElementById('spVendor');
const spReset = document.getElementById('spReset');
const spSave = document.getElementById('spSave');

const spSearch = document.getElementById('spSearch');
const spMatFilter = document.getElementById('spMatFilter');
const spOnlyRemaining = document.getElementById('spOnlyRemaining');
const spSort = document.getElementById('spSort');
const spActiveSel = document.getElementById('spActiveSel');
const spPrintLbl = document.getElementById('spPrintLbl');

const spWeigh = document.getElementById('spWeigh');
const spDeduct5 = document.getElementById('spDeduct5');
const spMarkEmpty = document.getElementById('spMarkEmpty');

const spTable = document.getElementById('spTable');
const spSummary = document.getElementById('spSummary');

//Toggles and core controls
const debugToggle     = document.getElementById('debugToggle');
const virtualToggle = document.getElementById('virtualToggle');
const connectBtn      = document.getElementById('connectBtn');
const disconnectBtn   = document.getElementById('disconnectBtn');
const sendCmdBtn      = document.getElementById('sendCmdBtn');
const clearLogBtn     = document.getElementById('clearLogBtn');

//Log/UI text
const printerLog      = document.getElementById('printerLog');
window.logBox = printerLog;
const lastUpdated     = document.getElementById('lastUpdated');
const lastCmd         = document.getElementById('lastCmd');
const activityBadge   = document.getElementById('activityBadge');
const connBadge       = document.getElementById('connBadge');
const printerNameEl = document.getElementById('printerName');

//Top status pills
const topHotendPill   = document.getElementById('topHotendPill');
const topBedPill      = document.getElementById('topBedPill');
const topHotendText   = document.getElementById('topHotend');
const topBedText      = document.getElementById('topBed');
const etaPill = document.getElementById('etaPill');

//Manual G-code
const manualCmd       = document.getElementById('manualCmd');

//Leveling UI
const readMeshBtn     = document.getElementById('readMeshBtn');
const exportMeshBtn   = document.getElementById('exportMeshBtn');
const meshInput       = document.getElementById('meshInput');
const screwTable      = document.getElementById('screwTable');
const levelPrinterSelect = document.getElementById('levelPrinterSelect');
const unsupportedMsg     = document.getElementById('unsupportedMsg');
const cr6seLevelWrap     = document.getElementById('cr6seLevelWrap');
const resetBtn        = document.getElementById('resetBtn');

//PID UI
const bedPidBtn       = document.getElementById('bedPidBtn');
const hotendPidBtn    = document.getElementById('hotendPidBtn');

//Temps and fan
const hotendSet       = document.getElementById('hotendSet');
const bedSet          = document.getElementById('bedSet');
const hotendApply     = document.getElementById('hotendApply');
const hotendOff       = document.getElementById('hotendOff');
const bedApply        = document.getElementById('bedApply');
const bedOff          = document.getElementById('bedOff');
const hotendNow       = document.getElementById('hotendNow');
const bedNow          = document.getElementById('bedNow');
const fanSlider       = document.getElementById('fanSlider');
const fanVal          = document.getElementById('fanVal');
const fanApply        = document.getElementById('fanApply');
const fanOff          = document.getElementById('fanOff');
const unlockTempsBtn = document.getElementById('unlockTempsBtn');
const unlockHint     = document.getElementById('unlockHint');
const MAX_HOTEND = 250;
const MAX_BED    = 110;

//Movement UI
const jogStep         = document.getElementById('jogStep');
const homeAll         = document.getElementById('homeAll');
const disableMotors   = document.getElementById('disableMotors');
const xMinus          = document.getElementById('xMinus');
const xPlus           = document.getElementById('xPlus');
const yMinus          = document.getElementById('yMinus');
const yPlus           = document.getElementById('yPlus');
const zMinus          = document.getElementById('zMinus');
const zPlus           = document.getElementById('zPlus');
const parkHead        = document.getElementById('parkHead');
const posXEl          = document.getElementById('posX');
const posYEl          = document.getElementById('posY');
const posZEl          = document.getElementById('posZ');

//eeprom and Config
const configBox       = document.getElementById('configBox');

//Diagnostics
const fwInfo          = document.getElementById('fwInfo');
const diagBox         = document.getElementById('diagBox');

//Sender
const gcodeFile       = document.getElementById('gcodeFile');
const sendGcode       = document.getElementById('sendGcode');
const cancelSend      = document.getElementById('cancelSend');
const sendProgress    = document.getElementById('sendProgress');
const sendStatus      = document.getElementById('sendStatus');

//Maintenance controls
const preheatPLA      = document.getElementById('preheatPLA');
const preheatPETG     = document.getElementById('preheatPETG');
const preheatABS      = document.getElementById('preheatABS');
const cooldown        = document.getElementById('cooldown');
const loadFil         = document.getElementById('loadFil');
const unloadFil       = document.getElementById('unloadFil');

//Easter egg
  const eeOverlay = document.getElementById('eeOverlay');
  const eeModal   = document.getElementById('eeModal');
  const eeClose   = document.getElementById('eeClose');
  const eeBody    = document.getElementById('eeBody');

/* =========================================================
   2) CONSTANTS (maps, regex, fixed values)
========================================================= */

const HOME_SIG_DEFAULT = { x: 117, y: 117, z: 10.0, tolX: 2.0, tolY: 2.0, tolZ: 4.0 };

connectBtn?.addEventListener('click', () => connectPrinter());

//Mesh and screws map
const screwAffects = {
  A1: [[0,0],[0,1],[1,0],[1,1]],
  A2: [[0,1],[0,2],[1,1],[1,2]],
  A3: [[0,2],[0,3],[1,2],[1,3]],
  B1: [[1,0],[1,1],[2,0],[2,1]],
  B2: [[1,1],[1,2],[2,1],[2,2]],
  B3: [[1,2],[1,3],[2,2],[2,3]],
  B4: [[2,3],[1,3],[3,3]],
  C1: [[2,0],[2,1],[3,0],[3,1]],
  C2: [[2,1],[2,2],[3,1],[3,2]],
  C3: [[2,2],[2,3],[3,2],[3,3]],
  C4: [[3,3]]
};

document.getElementById('parseM503Btn')?.addEventListener('click', async () => {
  try {
    const raw = await readFullBlock('M503');
    if (!raw.trim()) throw new Error('empty');
    const cfg = parseM503Response(raw);
    renderM503Table('#m503Table', cfg);
    window._lastParsedCfg = cfg;
  } catch (err) {
    console.error('Failed to read M503:', err);
    const fallback = prompt('No M503 received.\nPaste M503 output to parse:') || '';
    const cfg = parseM503Response(fallback);
    renderM503Table('#m503Table', cfg);
    window._lastParsedCfg = cfg;
  }
});

document.getElementById('parseM115Btn')?.addEventListener('click', async () => {
  try {
    stopTempPolling?.(); // optional, avoids temperature spam while capturing
    const raw = await readFullBlock('M115'); // waits until full banner and 'ok' received

    if (!raw || !raw.trim()) {
      // If no reply, ask the user
      const fallback = prompt('No M115 received.\nPaste firmware banner to parse:');
      if (!fallback) return; // user cancelled
      renderM115Table('#m115Table', parseM115Response(fallback));
      return;
    }

    renderM115Table('#m115Table', parseM115Response(raw));
  } catch (err) {
    console.error('Failed to read M115:', err);
    const fallback = prompt('No M115 received.\nPaste firmware banner to parse:');
    if (!fallback) return;
    renderM115Table('#m115Table', parseM115Response(fallback));
  }
});
function renderM122Fields(ax) {
  const put = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = (v ?? '—'); };
  for (const a of ['X','Y','Z','E']) {
    const d = ax[a] || {};
    put(`tmc_${a}_drv`, d.driver ?? '—');
    put(`tmc_${a}_rms`, d.rms ?? '—');
    put(`tmc_${a}_ms`,  d.msteps ?? '—');
    put(`tmc_${a}_sc`,  d.stealth ?? '—');
    put(`tmc_${a}_sp`,  d.spread ?? '—');
    put(`tmc_${a}_ot`,  d.otpw ?? '—');
    put(`tmc_${a}_er`,  d.error ?? '—');
  }
}

document.getElementById('parseM122Btn')?.addEventListener('click', async () => {
  try {
    stopTempPolling?.();
    const raw = await sendCmd('M122');   // real or virtual returns the full block
    const tmc = parseM122(raw || '');
    renderM122Fields(tmc);
  } catch (err) {
    // Optional offline fallback (remove if you truly never want prompts):
    // const raw = prompt('No M122 received.\nPaste M122 output to parse:') || '';
    // const tmc = parseM122(raw);
    // renderM122Fields(tmc);
  }
});

// Robust block reader: works in virtual or real serial, with diagnostics.
// Drop-in replacement: do NOT start capture here; rely on sendCmd's own capture
async function readFullBlock(cmd, timeoutMs = 7000) {
  try { stopTempPolling?.(); } catch {}
  // clean up any stale capture, just in case
  if (typeof oneShotCapture !== 'undefined' && oneShotCapture) {
    try { oneShotCapture.resolve(oneShotCapture.buf?.join('\n') || ''); } catch {}
    oneShotCapture = null;
  }
  let result;
  try {
    const direct = sendCmd(cmd); // string or promise
    result = await Promise.race([
      Promise.resolve(direct),
      new Promise(res => setTimeout(() => res(''), timeoutMs)),
    ]);
  } finally {
    try { startTempPolling?.(); } catch {}
  }
  return String(result || '');
}



function renderM115Table(containerSelector, parsed) {
  const el = document.querySelector(containerSelector);
  if (!el) return;
  const tbody = el.querySelector('tbody');
  if (!tbody) return;

  const { info = {}, caps = {}, area = null } = parsed || {};
  const rows = [];

  // Primary info
  const order = [
    ['FIRMWARE_NAME','Firmware'],
    ['SOURCE_CODE_URL','Source code URL'],
    ['PROTOCOL_VERSION','Protocol version'],
    ['MACHINE_TYPE','Machine type'],
    ['EXTRUDER_COUNT','Extruder count'],
    ['UUID','UUID'],
  ];
  order.forEach(([key, label]) => {
    if (info[key] != null) rows.push([label, escapeHtml(String(info[key]))]);
  });

  // Add any extra keys we didn't list above
  Object.keys(info).sort().forEach(k => {
    if (order.find(x => x[0] === k)) return; // already added
    rows.push([k.replace(/_/g,' '), escapeHtml(String(info[k]))]);
  });

  // Separator
  if (Object.keys(caps).length) rows.push(['', '', true]);

  // Capabilities (sorted)
  if (Object.keys(caps).length) {
    rows.push(['Capabilities', '']);
    Object.keys(caps).sort().forEach(name => {
      rows.push([`• ${name}`, caps[name] ? 'Yes' : 'No']);
    });
  }

  // Separator
  if (area) rows.push(['', '', true]);

  // Area (pretty)
  if (area) {
    const full = area.full || {};
    const work = area.work || {};
    const fmin = full.min || {}, fmax = full.max || {};
    const wmin = work.min || {}, wmax = work.max || {};
    rows.push(['Area (full)', `min x:${fmin.x}, y:${fmin.y}, z:${fmin.z} &nbsp; | &nbsp; max x:${fmax.x}, y:${fmax.y}, z:${fmax.z}`]);
    rows.push(['Area (work)', `min x:${wmin.x}, y:${wmin.y}, z:${wmin.z} &nbsp; | &nbsp; max x:${wmax.x}, y:${wmax.y}, z:${wmax.z}`]);
  }

  putTableRows(tbody, rows);
}

function renderM503Table(containerSelector, cfg) {
  const el = document.querySelector(containerSelector);
  if (!el) return;
  const tbody = el.querySelector('tbody');
  if (!tbody) return;

  const rows = [];
  const yesno = v => v == null ? '—' : (v ? 'On' : 'Off');

  // General
  rows.push(['Units', cfg.units || '—']);
  rows.push(['Filament settings', cfg.filament?.enabled == null ? '—' : (cfg.filament.enabled ? 'Enabled' : 'Disabled')]);
  rows.push(['Filament (M200)', cfg.filament?.M200 ? `S=${cfg.filament.M200.S} D=${cfg.filament.M200.D}` : '—']);
  rows.push(['Home offset (M206)', cfg.homeOffset ? `X=${cfg.homeOffset.X} Y=${cfg.homeOffset.Y} Z=${cfg.homeOffset.Z}` : '—']);
  rows.push(['Power-loss recovery (M413)', yesno(cfg.powerLossRecovery)]);
  rows.push(['Runout sensor (M412)', yesno(cfg.runout)]);

  rows.push(['', '', true]);

  // Motion
  rows.push(['Steps/mm (M92)', cfg.stepsPerUnit ? `X=${cfg.stepsPerUnit.X} Y=${cfg.stepsPerUnit.Y} Z=${cfg.stepsPerUnit.Z} E=${cfg.stepsPerUnit.E}` : '—']);
  rows.push(['Max feedrate (M203)', cfg.maxFeedrate ? `X=${cfg.maxFeedrate.X} Y=${cfg.maxFeedrate.Y} Z=${cfg.maxFeedrate.Z} E=${cfg.maxFeedrate.E}` : '—']);
  rows.push(['Max acceleration (M201)', cfg.maxAccel ? `X=${cfg.maxAccel.X} Y=${cfg.maxAccel.Y} Z=${cfg.maxAccel.Z} E=${cfg.maxAccel.E}` : '—']);
  rows.push(['Acceleration (M204)', cfg.accel ? `P=${cfg.accel.P} R=${cfg.accel.R} T=${cfg.accel.T}` : '—']);
  rows.push(['Advanced (M205)', cfg.advanced ? `B=${cfg.advanced.B} S=${cfg.advanced.S} T=${cfg.advanced.T} X=${cfg.advanced.X} Y=${cfg.advanced.Y} Z=${cfg.advanced.Z} E=${cfg.advanced.E}` : '—']);
  rows.push(['Linear advance (M900)', (cfg.linearAdvance ?? '—')]);

  rows.push(['', '', true]);

  // Temperatures / PID / Presets
  rows.push(['PID hotend (M301)', cfg.pid?.hotend ? `P=${cfg.pid.hotend.P} I=${cfg.pid.hotend.I} D=${cfg.pid.hotend.D}` : '—']);
  rows.push(['PID bed (M304)', cfg.pid?.bed ? `P=${cfg.pid.bed.P} I=${cfg.pid.bed.I} D=${cfg.pid.bed.D}` : '—']);
  rows.push(['Presets (M145)', (cfg.presets && cfg.presets.length)
    ? cfg.presets.map(p => `S${p.S}: H${p.H}/B${p.B}/F${p.F}`).join(', ')
    : '—']);
  rows.push(['Probe heaters off (C001)', cfg.probeHeatersOff
    ? `S=${cfg.probeHeatersOff.S ? 'On' : 'Off'} H=${cfg.probeHeatersOff.H} B=${cfg.probeHeatersOff.B} W=${cfg.probeHeatersOff.W}`
    : '—']);

  rows.push(['', '', true]);

  // Retract / Recover / Auto-retract / Z-probe
  rows.push(['Retract (M207)', cfg.retract ? `S=${cfg.retract.S} W=${cfg.retract.W} F=${cfg.retract.F} Z=${cfg.retract.Z}` : '—']);
  rows.push(['Recover (M208)', cfg.recover ? `S=${cfg.recover.S} W=${cfg.recover.W} F=${cfg.recover.F}` : '—']);
  rows.push(['Auto-retract (M209)', yesno(cfg.autoRetract)]);
  rows.push(['Z-probe offset (M851)', cfg.zProbeOffset ? `X=${cfg.zProbeOffset.X} Y=${cfg.zProbeOffset.Y} Z=${cfg.zProbeOffset.Z}` : '—']);

  rows.push(['', '', true]);

  // ABL
  const ablStr = cfg.abl ? `Enabled=${cfg.abl.enabled ? 'Yes' : 'No'}${cfg.abl.fade != null ? `, Fade Z=${cfg.abl.fade}` : ''}` : '—';
  rows.push(['Auto Bed Leveling (M420)', ablStr]);

  // Mesh (embed a colored table)
  if (cfg.mesh && cfg.mesh.nx && cfg.mesh.ny) {
    const { nx, ny, values } = cfg.mesh;
    const flat = values.flat().filter(v => typeof v === 'number');
    const min = Math.min(...flat), max = Math.max(...flat);
    const range = max - min || 1;

    const td = (z) => {
      let bg = '#eee';
      if (typeof z === 'number') {
        const t = (z - min) / range;
        let r,g,b;
        if (t < 0.5) { const k = t/0.5; r=0; g=Math.round(255*k); b=Math.round(255*(1-k)); }
        else { const k=(t-0.5)/0.5; r=Math.round(255*k); g=Math.round(255*(1-k)); b=0; }
        bg = `rgb(${r},${g},${b})`;
      }
      return `<td style="padding:6px;text-align:center;background:${bg};border:1px solid #ddd">${(z==null)?'':Number(z).toFixed(5)}</td>`;
    };

    const stats = `<div><strong>Mesh:</strong> ${nx}×${ny}
      &nbsp;|&nbsp;<strong>Min:</strong> ${min.toFixed(5)}
      &nbsp;|&nbsp;<strong>Max:</strong> ${max.toFixed(5)}
      &nbsp;|&nbsp;<strong>Avg:</strong> ${(flat.reduce((a,b)=>a+b,0)/flat.length).toFixed(5)}
      &nbsp;|&nbsp;<strong>Range:</strong> ${(max-min).toFixed(5)}</div>`;

    const table = `<div style="margin-top:6px">${stats}</div>
      <table style="border-collapse:collapse;margin-top:6px">
        <tbody>
          ${values.map(row => `<tr>${row.map(td).join('')}</tr>`).join('')}
        </tbody>
      </table>`;

    rows.push(['G29 Mesh', table]);
  } else {
    rows.push(['G29 Mesh', '<em>No mesh data</em>']);
  }

  putTableRows(tbody, rows);
}


function escapeHtml(s) {
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

function putTableRows(tbody, rows) {
  tbody.innerHTML = rows.map(([k, v, isSeparator]) => {
    if (isSeparator) {
      return `<tr><td colspan="2" style="padding:8px 0"><hr/></td></tr>`;
    }
    return `<tr>
      <th style="border:1px solid #ddd;padding:6px;text-align:left;background:#fafafa">${escapeHtml(k)}</th>
      <td style="border:1px solid #ddd;padding:6px;text-align:left">${v}</td>
    </tr>`;
  }).join('');
}

function parseM122(text) {
  const axes = { X:{}, Y:{}, Z:{}, E:{} };
  const boolify = v => /^(enabled|true|yes|1)$/i.test(v) ? 'enabled'
                    : /^(disabled|false|no|0)$/i.test(v) ? 'disabled' : String(v);

  const lines = String(text || '')
    .split(/\r?\n/)
    .map(s => s.replace(/^echo:\s*/i, '').trim())
    .filter(s => s && !/^>>\s*M122\b/i.test(s) && !/^ok\b/i.test(s));

  for (const ln of lines) {
    // Axis-prefixed key-value style lines
    // Examples: "X driver: TMC2209", "Y RMS current: 850", "E microsteps: 16",
    //           "Z stealthChop: enabled", "X spreadCycle: disabled", "E otpw: false", "Y error: false"
    let m = ln.match(/^([XYZE])\s+driver:\s*(.+)$/i);
    if (m) { axes[m[1].toUpperCase()].driver = m[2].trim(); continue; }

    m = ln.match(/^([XYZE]).*?\bRMS\s*current:\s*([\d.]+)/i);
    if (m) { axes[m[1].toUpperCase()].rms = +m[2]; continue; }

    m = ln.match(/^([XYZE]).*?\bmicrosteps?:\s*([\d.]+)/i);
    if (m) { axes[m[1].toUpperCase()].msteps = +m[2]; continue; }

    m = ln.match(/^([XYZE]).*?\bstealthchop:\s*(\S+)/i);
    if (m) { axes[m[1].toUpperCase()].stealth = boolify(m[2]); continue; }

    m = ln.match(/^([XYZE]).*?\bspreadcycle:\s*(\S+)/i);
    if (m) { axes[m[1].toUpperCase()].spread = boolify(m[2]); continue; }

    m = ln.match(/^([XYZE]).*?\botpw:\s*(\S+)/i);
    if (m) { axes[m[1].toUpperCase()].otpw = boolify(m[2]); continue; }

    m = ln.match(/^([XYZE]).*?\berror:\s*(\S+)/i);
    if (m) { axes[m[1].toUpperCase()].error = boolify(m[2]); continue; }

    // If you later want more, add patterns here (e.g., CS actual, SG, TSTEP).
  }
  return axes;
}

function _fillMissingM503Fields(cfg, cleanLines) {
  const num = s => (s == null ? null : Number(s));

  // M200 S<mode> D<dia>
  if (!cfg.filament?.M200) {
    const m = cleanLines.find(l => /^M200\b/i.test(l));
    if (m) {
      const g = /M200(?:\s+S(?<S>-?\d+(?:\.\d+)?))?(?:\s+D(?<D>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.filament = cfg.filament || {};
      cfg.filament.M200 = { S: num(g.S), D: num(g.D) };
    }
  }

  // M206 X Y Z
  if (!cfg.homeOffset) {
    const m = cleanLines.find(l => /^M206\b/i.test(l));
    if (m) {
      const g = /M206(?:\s+X(?<X>-?\d+(?:\.\d+)?))?(?:\s+Y(?<Y>-?\d+(?:\.\d+)?))?(?:\s+Z(?<Z>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.homeOffset = { X: num(g.X), Y: num(g.Y), Z: num(g.Z) };
    }
  }

  // M145 S H B F   (can appear multiple times)
  if (!cfg.presets || !cfg.presets.length) {
    cfg.presets = [];
    cleanLines.filter(l => /^M145\b/i.test(l)).forEach(l => {
      const g = /M145(?:\s+S(?<S>\d+))?(?:\s+H(?<H>-?\d+(?:\.\d+)?))?(?:\s+B(?<B>-?\d+(?:\.\d+)?))?(?:\s+F(?<F>-?\d+(?:\.\d+)?))?/i.exec(l)?.groups || {};
      if (g.S != null) cfg.presets.push({ S: Number(g.S), H: num(g.H), B: num(g.B), F: num(g.F) });
    });
  }

  // M301 / M304 PID
  if (!cfg.pid) cfg.pid = {};
  if (!cfg.pid.hotend) {
    const m = cleanLines.find(l => /^M301\b/i.test(l));
    if (m) {
      const g = /M301(?:\s+P(?<P>-?\d+(?:\.\d+)?))?(?:\s+I(?<I>-?\d+(?:\.\d+)?))?(?:\s+D(?<D>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.pid.hotend = { P: num(g.P), I: num(g.I), D: num(g.D) };
    }
  }
  if (!cfg.pid.bed) {
    const m = cleanLines.find(l => /^M304\b/i.test(l));
    if (m) {
      const g = /M304(?:\s+P(?<P>-?\d+(?:\.\d+)?))?(?:\s+I(?<I>-?\d+(?:\.\d+)?))?(?:\s+D(?<D>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.pid.bed = { P: num(g.P), I: num(g.I), D: num(g.D) };
    }
  }

  // M413 S
  if (cfg.powerLossRecovery == null) {
    const m = cleanLines.find(l => /^M413\b/i.test(l));
    if (m) cfg.powerLossRecovery = /S1\b/.test(m);
  }

  // M207 S W F Z
  if (!cfg.retract) {
    const m = cleanLines.find(l => /^M207\b/i.test(l));
    if (m) {
      const g = /M207(?:\s+S(?<S>-?\d+(?:\.\d+)?))?(?:\s+W(?<W>-?\d+(?:\.\d+)?))?(?:\s+F(?<F>-?\d+(?:\.\d+)?))?(?:\s+Z(?<Z>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.retract = { S: num(g.S), W: num(g.W), F: num(g.F), Z: num(g.Z) };
    }
  }

  // M208 S W F
  if (!cfg.recover) {
    const m = cleanLines.find(l => /^M208\b/i.test(l));
    if (m) {
      const g = /M208(?:\s+S(?<S>-?\d+(?:\.\d+)?))?(?:\s+W(?<W>-?\d+(?:\.\d+)?))?(?:\s+F(?<F>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.recover = { S: num(g.S), W: num(g.W), F: num(g.F) };
    }
  }

  // M209 S
  if (cfg.autoRetract == null) {
    const m = cleanLines.find(l => /^M209\b/i.test(l));
    if (m) cfg.autoRetract = /S1\b/.test(m);
  }

  // M851 X Y Z (X/Y may be integers in your dump)
  if (!cfg.zProbeOffset) {
    const m = cleanLines.find(l => /^M851\b/i.test(l));
    if (m) {
      const g = /M851(?:\s+X(?<X>-?\d+(?:\.\d+)?))?(?:\s+Y(?<Y>-?\d+(?:\.\d+)?))?(?:\s+Z(?<Z>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.zProbeOffset = { X: num(g.X), Y: num(g.Y), Z: num(g.Z) };
    }
  }

  // M900 K
  if (cfg.linearAdvance == null) {
    const m = cleanLines.find(l => /^M900\b/i.test(l));
    if (m) {
      const g = /M900(?:\s+K(?<K>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.linearAdvance = num(g.K);
    }
  }

  // M412 S
  if (cfg.runout == null) {
    const m = cleanLines.find(l => /^M412\b/i.test(l));
    if (m) cfg.runout = /S1\b/.test(m);
  }

  // C001 S H B W  (CR-6 helper)
  if (!cfg.probeHeatersOff) {
    const m = cleanLines.find(l => /^C001\b/i.test(l));
    if (m) {
      const g = /C001(?:\s+S(?<S>[01]))?(?:\s+H(?<H>-?\d+(?:\.\d+)?))?(?:\s+B(?<B>-?\d+(?:\.\d+)?))?(?:\s+W(?<W>-?\d+))?/i.exec(m)?.groups || {};
      cfg.probeHeatersOff = { S: g.S === '1', H: num(g.H), B: num(g.B), W: g.W != null ? Number(g.W) : null };
    }
  }
}

// ---------- PARSER FOR M503 ----------
function parseM503Response(raw) {
  const lines = raw.replace(/\r/g, '').split('\n').map(s => s.trim()).filter(Boolean);

  const cfg = {
    filament: {},
    pid: {},
    abl: {},
    presets: []
  };

  const num = s => (s == null ? null : Number(s));
  const grab = (re, line) => (re.exec(line) || {}).groups || null;

  const clean = lines.map(l => l.replace(/^echo:\s*/, '').trim());

  for (const line of clean) {
    if (/^G21\b/.test(line)) cfg.units = 'mm';
    if (/^G20\b/.test(line)) cfg.units = 'in';

    if (/^; Filament settings:\s*(Enabled|Disabled)/i.test(line))
      cfg.filament.enabled = /Enabled/i.test(line);

    if (/^M92\b/.test(line)) {
      const g = grab(/M92\s+X(?<X>\S+)\s+Y(?<Y>\S+)\s+Z(?<Z>\S+)\s+E(?<E>\S+)/, line);
      if (g) cfg.stepsPerUnit = { X: num(g.X), Y: num(g.Y), Z: num(g.Z), E: num(g.E) };
    }

    if (/^M203\b/.test(line)) {
      const g = grab(/M203\s+X(?<X>\S+)\s+Y(?<Y>\S+)\s+Z(?<Z>\S+)\s+E(?<E>\S+)/, line);
      if (g) cfg.maxFeedrate = { X: num(g.X), Y: num(g.Y), Z: num(g.Z), E: num(g.E) };
    }

    if (/^M201\b/.test(line)) {
      const g = grab(/M201\s+X(?<X>\S+)\s+Y(?<Y>\S+)\s+Z(?<Z>\S+)\s+E(?<E>\S+)/, line);
      if (g) cfg.maxAccel = { X: num(g.X), Y: num(g.Y), Z: num(g.Z), E: num(g.E) };
    }

    if (/^M204\b/.test(line)) {
      const g = grab(/M204\s+P(?<P>\S+)\s+R(?<R>\S+)\s+T(?<T>\S+)/, line);
      if (g) cfg.accel = { P: num(g.P), R: num(g.R), T: num(g.T) };
    }

    if (/^M205\b/.test(line)) {
      const g = grab(/M205.*X(?<X>\S+).*Y(?<Y>\S+).*Z(?<Z>\S+).*E(?<E>\S+)/, line);
      if (g) cfg.advanced = { X: num(g.X), Y: num(g.Y), Z: num(g.Z), E: num(g.E) };
    }

    if (/^M420\b/.test(line)) {
      const g = grab(/M420\s+S(?<S>[01])(?:\s+Z(?<Z>\S+))?/, line);
      if (g) { cfg.abl.enabled = g.S === '1'; cfg.abl.fade = num(g.Z); }
    }

    if (/^G29\s+W\b/.test(line)) {
      const g = grab(/I(?<I>\d+)\s+J(?<J>\d+)\s+Z(?<Z>\S+)/, line);
      if (g) {
        const I = Number(g.I), J = Number(g.J), Z = num(g.Z);
        if (!cfg.mesh) cfg.mesh = { nx: 0, ny: 0, values: [] };
        cfg.mesh.nx = Math.max(cfg.mesh.nx, I + 1);
        cfg.mesh.ny = Math.max(cfg.mesh.ny, J + 1);
        cfg.mesh.values[J] = cfg.mesh.values[J] || [];
        cfg.mesh.values[J][I] = Z;
      }
    }
  }
_fillMissingM503Fields(cfg, clean);
  return cfg;
}


function putRows(tbodySel, rows) {
  const tbody = document.querySelector(tbodySel);
  if (!tbody) return;
  tbody.innerHTML = rows
    .map(([k, v]) => `<tr><th style="text-align:left">${k}</th><td style="text-align:left">${v ?? ''}</td></tr>`)
    .join('');
}

function renderM503Fields(cfg) {
  // General
  putRows('#m503General tbody', [
    ['Units', cfg.units || '—'],
    ['Filament Settings', cfg.filament.enabled == null ? '—' : (cfg.filament.enabled ? 'Enabled' : 'Disabled')],
    ['Filament (M200)', cfg.filament.M200 ? `S=${cfg.filament.M200.S} D=${cfg.filament.M200.D}` : '—'],
    ['Home Offset (M206)', cfg.homeOffset ? `X=${cfg.homeOffset.X} Y=${cfg.homeOffset.Y} Z=${cfg.homeOffset.Z}` : '—'],
    ['Power-loss Recovery (M413)', cfg.powerLossRecovery == null ? '—' : (cfg.powerLossRecovery ? 'On' : 'Off')],
    ['Runout Sensor (M412)', cfg.runout == null ? '—' : (cfg.runout ? 'On' : 'Off')],
  ]);

  // Motion
  putRows('#m503Motion tbody', [
    ['Steps/mm (M92)', cfg.stepsPerUnit ? `X=${cfg.stepsPerUnit.X} Y=${cfg.stepsPerUnit.Y} Z=${cfg.stepsPerUnit.Z} E=${cfg.stepsPerUnit.E}` : '—'],
    ['Max Feedrate (M203)', cfg.maxFeedrate ? `X=${cfg.maxFeedrate.X} Y=${cfg.maxFeedrate.Y} Z=${cfg.maxFeedrate.Z} E=${cfg.maxFeedrate.E}` : '—'],
    ['Max Accel (M201)', cfg.maxAccel ? `X=${cfg.maxAccel.X} Y=${cfg.maxAccel.Y} Z=${cfg.maxAccel.Z} E=${cfg.maxAccel.E}` : '—'],
    ['Accel (M204)', cfg.accel ? `P=${cfg.accel.P} R=${cfg.accel.R} T=${cfg.accel.T}` : '—'],
    ['Advanced (M205)', cfg.advanced ? `B=${cfg.advanced.B} S=${cfg.advanced.S} T=${cfg.advanced.T} X=${cfg.advanced.X} Y=${cfg.advanced.Y} Z=${cfg.advanced.Z} E=${cfg.advanced.E}` : '—'],
    ['Linear Advance (M900)', cfg.linearAdvance ?? '—'],
  ]);

  // Temperatures / PID / Presets
  putRows('#m503Temps tbody', [
    ['PID Hotend (M301)', cfg.pid.hotend ? `P=${cfg.pid.hotend.P} I=${cfg.pid.hotend.I} D=${cfg.pid.hotend.D}` : '—'],
    ['PID Bed (M304)', cfg.pid.bed ? `P=${cfg.pid.bed.P} I=${cfg.pid.bed.I} D=${cfg.pid.bed.D}` : '—'],
    ['Presets (M145)', cfg.presets.length ? cfg.presets.map(p => `S${p.S}: H${p.H}/B${p.B}/F${p.F}`).join(', ') : '—'],
    ['Probe Heaters Off (C001)', cfg.probeHeatersOff ? `S=${cfg.probeHeatersOff.S ? 'On' : 'Off'} H=${cfg.probeHeatersOff.H} B=${cfg.probeHeatersOff.B} W=${cfg.probeHeatersOff.W}` : '—'],
  ]);

  // Retract
  putRows('#m503Retract tbody', [
    ['Retract (M207)', cfg.retract ? `S=${cfg.retract.S} W=${cfg.retract.W} F=${cfg.retract.F} Z=${cfg.retract.Z}` : '—'],
    ['Recover (M208)', cfg.recover ? `S=${cfg.recover.S} W=${cfg.recover.W} F=${cfg.recover.F}` : '—'],
    ['Auto-Retract (M209)', cfg.autoRetract == null ? '—' : (cfg.autoRetract ? 'On' : 'Off')],
    ['Z Probe Offset (M851)', cfg.zProbeOffset ? `X=${cfg.zProbeOffset.X} Y=${cfg.zProbeOffset.Y} Z=${cfg.zProbeOffset.Z}` : '—'],
  ]);

  // ABL + Mesh
  const ablStr = `Enabled=${cfg.abl.enabled ? 'Yes' : 'No'}${cfg.abl.fade != null ? `, Fade Z=${cfg.abl.fade}` : ''}`;
  putRows('#m503ABL tbody', [['ABL (M420)', ablStr]]);

  renderMesh('#m503Mesh', cfg.mesh);
}

function renderMesh(containerSel, mesh) {
  const container = document.querySelector(containerSel);
  if (!container) return;
  if (!mesh) { container.innerHTML = '<em>No mesh</em>'; return; }

  // Stats
  const vals = mesh.values.flat().filter(v => typeof v === 'number');
  const min = Math.min(...vals), max = Math.max(...vals);
  const avg = vals.reduce((a,b)=>a+b,0) / vals.length;
  const range = max - min;

  // Simple color mapping (green ~ median, blue = low, red = high)
  const tdFor = (z) => {
    let bg = '#eee';
    if (typeof z === 'number') {
      const t = range > 1e-9 ? (z - min) / range : 0.5;
      // interpolate blue(0) -> green(0.5) -> red(1)
      let r,g,b;
      if (t < 0.5) { // blue to green
        const k = t/0.5; r = 0; g = Math.round(255*k); b = Math.round(255*(1-k));
      } else { // green to red
        const k = (t-0.5)/0.5; r = Math.round(255*k); g = Math.round(255*(1-k)); b = 0;
      }
      bg = `rgb(${r},${g},${b})`;
    }
    const text = (z==null) ? '' : z.toFixed(5);
    return `<td style="padding:6px; text-align:center; background:${bg}; color:#000;">${text}</td>`;
  };

  const header = `<div style="margin:6px 0;">
    <strong>Mesh:</strong> ${mesh.nx}×${mesh.ny}
    &nbsp;|&nbsp; <strong>Min:</strong> ${min.toFixed(5)}
    &nbsp;|&nbsp; <strong>Max:</strong> ${max.toFixed(5)}
    &nbsp;|&nbsp; <strong>Avg:</strong> ${avg.toFixed(5)}
    &nbsp;|&nbsp; <strong>Range:</strong> ${range.toFixed(5)}
  </div>`;

  const rows = mesh.values.map(row => `<tr>${row.map(tdFor).join('')}</tr>`).join('');
  container.innerHTML = header + `<table style="border-collapse:collapse;"><tbody>${rows}</tbody></table>`;
}

function renderM115Fields(parsed) {
  const { info, caps, area } = parsed;
  const tbody = document.querySelector('#m115Table tbody');
  if (!tbody) return;

  const rows = [];

  // Top-level info (show common keys nicely)
  const mapKeys = [
    ['FIRMWARE_NAME', 'Firmware'],
    ['SOURCE_CODE_URL', 'Source'],
    ['PROTOCOL_VERSION', 'Protocol'],
    ['MACHINE_TYPE', 'Machine'],
    ['EXTRUDER_COUNT', 'Extruders'],
    ['UUID', 'UUID'],
  ];

  for (const [k, label] of mapKeys) {
    if (info[k]) rows.push([label, info[k]]);
  }

  // Caps (only show ones present)
  const capEntries = Object.keys(caps).sort().map(name => [name, caps[name] ? 'Yes' : 'No']);
  if (capEntries.length) {
    rows.push(['—', '—']);
    rows.push(['Capabilities', '']);
    for (const [k, v] of capEntries) rows.push(['• ' + k, v]);
  }

  // Area (pretty print if available)
  if (area) {
    rows.push(['—', '—']);
    rows.push(['Area (full)', `min x:${area.full?.min?.x}, y:${area.full?.min?.y}, z:${area.full?.min?.z} | max x:${area.full?.max?.x}, y:${area.full?.max?.y}, z:${area.full?.max?.z}`]);
    rows.push(['Area (work)', `min x:${area.work?.min?.x}, y:${area.work?.min?.y}, z:${area.work?.min?.z} | max x:${area.work?.max?.x}, y:${area.work?.max?.y}, z:${area.work?.max?.z}`]);
  }

  // Render
  tbody.innerHTML = rows.map(([k, v]) => `<tr><th style="text-align:left">${k}</th><td style="text-align:left">${v ?? ''}</td></tr>`).join('');
}


function parseM115(text) {
  const cfg = {};
  String(text || '')
    .split(/\r?\n/)
    .map(s => s.replace(/^echo:\s*/i, '').trim())
    .filter(s => s && !/^ok\b/i.test(s))
    .forEach(line => {
      if (/^FIRMWARE_NAME:/i.test(line))   cfg.name      = line.split(':')[1]?.trim();
      else if (/^FIRMWARE_URL:/i.test(line)) cfg.url     = line.split(':')[1]?.trim();
      else if (/^PROTOCOL_VERSION:/i.test(line)) cfg.protocol = line.split(':')[1]?.trim();
      else if (/^MACHINE_TYPE:/i.test(line)) cfg.machine = line.split(':')[1]?.trim();
      else if (/^EXTRUDER_COUNT:/i.test(line)) cfg.extruders = line.split(':')[1]?.trim();
      else if (/^UUID:/i.test(line))       cfg.uuid      = line.split(':')[1]?.trim();
    });
  return cfg;
}

function parseM115Response(raw) {
  const info = {};
  const caps = {};
  let area = null;

  const lines = raw
    .replace(/\r/g, '')
    .split('\n')
    .map(s => s.trim())
    .filter(Boolean);

  const mainLine = lines.find(l => /FIRMWARE_NAME:/.test(l));
  if (mainLine) {
    const re = /([A-Z_]+):(.*?)(?=\s[A-Z_]+:|$)/g;
    let m;
    while ((m = re.exec(mainLine)) !== null) {
      info[m[1]] = m[2].trim();
    }
  }

  for (const line of lines) {
    const capMatch = /^Cap:([A-Z_]+):([01])$/.exec(line);
    if (capMatch) caps[capMatch[1]] = capMatch[2] === '1';
  }

  const areaLine = lines.find(l => /^area:\{/.test(l));
  if (areaLine) {
    try {
      const jsonish = areaLine
        .replace(/^area:/, '')
        .replace(/([a-zA-Z_]+)\s*:/g, '"$1":');
      area = JSON.parse(jsonish);
    } catch (e) { console.warn('Failed to parse area:', e); }
  }

  return { info, caps, area };
}

function parseM503(text) {
  const out = {};

  // Normalize lines: strip comments like echo:, trim
  const lines = String(text || '')
    .replace(/^echo:\s*/gmi, '')
    .split(/\r?\n/).map(s => s.trim()).filter(Boolean);

  const grab = (re, parseFn = (m)=>m) => {
    for (const ln of lines) {
      const m = ln.match(re);
      if (m) return parseFn(m);
    }
    return null;
  };

  // M92: Steps/mm
  // e.g. "M92 X80.00 Y80.00 Z400.00 E420.00"
  out.M92 = grab(/\bM92\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([EXYZA])\s*([-+]?\d*\.?\d+)/gi, (_, ax, v) => (obj[ax.toUpperCase()] = +v));
    return obj;
  });

  // M203: Max feedrate mm/s
  out.M203 = grab(/\bM203\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([EXYZA])\s*([-+]?\d*\.?\d+)/gi, (_, ax, v) => (obj[ax.toUpperCase()] = +v));
    return obj;
  });

  // M201: Acceleration mm/s²
  out.M201 = grab(/\bM201\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([EXYZA])\s*([-+]?\d*\.?\d+)/gi, (_, ax, v) => (obj[ax.toUpperCase()] = +v));
    return obj;
  });

  // M204: Accel presets (P/R/T)
  // e.g. "M204 P500.00 R1000.00 T500.00" OR Marlin variants A/T
  out.M204 = grab(/\bM204\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([PRTA])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = +v));
    return obj;
  });

  // M205: Jerk/junction settings (X/Y/Z/E, J, S, T etc.)
  out.M205 = grab(/\bM205\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([A-Z])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = +v));
    return obj;
  });

  // M851: Z probe offset
  out.M851 = grab(/\bM851\s+Z\s*([-+]?\d*\.?\d+)/i, m => ({ Z: +m[1] }));

  // M301: Hotend PID "M301 P22.20 I1.08 D114.00"
  out.M301 = grab(/\bM301\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([PID])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = +v));
    return obj;
  });

  // M304: Bed PID
  out.M304 = grab(/\bM304\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([PID])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = +v));
    return obj;
  });

  // M420: Bed leveling state
  // e.g. "M420 S1 Z0.00" (S=on/off, Z=fade)
  out.M420 = grab(/\bM420\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([A-Z])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = isNaN(v) ? v : +v));
    return obj;
  });

  // M404: Filament diameter
  out.M404 = grab(/\bM404\s+(?:DN?\s*)?([-+]?\d*\.?\d+)/i, m => ({ D: +m[1] }));

  return out;
}

function fmtKV(obj, order) {
  if (!obj) return '—';
  const keys = order && order.length ? order : Object.keys(obj);
  return keys.filter(k => obj[k] != null)
             .map(k => `${k}:${obj[k]}`)
             .join(' · ') || '—';
}

const isVirtual = () => virtualToggle?.checked === true;

function renderM503Fields(cfg) {
  const set = (id, text) => { const el = document.getElementById(id); if (el) el.textContent = text || '—'; };

  set('f_M92',  fmtKV(cfg.M92,  ['X','Y','Z','E']));
  set('f_M203', fmtKV(cfg.M203, ['X','Y','Z','E']));
  set('f_M201', fmtKV(cfg.M201, ['X','Y','Z','E']));
  set('f_M204', fmtKV(cfg.M204, ['P','R','T','A']));
  set('f_M205', fmtKV(cfg.M205));
  set('f_M851', cfg.M851 && typeof cfg.M851.Z === 'number' ? `Z:${cfg.M851.Z}` : '—');
  set('f_M301', fmtKV(cfg.M301, ['P','I','D']));
  set('f_M304', fmtKV(cfg.M304, ['P','I','D']));
  set('f_M420', fmtKV(cfg.M420, ['S','Z']));
  set('f_M404', cfg.M404 && cfg.M404.D ? `D:${cfg.M404.D}` : '—');
}


// Wire buttons

document.getElementById('exportCfgBtn')?.addEventListener('click', () => {
  const cfg = window._lastParsedCfg || {};
  const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: 'application/json' });
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'm503_parsed.json'; a.click();
  URL.revokeObjectURL(url);
});

// Optional: auto-parse on paste/changes to the textarea
configBox?.addEventListener('input', () => {
  // lightweight debounce
  clearTimeout(configBox._deb);
  configBox._deb = setTimeout(() => {
    const cfg = parseM503(configBox.value || '');
    renderM503Fields(cfg);
    window._lastParsedCfg = cfg;
  }, 250);
});


// ===== Maintenance Logbook =====
const LS_MAINT = 'maintLog';
let maint = [];               // [{id, dateISO, note, createdTs}]
let maintEditingId = null;

// DOM refs (Maintenance)
const maintForm     = document.getElementById('maintForm');
const maintDate     = document.getElementById('maintDate');
const maintNote     = document.getElementById('maintNote');
const maintSaveBtn  = document.getElementById('maintSave');
const maintResetBtn = document.getElementById('maintReset');
const maintTable    = document.getElementById('maintTable');
const maintSummary  = document.getElementById('maintSummary');
const maintExport   = document.getElementById('maintExport');
const maintClearAll = document.getElementById('maintClearAll');

function loadMaint() {
  try { maint = JSON.parse(localStorage.getItem(LS_MAINT) || '[]'); }
  catch { maint = []; }
}
function saveMaint() {
  localStorage.setItem(LS_MAINT, JSON.stringify(maint));
}
function genMaintId() {
  return 'M' + Date.now().toString(36) + Math.random().toString(36).slice(2,5).toUpperCase();
}
function clearMaintForm() {
  maintEditingId = null;
  maintDate.value = new Date().toISOString().slice(0,10); // today
  maintNote.value = '';
  maintSaveBtn.textContent = 'Save';
}
function renderMaint() {
  // newest first
  const rows = [...maint].sort((a,b) => (b.dateISO||'').localeCompare(a.dateISO) || b.createdTs - a.createdTs)
    .map(m => {
      const d = m.dateISO || '—';
      const n = (m.note || '').replace(/</g,'&lt;');
      return `<tr>
        <td>${d}</td>
        <td style="text-align:left">${n}</td>
        <td>
          <button type="button" data-edit="${m.id}">Edit</button>
          <button type="button" data-del="${m.id}">Delete</button>
        </td>
      </tr>`;
    }).join('');
  maintTable.innerHTML = rows || `<tr><td colspan="3" class="muted">No maintenance recorded yet.</td></tr>`;
  maintSummary.textContent = `${maint.length} entr${maint.length===1?'y':'ies'}`;
}

function upsertMaintFromForm() {
  const dateISO = maintDate.value || new Date().toISOString().slice(0,10);
  const note = maintNote.value.trim();
  if (!note) { alert('Please enter a note.'); return; }

  if (maintEditingId) {
    const i = maint.findIndex(m => m.id === maintEditingId);
    if (i !== -1) {
      maint[i].dateISO = dateISO;
      maint[i].note = note;
    }
  } else {
    maint.push({
      id: genMaintId(),
      dateISO,
      note,
      createdTs: Date.now()
    });
  }
  saveMaint();
  clearMaintForm();
  renderMaint();
}

function editMaint(id) {
  const m = maint.find(x => x.id === id);
  if (!m) return;
  maintEditingId = id;
  maintDate.value = m.dateISO || new Date().toISOString().slice(0,10);
  maintNote.value = m.note || '';
  maintSaveBtn.textContent = 'Update';
}

function deleteMaint(id) {
  const i = maint.findIndex(x => x.id === id);
  if (i === -1) return;
  if (!confirm('Delete this entry?')) return;
  maint.splice(i, 1);
  saveMaint();
  renderMaint();
}

// Event wiring
maintForm?.addEventListener('submit', (e) => { e.preventDefault(); upsertMaintFromForm(); });
maintResetBtn?.addEventListener('click', clearMaintForm);

maintTable?.addEventListener('click', (e) => {
  const t = e.target;
  if (t.matches('button[data-edit]')) editMaint(t.getAttribute('data-edit'));
  if (t.matches('button[data-del]'))  deleteMaint(t.getAttribute('data-del'));
});

maintExport?.addEventListener('click', () => {
  const blob = new Blob([JSON.stringify(maint, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'maintenance-log.json'; a.click();
  URL.revokeObjectURL(url);
});

maintClearAll?.addEventListener('click', () => {
  if (!maint.length) return;
  if (!confirm('Clear ALL maintenance entries?')) return;
  maint = [];
  saveMaint();
  renderMaint();
});

// Initialize logbook once on load
(function maintInit(){
  if (!maintForm) return; // in case markup not present
  loadMaint();
  clearMaintForm();
  renderMaint();
})();


//Filament
const DEFAULT_DENSITY = {
  'PLA': 1.24, 'PETG': 1.27, 'ABS': 1.04, 'TPU': 1.21, 'Nylon': 1.15,
  'PC': 1.20, 'PVA': 1.23
};
const LS_SPOOLS = 'spools';
const LS_ACTIVE = 'activeSpoolId';

//Regex
const NOISY_REGEX = /^(?:echo:busy:\s*processing|\/\/action:.*|setnewscreen(?:\s*\([^)]*\))?:?.*|invoking handler for screen.*)/i;
const POS_REGEX   = /X:?\s*([+-]?\d*\.?\d+)\s+Y:?\s*([+-]?\d*\.?\d+)\s+Z:?\s*([+-]?\d*\.?\d+)/i;

//const TEMP_T = /T\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;
//const TEMP_B = /B\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;

const TEMP_T = /\bT\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;
const TEMP_B = /\bB\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;

const TELEMETRY_REGEX =
  /(?:\bT\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\bB\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\b@:\s*\d+)|(?:\bB@:\s*\d+)/i;

//Ambient-detection tuning
const AMBIENT_WINDOW_SEC   = 300;   // track last 5 minutes
const AMBIENT_MIN_SEC      = 240;   // require at least 4 minutes observed
const AMBIENT_MAX_SPREAD   = 0.8;   // max range (°C) over window (±0.4°C)
const AMBIENT_MAX_SLOPE    = 0.01;  // °C per second (~0.6°C/min) max drift

//Buffers
const _ambientBuf = { hot: [], bed: [] }; // arrays of [tsSec, temp]

//Virtual data
const mockMesh = [
  "Bed Topography Report:",
  "    0      1      2      3",
  "0  +0.025  +0.013  -0.002  -0.020",
  "1  +0.018  +0.005  -0.010  -0.022",
  "2  +0.030  +0.015  +0.003  -0.015",
  "3  +0.035  +0.020  +0.010  -0.012",
  "ok"
];

//Virtual printer state object
const vState = {
  hot: 25, hotTarget: null,
  bed: 25, bedTarget: null,
  x: 0, y: 0, z: 0
};

/* =========================================================
   3) STATE (all let)
========================================================= */






/* =========================================================
   4) TABS BOOTSTRAP (runs once)
========================================================= */
(function initTabs(){
  document.querySelectorAll('#tabButtons button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const target = btn.getAttribute('data-tab');
      sessionStorage.setItem('currentTab', target);
      document.querySelectorAll('.tabContent').forEach(tab => {
        tab.classList.toggle('active', tab.id === target);
      });
    });
  });
  const savedTab = sessionStorage.getItem('currentTab');
  if (savedTab && document.getElementById(savedTab)) {
    document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
    document.querySelector(`#tabButtons button[data-tab="${savedTab}"]`)?.classList.add('active');
    document.querySelectorAll('.tabContent').forEach(tab => {
      tab.classList.toggle('active', tab.id === savedTab);
    });
  }
})();

/* =========================================================
   5) HELPERS (pure UI / formatting / state)
========================================================= */

/* ================= G-code Previewer ================= */
(function(){
  const els = {
    file: document.getElementById('gcodeFile'),
    canvas: document.getElementById('gcodeCanvas'),
    scrub: document.getElementById('layerScrub'),
    info: document.getElementById('layerInfo'),
    travel: document.getElementById('showTravel'),
    zoomFit: document.getElementById('zoomFit'),
    zoom1: document.getElementById('zoom1'),
    resetPan: document.getElementById('resetPan'),
    wrap: document.getElementById('gcodePreview')
  };
  const ctx = els.canvas.getContext('2d', { alpha: false });

  // ----- Model -----
  let layers = [];            // [{z, lines:[{x1,y1,x2,y2, extruding, lineNo}]}]
  let zList = [];             // sorted z values
  let bbox = {minX:0, minY:0, maxX:1, maxY:1};
  let scale = 1, offsetX = 0, offsetY = 0; // world->screen
  let pan = {x:0, y:0}, zoom = 1;

  // ----- Utilities -----
  const EPS_Z = 0.0009;
  function nearlyEqual(a,b,eps){ return Math.abs(a-b) <= eps; }
  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  // Color tokens from CSS
  function token(name, fallback){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback;
  }

  // ----- Parser -----
  function parseGCode(text){
    layers = []; zList = [];
    bbox = {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity};

    let x=0, y=0, z=0, e=0, f=0;
    let absPos = true;   // G90/G91
    let absE = true;     // M82/M83
    let lastE = 0;

    let currentLayer = null;
    let layerByIndex = {}; // capture ;LAYER: comments

    const lines = text.split(/\r?\n/);
    for (let i=0; i<lines.length; i++){
      let raw = lines[i];
      // strip comments (; ... or ( ... ) ) basic
      let line = raw.replace(/\(.*?\)/g,'').split(';')[0].trim();
      if (!line) {
        // Capture Cura-like layer markers for better accuracy
        const layerMatch = raw.match(/;\s*LAYER\s*:\s*(\d+)/i) || raw.match(/;\s*layer\s*(\d+)/i);
        if (layerMatch) layerByIndex[Number(layerMatch[1])] = z;
        continue;
      }

      const cmd = line.split(/\s+/)[0].toUpperCase();

      if (cmd === 'G90') { absPos = true; continue; }
      if (cmd === 'G91') { absPos = false; continue; }
      if (cmd === 'M82') { absE = true;  continue; }
      if (cmd === 'M83') { absE = false; continue; }

      if (cmd === 'G92') {
        // Set position: parse axes present
        const p = parseParams(line);
        if (p.X!=null) x = p.X;
        if (p.Y!=null) y = p.Y;
        if (p.Z!=null) z = p.Z;
        if (p.E!=null) { e = p.E; lastE = e; }
        continue;
      }

      if (cmd === 'G0' || cmd === 'G1') {
        const p = parseParams(line);
        let nx = (p.X!=null) ? (absPos ? p.X : x + p.X) : x;
        let ny = (p.Y!=null) ? (absPos ? p.Y : y + p.Y) : y;
        let nz = (p.Z!=null) ? (absPos ? p.Z : z + p.Z) : z;
        let ne = (p.E!=null) ? (absE ? p.E : e + p.E) : e;
        if (p.F!=null) f = p.F;

        // new layer if Z changed noticeably
        if (!currentLayer || !nearlyEqual(nz, currentLayer.z, EPS_Z)) {
          currentLayer = getOrCreateLayer(nz);
        }

        const extruding = (ne > lastE + 1e-9);
        if ((nx!==x || ny!==y || nz!==z) && (extruding || p.X!=null || p.Y!=null)) {
          // store only XY segments (2D top view). Ignore pure Z hops.
          if (!nearlyEqual(nz, currentLayer.z, EPS_Z)) {
            currentLayer = getOrCreateLayer(nz);
          }
          if (nx!==x || ny!==y) {
            currentLayer.lines.push({ x1:x, y1:y, x2:nx, y2:ny, extruding, lineNo: i+1 });
            // expand bbox
            bbox.minX = Math.min(bbox.minX, x, nx);
            bbox.minY = Math.min(bbox.minY, y, ny);
            bbox.maxX = Math.max(bbox.maxX, x, nx);
            bbox.maxY = Math.max(bbox.maxY, y, ny);
          }
        }
        x = nx; y = ny; z = nz; lastE = e = ne;
        continue;
      }

      // ignore other codes for 2D preview
    }

    // sort layers by z
    layers.sort((a,b)=>a.z-b.z);
    zList = layers.map(l=>l.z);

    // If any ;LAYER markers existed, we could remap (optional, kept simple here)

    // guard bbox
    if (!isFinite(bbox.minX)) bbox = {minX:0, minY:0, maxX:1, maxY:1};
    return { layers, bbox };
  }

  function parseParams(line){
    const p = {};
    line.replace(/[A-Za-z][-+]?\d*\.?\d+(e[-+]?\d+)?/gi, tok=>{
      const letter = tok[0].toUpperCase();
      const num = parseFloat(tok.slice(1));
      p[letter] = num;
    });
    return p;
  }

  function getOrCreateLayer(z){
    // merge z into existing within EPS_Z
    for (const L of layers) if (nearlyEqual(L.z, z, EPS_Z)) return L;
    const L = { z, lines: [] };
    layers.push(L);
    return L;
  }

  // ----- View / Transform -----
  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = els.canvas.getBoundingClientRect();
    els.canvas.width = Math.floor(r.width * dpr);
    els.canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    fitView();
  }

  function fitView(){
    const pad = 10;
    const w = els.canvas.clientWidth - pad*2;
    const h = els.canvas.clientHeight - pad*2;
    const bw = Math.max(1e-6, bbox.maxX - bbox.minX);
    const bh = Math.max(1e-6, bbox.maxY - bbox.minY);
    const sx = w / bw;
    const sy = h / bh;
    scale = Math.min(sx, sy);
    offsetX = -bbox.minX + (w/scale - bw)/2;
    offsetY = -bbox.minY + (h/scale - bh)/2;
    zoom = 1; pan = {x:0, y:0};
    render();
  }

  function worldToScreen(x,y){
    // Flip Y so +Y is up visually (optional). Here we keep slicer coords (origin lower-left).
    const sx = (x + offsetX + pan.x) * scale * zoom + 10;
    const sy = (y + offsetY + pan.y) * scale * zoom + 10;
    return [sx, els.canvas.clientHeight - sy]; // invert for canvas pixels
  }

  // ----- Render -----
  let currentLayerIdx = 0;
  function render(){
    const bg = token('--panel','#fff');
    const grid = token('--border','#ccd');
    const text = token('--text','#111');
    const prevCol = `rgba(128,128,128,0.35)`;
    const currCol = token('--accent','#4f46e5');
    const travelCol = `rgba(120,120,120,0.55)`;

    ctx.clearRect(0,0,els.canvas.clientWidth,els.canvas.clientHeight);

    // Very light grid
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = grid;
    ctx.lineWidth = 1;
    // simple frame
    ctx.strokeRect(0.5,0.5,els.canvas.clientWidth-1,els.canvas.clientHeight-1);
    ctx.restore();

    if (!layers.length) return;

    // Draw previous layers faint
    for (let i=0; i<currentLayerIdx; i++){
      drawLayer(layers[i], prevCol, travelCol, els.travel.checked, 1);
    }
    // Draw current layer full
    drawLayer(layers[currentLayerIdx], currCol, travelCol, els.travel.checked, 2);
    // HUD text
    ctx.fillStyle = text;
    ctx.font = '12px system-ui, sans-serif';
    const z = layers[currentLayerIdx]?.z ?? 0;
    ctx.fillText(`Layer ${currentLayerIdx+1}/${layers.length}  •  Z=${z.toFixed(3)} mm`, 12, 18);
  }

  function drawLayer(L, extrudeColor, travelColor, showTravel, widthBase){
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    for (const seg of L.lines){
      const [x1,y1] = worldToScreen(seg.x1, seg.y1);
      const [x2,y2] = worldToScreen(seg.x2, seg.y2);
      const isTravel = !seg.extruding;
      if (isTravel && !showTravel) continue;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      if (isTravel){
        ctx.strokeStyle = travelColor;
        ctx.setLineDash([6,6]);
        ctx.lineWidth = widthBase;
      } else {
        ctx.strokeStyle = extrudeColor;
        ctx.setLineDash([]);
        ctx.lineWidth = widthBase + 0.5;
      }
      ctx.stroke();
    }
  }

  // ----- Scrubber / Controls -----
  function syncScrubber(){
    els.scrub.max = Math.max(0, layers.length-1);
    currentLayerIdx = clamp(currentLayerIdx, 0, layers.length-1);
    els.scrub.value = currentLayerIdx;
    const z = layers[currentLayerIdx]?.z ?? 0;
    els.info.textContent = layers.length
      ? `#${currentLayerIdx+1}/${layers.length} (Z=${z.toFixed(3)}mm)`
      : '—';
  }

  els.scrub.addEventListener('input', () => {
    currentLayerIdx = Number(els.scrub.value|0);
    syncScrubber(); render();
  });

  els.travel.addEventListener('change', render);
  els.zoomFit.addEventListener('click', fitView);
  els.zoom1.addEventListener('click', ()=>{ zoom = 1; render(); });
  els.resetPan.addEventListener('click', ()=>{ pan = {x:0,y:0}; render(); });

  // Pan & Zoom (mouse)
  let panning = false, last = {x:0,y:0};
  els.canvas.addEventListener('pointerdown', e=>{
    panning = true; last = {x:e.clientX, y:e.clientY}; els.canvas.setPointerCapture(e.pointerId);
  });
  els.canvas.addEventListener('pointermove', e=>{
    if (!panning) return;
    const dx = (e.clientX - last.x) / (scale * zoom);
    const dy = (e.clientY - last.y) / (scale * zoom);
    pan.x += dx;
    pan.y -= dy; // invert due to screen Y invert
    last = {x:e.clientX, y:e.clientY};
    render();
  });
  window.addEventListener('pointerup', ()=>{ panning = false; });
  els.canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const factor = Math.exp((e.deltaY>0?-1:1)*0.08);
    zoom = clamp(zoom*factor, 0.1, 20);
    render();
  }, { passive:false });

  // ----- Loading -----
  els.file.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0];
    if (!file) return;
    const text = await file.text();
    loadFromText(text);
  });

  function loadFromText(text){
    parseGCode(text);
    resizeCanvas(); // sets fitView via render
    currentLayerIdx = 0;
    syncScrubber(); render();
  }

  // Resize handling
  const ro = new ResizeObserver(()=>resizeCanvas());
  ro.observe(els.canvas);

  // ----- Live highlight API -----
  function updateCurrentZ(z){
    if (!layers.length) return;
    // find nearest layer by Z
    let idx = 0, best = Infinity;
    for (let i=0;i<layers.length;i++){
      const d = Math.abs(layers[i].z - z);
      if (d < best) { best = d; idx = i; }
    }
    if (idx !== currentLayerIdx){
      currentLayerIdx = idx;
      syncScrubber(); render();
    }
  }

  function updateByGcodeLine(lineNo){
    if (!layers.length) return;
    // find the highest layer that has any segment with lineNo <= given
    let idx = currentLayerIdx;
    for (let i=0;i<layers.length;i++){
      const has = layers[i].lines.some(s => s.lineNo <= lineNo && s.extruding);
      if (has) idx = i;
    }
    if (idx !== currentLayerIdx){
      currentLayerIdx = idx;
      syncScrubber(); render();
    }
  }

  // Expose a small API for your sender
  window.GCodePreview = {
    loadFromText,
    updateCurrentZ,
    updateByGcodeLine,
    fitView,
    setLayer: (i)=>{ currentLayerIdx = clamp(i,0,layers.length-1); syncScrubber(); render(); },
    get meta(){ return { layers: layers.length, zList:[...layers.map(l=>l.z)], bbox }; }
  };

  // If you already have the file string available elsewhere, you can do:
  // GCodePreview.loadFromText(gcodeString);

})();

function genSpoolId() {
  const t = Date.now().toString(36).slice(-5);
  const r = Math.floor(Math.random() * 0xffff).toString(36).padStart(3, '0');
  return `S-${t}${r}`.toUpperCase();
}

function saveSpools() {
  localStorage.setItem(LS_SPOOLS, JSON.stringify(spools));
}


function loadSpools() {
  try {
    spools = JSON.parse(localStorage.getItem(LS_SPOOLS) || '[]');
  } catch {
    spools = [];
  }
}

function saveActive(id) {
  activeSpoolId = id || null;
  localStorage.setItem(LS_ACTIVE, activeSpoolId || '');
}

function materialDensityGuess(mat) {
  const k = String(mat || '').trim().toUpperCase();
  // Common aliases
  if (k === 'PA' || k.startsWith('PA')) return DEFAULT_DENSITY.NYLON; // PA/PA12/PA6
  return DEFAULT_DENSITY[k] ?? null;
}


function findSpool(id) {
  return spools.find(s => s.id === id) || null;
}

function formatG(x) {
  return Number.isFinite(x) ? Math.round(x) : '—';
}

function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function fillDensityByMaterial() {
  if (!window.spMaterial || !window.spDensity) return;
  const d = materialDensityGuess(spMaterial.value);
  if (d != null) {
    spDensity.value = d.toFixed(2);
    spDensity.dataset.auto = '1';
  } else {
    spDensity.value = '';
    delete spDensity.dataset.auto;
  }
}

// On init (where you wire your form):
spMaterial.addEventListener('change', fillDensityByMaterial);

// After you populate the form (writeForm/clearForm), call this so the field matches:
fillDensityByMaterial();

function qrUrlForSpool(s) {
  const payload = encodeURIComponent(JSON.stringify({
    id: s.id,
    brand: s.brand,
    mat: s.material,
    dia: s.diameter,
    dens: s.density,
    color: s.colorHex,
    cap: s.capacityG,
    rem: s.remainingG
  }));
  return `https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=${payload}`;
}

function openPrintLabel(s) {
  const w = window.open('', '_blank', 'width=360,height=520');
  if (!w) return;

  const html = `
    <html><head><title>Spool ${s.id}</title></head>
    <body style="font-family:sans-serif;padding:12px">
      <h3 style="margin:0 0 8px">Spool Label</h3>
      <div><strong>ID:</strong> ${s.id}</div>
      <div><strong>Brand:</strong> ${s.brand || '—'}</div>
      <div><strong>Material:</strong> ${s.material} — Ø ${s.diameter} mm</div>
      <div><strong>Color:</strong> ${s.colorName || ''} 
        <span style="display:inline-block;width:12px;height:12px;background:${s.colorHex};
          border:1px solid #999;vertical-align:middle"></span>
      </div>
      <div><strong>Remaining:</strong> ${formatG(s.remainingG)} g / ${formatG(s.capacityG)} g</div>
      <img src="${qrUrlForSpool(s)}" alt="QR" style="margin-top:10px"/>
      <script>setTimeout(()=>window.print(), 200);<\/script>

    </body></html>`;

  w.document.write(html);
  w.document.close();
}

function loadActive() {
  try {
    const v = localStorage.getItem(LS_ACTIVE);
    activeSpoolId = v && v !== '' ? v : null;
    if (activeSpoolId && !findSpool(activeSpoolId)) {
      activeSpoolId = null;
      localStorage.setItem(LS_ACTIVE, ''); // clear ghost
    }
  } catch {
    activeSpoolId = null;
  }
}
function estimateGramsFromGcodeText(text, diameterMM, densityGperCM3) {
  const dia  = Math.max(0.5, parseFloat(diameterMM) || 1.75);
  const dens = Math.max(0.1, parseFloat(densityGperCM3) || 1.20);
  const A    = Math.PI * Math.pow(dia / 2, 2); // mm^2

  let absoluteE = true; // default: M82 unless G-code says otherwise
  let lastE = 0;
  let usedMM = 0;

  const lines = text.split(/\r?\n/);
  for (let raw of lines) {
    let line = raw.replace(/;.*$/, '').trim();
    if (!line) continue;

    if (/^M82\b/i.test(line)) { absoluteE = true;  continue; }
    if (/^M83\b/i.test(line)) { absoluteE = false; continue; }

    const g92 = line.match(/^G92\s+.*?E\s*([-+]?\d*\.?\d+)/i);
    if (g92) { lastE = parseFloat(g92[1]) || 0; continue; }

    if (/^G0?1\b/i.test(line)) {
      const m = line.match(/\bE\s*([-+]?\d*\.?\d+)/i);
      if (!m) continue;
      const eNow = parseFloat(m[1]);
      if (!Number.isFinite(eNow)) continue;

      let dE;
      if (absoluteE) {
        dE = eNow - lastE;
        lastE = eNow;
      } else {
        dE = eNow;
      }
      if (dE > 0) usedMM += dE; // ignore retractions
    }
  }
  const volMM3 = usedMM * A;      // mm^3
  const volCM3 = volMM3 / 1000.0; // cm^3
  return volCM3 * dens;           // grams
}

function clearForm(newId = true) {
  editingId = null;
  spIdShow.textContent = newId ? genSpoolId() : '—';
  spBrand.value = '';
  spMaterial.value = '';
  spDiameter.value = '1.75';
  spDensity.value = '1.24';
  spColorName.value = '';
  spColorHex.value = '#000000';
  spFinish.value = '';
  spTare.value = '250';
  spCapacity.value = '1000';
  spCostTotal.value = '';
  spCostPerKg.value = '';
  spLot.value = '';
  spDate.value = ''; // or set to today if you prefer: new Date().toISOString().slice(0,10)
  spVendor.value = '';

  // keep dependent fields fresh
  fillDensityByMaterial?.();
  autofillLot(true);      // <= generate a fresh lot every new spool
}

function fillForm(s) {
  editingId = s.id;
  spIdShow.textContent = s.id;
  spBrand.value     = s.brand || '';
  spMaterial.value  = s.material || '';
  spDiameter.value  = String(s.diameter || '1.75');
  spDensity.value   = String(s.density ?? 1.24);
  spColorName.value = s.colorName || '';
  spColorHex.value  = s.colorHex || '#000000';
  spFinish.value    = s.finish || '';
  spTare.value      = String(s.tareG ?? 0);
  spCapacity.value  = String(s.capacityG ?? 0);
  spCostTotal.value = s.costTotal ?? '';
  spCostPerKg.value = s.costPerKg ?? '';
  spLot.value       = s.lot || '';
  spDate.value      = s.purchaseDate || '';
  spVendor.value    = s.vendorUrl || '';

  // respect saved density/lot; otherwise auto-fill
  if (!s.density) fillDensityByMaterial?.();
  if (!s.lot) { autofillLot(true); } else { delete spLot.dataset.auto; }
}

function upsertFromForm(e) {
  if (e) e.preventDefault();
  const id = editingId || spIdShow.textContent || genSpoolId();

  const diameter = parseFloat(spDiameter.value);
  const density  = parseFloat(spDensity.value);
  const tare     = Math.max(0, parseFloat(spTare.value) || 0);
  const capacity = Math.max(0, parseFloat(spCapacity.value) || 0);

  if (!(diameter > 0)) return alert('Diameter must be > 0.');
  if (!(density  > 0)) return alert('Density must be > 0.');
  if (!(capacity >= 0)) return alert('Capacity must be ≥ 0.');

  // cost sanity
  let costTotal = spCostTotal.value ? parseFloat(spCostTotal.value) : null;
  let costPerKg = spCostPerKg.value ? parseFloat(spCostPerKg.value) : null;
  if (costTotal == null && costPerKg != null && capacity > 0) {
    costTotal = costPerKg * (capacity / 1000);
  } else if (costPerKg == null && costTotal != null && capacity > 0) {
    costPerKg = costTotal / (capacity / 1000);
  }

  const existing = findSpool(id);
  const base = {
    id,
    brand: spBrand.value.trim(),
    material: spMaterial.value.trim() || 'PLA',
    diameter,
    density,
    colorName: spColorName.value.trim(),
    colorHex: spColorHex.value || '#000000',
    finish: spFinish.value.trim(),
    tareG: tare,
    capacityG: capacity,
    costTotal:  (costTotal  != null) ? +costTotal.toFixed(2)  : null,
    costPerKg:  (costPerKg  != null) ? +costPerKg.toFixed(2)  : null,
    lot: spLot.value.trim(),
    purchaseDate: spDate.value || '',
    vendorUrl: spVendor.value.trim()
  };

  if (existing) {
    Object.assign(existing, base);
    existing.remainingG = clamp(existing.remainingG ?? capacity, 0, capacity);
    existing.updatedAt  = Date.now();
  } else {
    spools.push({
      ...base,
      remainingG: capacity,
      createdAt:  Date.now(),
      updatedAt:  Date.now(),
      lastUsedAt: null
    });
  }
  saveSpools();
  renderSpoolList();
  renderActiveSel();
  clearForm(true);
  setActivity('Spool saved', 'ok');
}

function clearGhostActive() {
  try {
    const v = localStorage.getItem(LS_ACTIVE); // 'activeSpoolId'
    const isGhost = v && !spools.some(s => s.id === v);
    if (isGhost) {
      localStorage.setItem(LS_ACTIVE, '');  // clear saved ghost
      activeSpoolId = null;                 // clear in memory
    }
  } catch {
    activeSpoolId = null;
  }
}

function renderActiveSel() {
  if (activeSpoolId && !findSpool(activeSpoolId)) {
    saveActive(''); // clear ghost before building
  }
  const idKeep = activeSpoolId;
  spActiveSel.innerHTML =
    '<option value="">— none —</option>' +
    spools.map(s => `<option value="${s.id}" ${s.id === idKeep ? 'selected' : ''}>
        ${s.id} · ${s.brand || ''} ${s.material} ${s.colorName || ''}
      </option>`).join('');
}

function renderSpoolList() {
  const q      = spSearch.value.trim().toLowerCase();
  const mat    = spMatFilter.value.trim();
  const onlyRem= spOnlyRemaining.checked;

  let rows = spools.slice();
  if (q) {
    rows = rows.filter(s => (s.id + s.brand + s.colorName).toLowerCase().includes(q));
  }
  if (mat) rows = rows.filter(s => s.material === mat);
  if (onlyRem) rows = rows.filter(s => (s.remainingG || 0) > 0);

  const sort = spSort.value;
  rows.sort((a, b) => {
    if (sort === 'remainingDesc') return (b.remainingG || 0) - (a.remainingG || 0);
    if (sort === 'brandAsc')     return (a.brand || '').localeCompare(b.brand || '');
    if (sort === 'materialAsc')  return (a.material || '').localeCompare(b.material || '');
    if (sort === 'createdDesc')  return (b.createdAt || 0) - (a.createdAt || 0);
    return 0;
  });

  spTable.innerHTML = rows.map(s => `
    <tr>
      <td>${s.id}</td>
      <td>${s.brand || '—'}</td>
      <td>${s.material}</td>
      <td>
        <span style="display:inline-block;width:10px;height:10px;background:${s.colorHex};border:1px solid #999;vertical-align:middle"></span>
        ${s.colorName || ''}
      </td>
      <td>${s.diameter}</td>
      <td>${formatG(s.remainingG)}</td>
      <td>${formatG(s.capacityG)}</td>
      <td>
        <button data-act="edit" data-id="${s.id}">Edit</button>
        <button data-act="setActive" data-id="${s.id}">Set active</button>
        <button data-act="label" data-id="${s.id}">Label</button>
        <button data-act="del" data-id="${s.id}">Delete</button>
      </td>
    </tr>
  `).join('');

  const total   = spools.length;
  const withRem = spools.filter(s => (s.remainingG || 0) > 0).length;
  spSummary.textContent = `${rows.length}/${total} shown · ${withRem} have remaining`;
}


function setActiveSpool(id) {
  saveActive(id || '');
  spActiveSel.value = activeSpoolId || '';
  setActivity(
    activeSpoolId ? `Active spool: ${activeSpoolId}` : 'No active spool',
    activeSpoolId ? 'ok' : ''
  );
}

// --- Lot / Batch auto-generator ---
function _slug3(s) {
  // first 3 letters/numbers of brand, fallback to 'XXX'
  const t = String(s || '').replace(/[^a-z0-9]/gi, '').toUpperCase();
  return (t.slice(0, 3) || 'XXX').padEnd(3, 'X');
}
function _matCode(s) {
  const k = String(s || '').trim().toUpperCase();
  if (k.startsWith('PA')) return 'NYL'; // PA, PA6, PA12 -> Nylon
  return (k || 'MAT').slice(0, 3);
}
function _dateYYMMDD(dateStr) {
  const d = dateStr ? new Date(dateStr) : new Date();
  const y = String(d.getFullYear()).slice(-2);
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const dd = String(d.getDate()).padStart(2, '0');
  return `${y}${m}${dd}`;
}
function genLotBatch() {
  const brand = _slug3(spBrand.value);
  const mat   = _matCode(spMaterial.value);
  const ymd   = _dateYYMMDD(spDate.value);
  const seq   = Math.random().toString(36).slice(2, 5).toUpperCase();
  return `${brand}-${mat}${ymd}-${seq}`;
}
/**
 * Fill lot only if:
 *  - force = true, or
 *  - field is empty, or
 *  - it was previously auto-filled (tracked via data-auto="1")
 */
function autofillLot(force = false) {
  if (!spLot) return;
  if (force || !spLot.value || spLot.dataset.auto === '1') {
    spLot.value = genLotBatch();
    spLot.dataset.auto = '1';
  }
}

// Keep lot in sync while user is building a new spool
spBrand?.addEventListener('input',  () => autofillLot(false));
spMaterial?.addEventListener('change', () => autofillLot(false));
spDate?.addEventListener('change', () => autofillLot(false));

// Optional: a quick way to "lock" custom lot once user types anything
spLot?.addEventListener('input', () => { delete spLot.dataset.auto; });

function ensureMeshTable() {
  if (!meshInput) return;
  if (meshInput.children.length) return; // already built

  const rows = 4, cols = 4;
  meshInput.innerHTML = '';
  for (let r = 0; r < rows; r++) {
    const tr = document.createElement('tr');
    for (let c = 0; c < cols; c++) {
      const td = document.createElement('td');
      const inp = document.createElement('input');
      inp.type = 'number';
      inp.step = '0.001';
      inp.style.width = '90px';
      inp.id = `m_${r}_${c}`;
      td.appendChild(inp);
      tr.appendChild(td);
    }
    meshInput.appendChild(tr);
  }
}

document.addEventListener('DOMContentLoaded', ensureMeshTable);

function deleteSpool(id) {
  const s = findSpool(id);
  if (!s) return;
  if (!safeConfirm(`Delete spool ${id}?`)) return;
  spools = spools.filter(x => x.id !== id);
  if (activeSpoolId === id) saveActive('');
  saveSpools();
  renderSpoolList();
  renderActiveSel();
}

function adjustRemaining(id, deltaG) {
  const s = findSpool(id);
  if (!s) return;
  const cap = s.capacityG || 0;
  s.remainingG = clamp((s.remainingG || 0) + deltaG, 0, cap);
  s.updatedAt  = Date.now();
  saveSpools();
  renderSpoolList();
  renderActiveSel();
}

// =============== FILAMENT: event wiring ===============
spMaterial?.addEventListener('change', fillDensityByMaterial);
spReset?.addEventListener('click', () => clearForm(true));
spoolForm?.addEventListener('submit', upsertFromForm);

spTable?.addEventListener('click', (e) => {
  const btn = e.target.closest('button');
  if (!btn) return;
  const id  = btn.getAttribute('data-id');
  const s   = findSpool(id);
  const act = btn.getAttribute('data-act');

  if (act === 'edit'      && s) fillForm(s);
  if (act === 'setActive' && s) setActiveSpool(id);
  if (act === 'label'     && s) openPrintLabel(s);
  if (act === 'del')           deleteSpool(id);
});

[spSearch, spMatFilter, spOnlyRemaining, spSort]
  .forEach(el => el?.addEventListener('input', renderSpoolList));

spActiveSel?.addEventListener('change', () => setActiveSpool(spActiveSel.value || ''));

spPrintLbl?.addEventListener('click', () => {
  const s = findSpool(activeSpoolId || '');
  if (!s) return alert('Select an active spool first.');
  openPrintLabel(s);
});

spWeigh?.addEventListener('click', () => {
  const s = findSpool(activeSpoolId || '');
  if (!s) return alert('Select an active spool first.');
  const gross = parseFloat(safePrompt('Current gross weight (g) — spool+filament on scale:', '850') || '');
  if (!Number.isFinite(gross) || gross <= 0) return;
  const net = gross - (s.tareG || 0);
  if (net < 0) return alert('Gross must be ≥ tare weight.');
  s.remainingG = clamp(Math.round(net), 0, s.capacityG || 0);
  s.updatedAt  = Date.now();
  saveSpools();
  renderSpoolList();
  renderActiveSel();
});

spDeduct5?.addEventListener('click', () => {
  const s = findSpool(activeSpoolId || '');
  if (!s) return alert('Select an active spool first.');

  const def = localStorage.getItem('spDeductDefault') || '5';
  const input = safePrompt('Deduct amount (grams):', def);
  const amt = parseFloat(input || '');
  if (!Number.isFinite(amt) || amt <= 0) return;

  localStorage.setItem('spDeductDefault', String(amt));
  adjustRemaining(s.id, -Math.abs(amt)); // deduct
});

spMarkEmpty?.addEventListener('click', () => {
  const s = findSpool(activeSpoolId || '');
  if (!s) return alert('Select an active spool first.');
  s.remainingG = 0;
  s.updatedAt  = Date.now();
  saveSpools();
  renderSpoolList();
});

// =============== FILAMENT: init ===============
(function filamentInit() {
  try {
    loadSpools();
    loadActive?.();          // if you have it
    clearGhostActive();      // <= add this line
    renderSpoolList();
    renderActiveSel();
    clearForm(true);
  } catch (e) {
    console.error('filamentInit failed:', e);
  }
})();

function updatePricePerKg() {
  const totalPrice = parseFloat(spCostTotal.value) || 0;
  const capacityGrams = parseFloat(spCapacity.value) || 0;
  if (capacityGrams > 0) {
    const perKg = totalPrice / (capacityGrams / 1000);
    spCostPerKg.value = perKg.toFixed(2);
  } else {
    spCostPerKg.value = '';
  }
}

spCostTotal.addEventListener('input', updatePricePerKg);
spCapacity.addEventListener('input', updatePricePerKg);











function getHomeSig() {
  try { return JSON.parse(localStorage.getItem('homeSig')) || HOME_SIG_DEFAULT; }
  catch { return HOME_SIG_DEFAULT; }
}
function setHomeSig(sig) {
  localStorage.setItem('homeSig', JSON.stringify(sig));
}

// Call on every incoming log line to update the “hint” window
function maybeMarkHomingHint(line) {
  if (/\b(Homing|Home\s+all|Taring probe|Preheating)\b/i.test(line)) {
    lastHomeHintAt = performance.now();
  }
}

// Call when you parse a position to decide if we’re homed
function maybeMarkHomedFromPos(x, y, z) {
  const now = performance.now();

  // If we saw a homing-ish line very recently, trust this as homed
  if (now - lastHomeHintAt < 4000) {
    isHomed = true;
    return;
  }

  // Otherwise, compare to a known "home signature" with tolerance
  const sig = getHomeSig();
  const near =
    Math.abs(x - sig.x) <= sig.tolX &&
    Math.abs(y - sig.y) <= sig.tolY &&
    Math.abs(z - sig.z) <= sig.tolZ;

  if (near) isHomed = true;
}

// (optional) learn & persist your printer’s home signature after a known-good G28
function learnHomeSignature(x, y, z) {
  setHomeSig({ x, y, z, tolX: 2.0, tolY: 2.0, tolZ: 4.0 });
}

// === Nozzle Wipe + Prime Line (staged warmup, safe home, purge, cool, exit) ===
async function runPrimeLine() {
  cancelStream = false; // ← clear leftover cancel flag from a previous send
  const HOT_FINAL = 200;
  const BED_FINAL = 60;

  try {
    setActivity('Nozzle prep…', 'warn');

    // Restore mesh & motion defaults
    await sendCmdsSequential(
      'M420 S1',
      'M201 X500.00 Y500.00 Z100.00 E5000.00',
      'M203 X500.00 Y500.00 Z10.00 E50.00',
      'M204 P500.00 R1000.00 T500.00',
      'M205 X8.00 Y8.00 Z0.40 E5.00',
      'M220 S100',
      'M221 S100'
    );

    // Staged warmup to avoid droop before homing (per your script)
    await sendCmd('M190 S50');            await waitForOk(); // bed to 50 (wait)
    await sendCmd('M140 S65');            await waitForOk(); // bed target 65 (no wait)
    await sendCmd('M104 S120');           await waitForOk(); // nozzle 120 (no wait)
    await sendCmd('M190 S65');            await waitForOk(); // bed to 65 (wait)
    await sendCmd('M109 S145');           await waitForOk(); // nozzle to 145 (wait)
    await sendCmd('M105');                await waitForOk();

    // Home while warm (Z sensor happy at ~145)
    await sendCmd('G28');                 await waitForOk();

    // Set final print temps (don’t wait yet), park, then wait to temps
    await sendCmd(`M104 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd(`M140 S${BED_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();
    await sendCmdsSequential('G90', 'G0 Z20', 'G0 X0 Y0');
    await sendCmd(`M190 S${BED_FINAL}`);  await waitForOk();
    await sendCmd(`M109 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();

    // Purge / prime lines
    await sendCmdsSequential(
      'G92 E0',
      'M83',
      'G1 Z2.0 F3000',
      'G1 X10.1 Y20 Z0.28 F5000.0',
      'G1 X10.1 Y200.0 Z0.28 F1500.0 E15',
      'G1 X10.4 Y200.0 Z0.28 F5000.0',
      'G1 X10.4 Y20 Z0.28 F1500.0 E30',
      'G92 E0',
      'G1 Z2.0 F3000',
      'M82'
    );

    // Drain queue, Z hop +10, cool down, then close print screen
    await sendCmd('M400');                await waitForOk().catch(()=>{});
    await sendCmd('G91');                 await waitForOk().catch(()=>{});
    await sendCmd('G1 Z10 F600');         await waitForOk().catch(()=>{});
    await sendCmd('G90');                 await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');             await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');             await waitForOk().catch(()=>{});
    exitPrintScreen(0, { tellHost: false }); 

    isHomed = true;
    setActivity('Wipe + prime complete (cooled)', 'ok');
    logMsg('✅ Homed at 65/145; primed at 200/60; Z+10; heaters OFF; closed print screen.');
    updateLastUpdated();
  } catch (e) {
    setActivity('Prep failed', 'bad');
    logMsg('⚠️ Wipe/prime error: ' + (e?.message || e));
  }
}

// === Nozzle Wipe + Prime Line (staged warmup, safe home, purge, cool, exit) ===
async function runPrimeLine() {
  const HOT_FINAL = 200;
  const BED_FINAL = 60;

  try {
    setActivity('Nozzle prep…', 'warn');

    // Restore mesh & motion defaults
    await sendCmdsSequential(
      'M420 S1',
      'M201 X500.00 Y500.00 Z100.00 E5000.00',
      'M203 X500.00 Y500.00 Z10.00 E50.00',
      'M204 P500.00 R1000.00 T500.00',
      'M205 X8.00 Y8.00 Z0.40 E5.00',
      'M220 S100',
      'M221 S100'
    );

    // Staged warmup to avoid droop before homing (per your script)
    await sendCmd('M190 S50');            await waitForOk(); // bed to 50 (wait)
    await sendCmd('M140 S65');            await waitForOk(); // bed target 65 (no wait)
    await sendCmd('M104 S120');           await waitForOk(); // nozzle 120 (no wait)
    await sendCmd('M190 S65');            await waitForOk(); // bed to 65 (wait)
    await sendCmd('M109 S145');           await waitForOk(); // nozzle to 145 (wait)
    await sendCmd('M105');                await waitForOk();

    // Home while warm (Z sensor happy at ~145)
    await sendCmd('G28');                 await waitForOk();

    // Set final print temps (don’t wait yet), park, then wait to temps
    await sendCmd(`M104 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd(`M140 S${BED_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();
    await sendCmdsSequential('G90', 'G0 Z20', 'G0 X0 Y0');
    await sendCmd(`M190 S${BED_FINAL}`);  await waitForOk();
    await sendCmd(`M109 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();

    // Purge / prime lines
    await sendCmdsSequential(
      'G92 E0',
      'M83',
      'G1 Z2.0 F3000',
      'G1 X10.1 Y20 Z0.28 F5000.0',
      'G1 X10.1 Y200.0 Z0.28 F1500.0 E15',
      'G1 X10.4 Y200.0 Z0.28 F5000.0',
      'G1 X10.4 Y20 Z0.28 F1500.0 E30',
      'G92 E0',
      'G1 Z2.0 F3000',
      'M82'
    );

    // Drain queue, Z hop +10, cool down, then close print screen
    await sendCmd('M400');                await waitForOk().catch(()=>{});
    await sendCmd('G91');                 await waitForOk().catch(()=>{});
    await sendCmd('G1 Z10 F600');         await waitForOk().catch(()=>{});
    await sendCmd('G90');                 await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');             await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');             await waitForOk().catch(()=>{});
    exitPrintScreen(0, { tellHost: false }); 

    isHomed = true;
    setActivity('Wipe + prime complete (cooled)', 'ok');
    logMsg('✅ Homed at 65/145; primed at 200/60; Z+10; heaters OFF; closed print screen.');
    updateLastUpdated();
  } catch (e) {
    setActivity('Prep failed', 'bad');
    logMsg('⚠️ Wipe/prime error: ' + (e?.message || e));
  }
}


function _ensureAudioCtx() {
  if (!_audioCtx) {
    try { _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {}
  }
  if (_audioCtx && _audioCtx.state === 'suspended') _audioCtx.resume();
  return _audioCtx;
}

function _tone(freq=880, ms=120, vol=0.22, when=0) {
  const ctx = _ensureAudioCtx(); if (!ctx) return;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;

  const t0 = ctx.currentTime + when;
  gain.gain.setValueAtTime(0.0001, t0);
  gain.gain.linearRampToValueAtTime(vol, t0 + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.0001, t0 + ms/1000);

  osc.connect(gain).connect(ctx.destination);
  osc.start(t0);
  osc.stop(t0 + ms/1000 + 0.02);
}

function beep(kind='start') {
  try {
    if (!BEEP_BROWSER_ON) return;
    if (kind === 'start') { _tone(880,120,0.24,0); _tone(1100,120,0.24,0.15); }
    else if (kind === 'done') { _tone(784,120,0.24,0); _tone(988,120,0.24,0.16); _tone(1319,160,0.26,0.34); }
    else if (kind === 'cancel') { _tone(220,260,0.28,0); }
    else if (kind === 'error') { _tone(200,160,0.28,0); _tone(150,220,0.28,0.22); }
    if (navigator.vibrate) {
      if (kind === 'start') navigator.vibrate([25]);
      else if (kind === 'done') navigator.vibrate([20,40,20]);
      else if (kind === 'cancel' || kind === 'error') navigator.vibrate([60]);
    }
  } catch {}
}

async function printerBeep(kind='start') {
  if (!BEEP_PRINTER_ON) return;
  // only try if connected
  if (!(connKind === 'virtual' || writer)) return;

  // simple patterns (freq S, duration P)
  const seq = (kind === 'start') ? [[880,120],[1100,120]]
            : (kind === 'done')  ? [[784,120],[988,120],[1319,160]]
            : (kind === 'cancel')? [[220,260]]
            :                      [];
  try {
    for (const [s,p] of seq) {
      await sendCmd(`M300 S${Math.round(s)} P${Math.round(p)}`);
      await waitForOk().catch(()=>{});
      await sleep(10);
    }
  } catch {}
}

/* ===== Live Telemetry Chart (temps, fan %, M73 %) ===== */
const live = {
  el: null, ctx: null, buf: [], maxSec: 600, // 10 minutes
  lastFan255: 0, lastProg: null, raf: 0
};

(function initLiveChart(){
  live.el = document.getElementById('liveChart');
  if (!live.el) return;
  live.ctx = live.el.getContext('2d');

  const resize = () => {
    const dpr = window.devicePixelRatio || 1;
    const cssW = live.el.clientWidth || 900;
    const cssH = live.el.clientHeight || 260;
    live.el.width  = Math.round(cssW * dpr);
    live.el.height = Math.round(cssH * dpr);
    live.ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    queueLiveDraw();
  };
  window.addEventListener('resize', resize);
  resize();
})();

function recordLiveSample() {
  if (!live.ctx) return;
  const now = Date.now()/1000;
  live.buf.push({
    ts: now,
    hot: Number.isFinite(temps.hot) ? temps.hot : null,
    bed: Number.isFinite(temps.bed) ? temps.bed : null,
    fanPct: Number.isFinite(live.lastFan255) ? Math.round(live.lastFan255 * 100 / 255) : null,
    progPct: (live.lastProg != null ? live.lastProg : null)
  });
  // drop old
  const cut = now - live.maxSec;
  while (live.buf.length && live.buf[0].ts < cut) live.buf.shift();
  queueLiveDraw();
}

function queueLiveDraw(){
  if (live.raf) return;
  live.raf = requestAnimationFrame(() => { live.raf = 0; drawLive(); });
}

function drawLive(){
  const el = live.el, ctx = live.ctx;
  if (!ctx) return;
  const W = el.clientWidth || 900, H = el.clientHeight || 260;
  ctx.clearRect(0,0,W,H);

  // Axes and layout
  const padL = 40, padR = 40, padT = 10, padB = 20;
  const plotW = W - padL - padR, plotH = H - padT - padB;

  // Time window
  const now = Date.now()/1000;
  const t0 = now - live.maxSec, t1 = now;

  // Scales
  const tempMin = 0, tempMax = 270;   // °C
  const pctMin  = 0, pctMax  = 100;   // %
  const xOf = ts => padL + ((ts - t0) / (t1 - t0)) * plotW;
  const yTemp = v => padT + (1 - (v - tempMin) / (tempMax - tempMin)) * plotH;
  const yPct  = v => padT + (1 - (v - pctMin)  / (pctMax  - pctMin )) * plotH;

  // Grid
  ctx.globalAlpha = 0.15;
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i=0;i<=5;i++){
    const y = padT + (i/5)*plotH;
    ctx.moveTo(padL, y); ctx.lineTo(W - padR, y);
  }
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Labels
  ctx.fillStyle = '#333';
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.textAlign = 'left';  ctx.fillText('°C', 4, padT+12);
  ctx.textAlign = 'right'; ctx.fillText('%', W-4, padT+12);

  // Helper to draw a series
  const drawSeries = (key, yFn, color, dash=[]) => {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.setLineDash(dash);
    ctx.lineWidth = 2;
    let started = false;
    ctx.beginPath();
    for (const s of live.buf) {
      const v = s[key];
      if (v == null || !isFinite(v)) continue;
      const x = xOf(s.ts), y = yFn(v);
      if (!started) { ctx.moveTo(x,y); started = true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  };

  // Series
  drawSeries('hot',    yTemp, '#e74c3c');        // Hotend (red)
  drawSeries('bed',    yTemp, '#3498db', [6,4]); // Bed (blue, dashed)
  drawSeries('fanPct', yPct,  '#7f8c8d');        // Fan % (gray)
  drawSeries('progPct',yPct,  '#2ecc71');        // M73 % (green)

  // Frame
  ctx.strokeStyle = '#ccc';
  ctx.strokeRect(padL, padT, plotW, plotH);
}

function openPreflight(file) {
  _preflightFile = file;

  // dynamic bits
  document.getElementById('preFileName').textContent = file?.name || '(unnamed)';
  document.getElementById('preGuardrail').textContent = heaterUnlocked ? 'OFF' : 'ON';
  const ht = (temps.hot ?? NaN), bt = (temps.bed ?? NaN);
  const hT = (temps.hotTarget ?? NaN), bT = (temps.bedTarget ?? NaN);
  const fmt = (v) => Number.isFinite(v) ? (''+ (v % 1 ? v.toFixed(1) : Math.round(v))) : '—';
  document.getElementById('preTemps').textContent = `${fmt(ht)} / ${fmt(hT)} · ${fmt(bt)} / ${fmt(bT)}`;
  document.getElementById('preMode').textContent = (connKind === 'virtual') ? 'Virtual' : 'Serial';
  document.getElementById('preHomed').textContent = isHomed ? 'Yes' : 'No';

  // reset checks & button
  document.querySelectorAll('.preChk').forEach(c => c.checked = false);
  document.getElementById('preStart').disabled = true;
  document.getElementById('preSkip').checked = false;

  // wire buttons
document.getElementById('preStart').onclick = async () => {
  if (document.getElementById('preSkip').checked) sessionStorage.setItem('skipPreflight','1');
  const f = _preflightFile;     // capture first
  closePreflight();             // then close (which clears _preflightFile)
  if (f) await streamGcode(f);  // safe
};
  document.getElementById('preCancel').onclick = closePreflight;
  document.getElementById('preClose').onclick  = closePreflight;

  document.getElementById('preHome').onclick = async () => {
    try {
      await sendCmd('G28'); await waitForOk().catch(()=>{});
      isHomed = true;
      document.getElementById('preHomed').textContent = 'Yes';
    } catch {}
  };
  document.getElementById('prePark').onclick = async () => {
    try { await sendCmdsSequential('G90', 'G1 X0 Y0 Z10 F3000'); } catch {}
  };

  // show
  document.getElementById('preOverlay').style.display = 'block';
  document.getElementById('preModal').style.display   = 'grid';

  // esc to close
  const esc = (e) => { if (e.key === 'Escape') closePreflight(); };
  document.addEventListener('keydown', esc, { once:true });
}

function closePreflight() {
  document.getElementById('preModal').style.display   = 'none';
  document.getElementById('preOverlay').style.display = 'none';
  _preflightFile = null;
}

function updateUnlockUi() {
  const btn  = document.getElementById('unlockTempsBtn');
  const hint = document.getElementById('unlockHint');
  if (!btn) return;

  // Toggle label + aria state
  btn.textContent = heaterUnlocked ? 'Lock high hotend temps' : 'Unlock high hotend temps';
  btn.setAttribute('aria-pressed', heaterUnlocked ? 'true' : 'false');

  // Helper text
  if (hint) {
    hint.textContent = heaterUnlocked
    ? '⚠️ Guardrail OFF — be careful.'
    : '✅ Guardrail ON — 250°C caps active.';
  }
}

function setHeaterUnlocked(on) {
  heaterUnlocked = !!on;
  localStorage.setItem('heaterUnlocked', JSON.stringify(heaterUnlocked));
  updateUnlockUi();

  const msg = heaterUnlocked
    ? '⚠️ Guardrail OFF — be careful.'
    : '✅ Guardrail ON — 250°C caps active.';
  const text = heaterUnlocked ? 'High hotend temps UNLOCKED' : 'High hotend temps LOCKED';
  const cls  = heaterUnlocked ? 'warn' : '';

  setActivity(text, cls);
  logMsg(msg);
}


function onUnlockToggle(e){
  e.preventDefault();
  setHeaterUnlocked(!heaterUnlocked);
  setActivity(heaterUnlocked ? 'High hotend temps UNLOCKED' : 'High hotend temps LOCKED',
              heaterUnlocked ? 'warn' : '');
  logMsg(heaterUnlocked ? '⚠️ Guardrail OFF — be careful.'
                        : '✅ Guardrail ON — 250°C caps active.');
}

if (unlockTempsBtn) unlockTempsBtn.onclick = onUnlockToggle; // bind once

function guardHeaterFromCmd(cmd) {
  if (heaterUnlocked) return true;
  // Only gate heater-set commands with S values
  if (!/^(?:M10(?:4|9)|M1(?:40|90))\b/i.test(cmd)) return true;
  const s = cmd.match(/\bS\s*([0-9.]+)/i);
  if (!s) return true;

  const val = parseFloat(s[1]);
  const isHot = /^M10(?:4|9)\b/i.test(cmd);
  const lim = isHot ? MAX_HOTEND : MAX_BED;

  if (val > lim) {
    setActivity('Heater limit blocked', 'bad');
    logMsg(`⛔ Blocked: ${cmd} (limit ${lim}°C; click “Unlock hotend high temps” to override)`);
    return false;
  }
  return true;
}

function guardHeaterSet(tool, target, sourceLabel='UI') {
  const limit = tool === 'hotend' ? MAX_HOTEND : MAX_BED;
  if (Number.isFinite(target) && target > limit && !heaterUnlocked) {
    setActivity('Blocked by heater guardrail', 'bad');
    alert(`⛔ Limit ${limit}°C. Requested ${target}°C from ${sourceLabel}. Click “Unlock high hotend temps” to allow this.`);
    return false;
  }
  return true;
}

function startNetMeter() {
  if (net.timer) return;
  net.lastSample = performance.now();
  net.timer = setInterval(sampleNet, 1000);
}

function stopNetMeter() {
  if (net.timer) { clearInterval(net.timer); net.timer = null; }
  net.txRate = 0; net.rxRate = 0;
  updateNetUi();
}

function sampleNet() {
  const now = performance.now();
  const dt = (now - net.lastSample) / 1000;
  if (dt <= 0) return;

  const txInstant = net.txSince / dt;
  const rxInstant = net.rxSince / dt;
  const a = 0.30; // EMA smoothing

  net.txRate = net.txRate ? (a * txInstant + (1 - a) * net.txRate) : txInstant;
  net.rxRate = net.rxRate ? (a * rxInstant + (1 - a) * net.rxRate) : rxInstant;

  net.txSince = 0;
  net.rxSince = 0;
  net.lastSample = now;

  updateNetUi();
}

function fmtRate(v) {
  if (!v) return '—';
  if (v < 1024) return `${Math.round(v)} B/s`;
  if (v < 1024 * 1024) return `${(v / 1024).toFixed(1)} KB/s`;
  return `${(v / 1024 / 1024).toFixed(2)} MB/s`;
}

function updateNetUi() {
  const el = document.getElementById('netPill');
  if (!el) return;
  const lat = (net.latencyEMA != null) ? `${Math.round(net.latencyEMA)} ms` : '—';
  el.textContent = `TX ${fmtRate(net.txRate)} · RX ${fmtRate(net.rxRate)} · Lat ${lat}`;
}

function updateLatency(ms) {
  const a = 0.20; // EMA for OK latency
  net.latencyEMA = (net.latencyEMA == null) ? ms : (a * ms + (1 - a) * net.latencyEMA);
  updateNetUi();
}


// --- Baud selection and robust open/probe helpers ---------------------------
function baudSelection() {
  const sel = document.getElementById('baudSelect');
  const v = sel?.value || 'auto';
  if (v !== 'auto') {
    const fixed = parseInt(v, 10);
    return { mode: 'manual', list: Number.isFinite(fixed) ? [fixed] : [115200] };
  }
  // Try common rates (most likely first)
  return { mode: 'auto', list: [250000, 115200, 230400, 500000, 1000000, 57600] };
}

async function nudgeDTRRTS() {
  // Some boards wake/reset on signal toggles
  try {
    await port.setSignals({ dataTerminalReady: true,  requestToSend: true });
    await sleep(80);
    await port.setSignals({ dataTerminalReady: false, requestToSend: false });
  } catch { /* not supported on every driver */}
}

async function openAtBaud(baud) {
  // Clean any prior state
  try { if (reader) await reader.cancel(); } catch {}
  try { if (reader) reader.releaseLock(); } catch {}
  try { if (writer) writer.releaseLock(); } catch {}
  try { if (port && (port.readable || port.writable)) await port.close(); } catch {}

  await port.open({ baudRate: baud });

  // Pipe as strings when available for better perf
  if (typeof TextDecoderStream !== 'undefined') {
    const tds = new TextDecoderStream();
    textDecoder = tds;
    port.readable.pipeTo(tds.writable).catch(() => {});
    reader = tds.readable.getReader();      // yields strings
  } else {
    textDecoder = new TextDecoder();
    reader = port.readable.getReader();     // yields Uint8Array
  }
  writer = port.writable.getWriter();

  await nudgeDTRRTS(); // wake it up a bit
  return { success: true, baud };
}

// Auto-detect helper: open, poke, and look for tokens; otherwise close & fail.
async function probeAtBaud(baud, timeoutMs = 5000) {
  try {
    await openAtBaud(baud);
  } catch (e) {
    return { success: false, error: e };
  }

  const enc = new TextEncoder();
  const poke = async (s) => { try { await writer.write(enc.encode(s)); } catch {} };

  // Send a few CRLFs then M115; some stacks only react to \r\n
  await poke('\r\n\r\nM115\r\n');

  const deadline = performance.now() + timeoutMs;
  let buf = '';

  try {
    while (performance.now() < deadline) {
      const { value, done } = await reader.read();
      if (done) break;

      // Normalize to string
      const chunk = (value instanceof Uint8Array)
        ? textDecoder.decode(value, { stream: true })
        : (value ?? '');

      buf += chunk;

      // Accept any of these as "alive":
      // - Marlin/RepRap M115 banner
      // - a plain "start"
      // - an "ok"
      // - temps like "T:..." or "B:..."
      if (/FIRMWARE_NAME:|^start\b|^ok\b|T:\s*[-+]?\d|B:\s*[-+]?\d/m.test(buf)) {
        return { success: true, baud };
      }
    }
  } catch { /* ignore transient read errors during probing */ }

  // No luck: tear down cleanly
  try { await reader.cancel(); } catch {}
  try { reader.releaseLock(); } catch {}
  try { writer.releaseLock(); } catch {}
  try { await port.close(); } catch {}

  return { success: false };
}
















//Critical section helpers
function beginCritical() { if (criticalDepth++ === 0) stopTempPolling(); }

function endCritical()   { if (criticalDepth > 0 && --criticalDepth === 0) startTempPolling(); }

//Ambient sampling
function _pushAmbientSample(tool, temp, target) {
  const now = Date.now() / 1000;
  const buf = _ambientBuf[tool];
  // Only track when target is off/zero/unknown
  if (target == null || target <= 0) {
    buf.push([now, temp]);
    while (buf.length && (now - buf[0][0]) > AMBIENT_WINDOW_SEC) buf.shift();
  } else {
    // heating/cooling to a target — clear buffer so we don't mislabel
    buf.length = 0;
  }
}

function _ambientPlateau(tool) {
  const buf = _ambientBuf[tool];
  if (buf.length < 2) return null;
  const span = buf[buf.length - 1][0] - buf[0][0];
  if (span < AMBIENT_MIN_SEC) return null;

  let min = +Infinity, max = -Infinity;
  for (const [, t] of buf) { if (t < min) min = t; if (t > max) max = t; }
  const spread = max - min;

  const first = buf[0], last = buf[buf.length - 1];
  const slope = (last[1] - first[1]) / Math.max(1, (last[0] - first[0])); // °C/s
  if (spread <= AMBIENT_MAX_SPREAD && Math.abs(slope) <= AMBIENT_MAX_SLOPE) {
    // use mean as ambient estimate
    const avg = buf.reduce((a, [,t]) => a + t, 0) / buf.length;
    return { ambient: avg, spread, slope, span };
  }
  return null;
}

//ETA helpers
function isCountingLine(g) {
  const s = g.trim();
  if (!s || s.startsWith(';')) return false;

  // Ignore homing/leveling/heating/waits/setup
  if (/^(?:G28|G29|M104|M109|M140|M190|M82|M83|G90|G91|M84|M400)\b/i.test(s)) return false;

  // Count real motion lines; require X or Y or E (ignore pure Z hops)
  if (/^G0?1\b/i.test(s)) {
    const hasXorY = /[XY]/i.test(s);
    const hasE    = /\bE[-+]?\d/i.test(s);
    const hasOnlyZ= /Z[-+]?\d/i.test(s) && !hasXorY && !hasE;
    return (hasE || hasXorY) && !hasOnlyZ;
  }
  return false;
}

function formatETA(seconds) {
  if (!isFinite(seconds) || seconds <= 0) return '0s';
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  if (m > 59) {
    const h = Math.floor(m / 60);
    const mm = m % 60;
    return `${h}h ${mm}m`;
  }
  return m > 0 ? `${m}m ${s}s` : `${s}s`;
}

function showEtaPill(text, cls = 'warn') {
  if (!etaPill) return;
  etaPill.textContent = text;
  etaPill.className = 'pill ' + cls;
  etaPill.style.display = 'inline-flex';
}

function hideEtaPill() {
  if (!etaPill) return;
  etaPill.style.display = 'none';
}

//PID Prefs
function getPidCycles(tool) {
  const key = `pidCycles:${tool}`;            // tool = 'hotend' | 'bed'
  const saved = parseInt(localStorage.getItem(key) || '', 10);
  return Number.isFinite(saved) && saved >= 1 && saved <= 20 ? saved : 5; // default 5
}

function setPidActive(tool, on = true) {
  if (on && pidTarget && pidTarget !== tool) return; // don't flip mid-run
  if (tool === 'hotend') pidActiveHotend = !!on;
  if (tool === 'bed')    pidActiveBed    = !!on;
  pidTarget = on ? tool : null;
  setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
  setTempPill(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget, 'bed');
}

function clearAllPidUi() {
  pidActiveHotend = false;
  pidActiveBed = false;
  pidTarget = null; // <- ensure the orange pulse stops

  topHotendPill.classList.remove('warn', 'pulse');
  topBedPill.classList.remove('warn', 'pulse');

  setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
  setTempPill(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget, 'bed');
}

function setPidCycles(tool, c) {
  const key = `pidCycles:${tool}`;
  localStorage.setItem(key, String(c));
}

function promptCycles(tool) {
  const def = getPidCycles(tool);
  const raw = safePrompt(`How many PID cycles? (1–20)`, String(def));
  if (raw === null) return null;
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n < 1 || n > 20) {
    alert('Invalid cycle count. Enter a whole number between 1 and 20.');
    return null;
  }
  setPidCycles(tool, n);
  return n;
}

//Temp and UI state
function tempState(current, target, tolerance = 0.5) {
  if (target == null || Number.isNaN(target)) return 'idle';
  const diff = target - current;
  if (Math.abs(diff) <= tolerance) return 'ready';
  return diff > 0 ? 'heating' : 'cooling';
}

function setTempPill(pillEl, textEl, curr, target, type /* 'hotend'|'bed' */) {
  // Text (default)
  textEl.textContent =
    (target != null && !Number.isNaN(target))
      ? `${curr.toFixed(1)}°C / ${Math.round(target)}°`
      : `${curr.toFixed(1)}°C`;

  // Reset base classes
  pillEl.classList.remove('offline','idle','ready','heating','cooling','pulse','warn','ok','bad');

  // If PID is running, keep orange pulse
  if (pidTarget && pidTarget === type) {
    pillEl.classList.add('warn','pulse');
    return;
  }

  // ✅ Ambient plateau override: target off/zero and temp has stabilised for ~5 min
  if (target == null || target <= 0) {
    const tool = (type === 'hotend') ? 'hot' : 'bed';
    const amb = _ambientPlateau(tool);
    if (amb) {
      pillEl.classList.add('ready');            // green
      pillEl.classList.remove('pulse');
      textEl.textContent = `${curr.toFixed(1)}°C (ambient≈${amb.ambient.toFixed(1)}°)`;
      return;                                   // don't fall through to 'cooling'
    }
  }

  // Normal state machine
  const state = tempState(curr, target); // 'idle' | 'ready' | 'heating' | 'cooling'
  pillEl.classList.add(state);
  if ((state === 'heating' || state === 'cooling') && !pidTarget) {
    pillEl.classList.add('pulse');
  }
}

// Now updateTempPanel simply calls setTempPill for each
function updateTempPanel() {
  if (temps.hot != null || temps.hotTarget != null) {
setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
    hotendNow.textContent = `Current: ${temps.hot?.toFixed(1) ?? '—'}°C` +
      (temps.hotTarget != null ? ` / ${Math.round(temps.hotTarget)}°` : '');
  } else {
    hotendNow.textContent = 'Current: —';
  }

  if (temps.bed != null || temps.bedTarget != null) {
    setTempPill(topBedPill, topBedText, temps.bed ?? 0, temps.bedTarget, 'bed');
    bedNow.textContent = `Current: ${temps.bed?.toFixed(1) ?? '—'}°C` +
      (temps.bedTarget != null ? ` / ${Math.round(temps.bedTarget)}°` : '');
  } else {
    bedNow.textContent = 'Current: —';
  }
}

function setOfflinePills() {
  topHotendText.textContent = '--°C';
  topBedText.textContent    = '--°C';
  topHotendPill.className   = 'pill offline';
  topBedPill.className      = 'pill offline';
  hotendNow.textContent     = 'Current: —';
  bedNow.textContent        = 'Current: —';
}


//Axis UI
function updateAxisPanel(x, y, z) {
  posXEl.textContent = x.toFixed(3);
  posYEl.textContent = y.toFixed(3);
  posZEl.textContent = z.toFixed(3);
}


//Logging and Format
function normalizeLine(s){
  s = s.replace(/\x1b\[[0-9;]*m/g, '').replace(/[\u0000-\u001F\u007F]/g, '');
  s = s.replace(/\bcontinueing\b/gi, 'continuing');
  return s;
}

function isNoisyLine(s){ return NOISY_REGEX.test(s); }

function isSetNewScreenLine(s){ return /^setnewscreen\b/i.test(s); }

function trace(msg) { console.debug('[TRACE]', msg); }

function _logBase(msg) {
  if (!msg.endsWith('\n')) msg += '\n';
  printerLog.textContent += msg;
  printerLog.scrollTop = printerLog.scrollHeight;
}

function logMsg(msg, kind = 'info') {
  const el = window.logBox || document.getElementById('logBox');
  if (el) {
    // if it's a <textarea>, use .value; otherwise append textContent
    if ('value' in el) {
      el.value += (el.value ? '\n' : '') + String(msg);
      // keep scrolled to bottom
      el.scrollTop = el.scrollHeight;
    } else {
      el.textContent += (el.textContent ? '\n' : '') + String(msg);
    }
  } else {
    // fallback to console so we still see output
    (kind === 'bad' ? console.error : console.log)(msg);
  }
}

//Header and UI
function setActivity(text, cls='') {
  activityBadge.textContent = text;
  activityBadge.className = 'pill ' + cls;
}

function setConnected(connected) {
    if (connectBtn) connectBtn.disabled = connected;
  if (disconnectBtn) disconnectBtn.disabled = !connected;
  if (connected) {
    connBadge.textContent = 'Connected';
    connBadge.className = 'pill ok';

    topHotendPill.classList.remove('offline');
    topBedPill.classList.remove('offline');
    topHotendPill.classList.add('idle');
    topBedPill.classList.add('idle');
    updateTempPanel();
    // reset live net meter on fresh connect
    net.txBytesTotal = net.rxBytesTotal = 0;
    net.txSince = net.rxSince = 0;
    net.txRate = net.rxRate = 0;
    net.latencyEMA = null;
    updateNetUi();
    startTempPolling();
 startNetMeter();   
    hideEtaPill();
  } else {
    connBadge.textContent = 'Disconnected';
    connBadge.className = 'pill bad';
    stopTempPolling();
 stopNetMeter();   
    setOfflinePills();
    if (live) { live.buf.length = 0; live.lastProg = null; queueLiveDraw(); }
  }

  connectBtn.disabled    = connected;
  disconnectBtn.disabled = !connected;
  readMeshBtn.disabled   = !connected;
  sendCmdBtn.disabled    = !connected;
  bedPidBtn.disabled     = !connected;
  hotendPidBtn.disabled  = !connected;
  clearLogBtn.disabled   = !connected;

  hotendApply.disabled = !connected;
  hotendOff.disabled   = !connected;
  bedApply.disabled    = !connected;
  bedOff.disabled      = !connected;
  fanApply.disabled    = !connected;
  fanOff.disabled      = !connected;

  homeAll.disabled      = !connected;
  disableMotors.disabled= !connected;
  xMinus.disabled = xPlus.disabled =
  yMinus.disabled = yPlus.disabled =
  zMinus.disabled = zPlus.disabled = !connected;
  parkHead.disabled     = !connected;

  preheatPLA.disabled = preheatPETG.disabled =
  preheatABS.disabled = cooldown.disabled =
  loadFil.disabled = unloadFil.disabled = !connected;
primeLine.disabled = !connected;

  sendGcode.disabled   = !connected || !gcodeFile.files.length;
  cancelSend.disabled  = true;
}

function updateLastUpdated(){
  lastUpdated.textContent = 'Last updated: ' + new Date().toLocaleTimeString();
  updateTempPanel();
}

function setLastCmd(cmd){ lastCmd.textContent = 'Last Cmd: ' + cmd; }

//Polling
function startTempPolling(periodMs = 1000) {
  if (tempTimer) return;              // already polling
  tempTimer = setInterval(() => {
    // quiet=true is fine; we just need the inbound line
    try { sendCmd('M105', /*quiet*/ true); } catch (e) { /* ignore */ }
  }, Math.max(250, periodMs));
  // optional UI cue
  if (typeof showTempPill === 'function') showTempPill('Polling temps', 'good');
}

function stopTempPolling(){
  if (tempTimer){ clearInterval(tempTimer); tempTimer = null; }
}

//Printer Name
function loadPrinterName() {
  const saved = localStorage.getItem('printerName');
  printerNameEl.textContent = saved || 'PRINTER';
}

function savePrinterName(name) {
  const cleanName = name.trim() || 'PRINTER';
  printerNameEl.textContent = cleanName;
  localStorage.setItem('printerName', cleanName);
}

function initPrinterName() {
  loadPrinterName();
  printerNameEl.addEventListener('click', () => {
    const currentName = printerNameEl.textContent.trim();
    const newName = safePrompt('Enter your printer name:', currentName);
    if (newName !== null) {
      savePrinterName(newName);
    }
  });
}

//Prompts
function safePrompt(message, def = '') {
  if (typeof window !== 'undefined' && typeof window.prompt === 'function') {
    return window.prompt(message, String(def));
  }
  console.warn('[prompt] not available; using default value.');
  return String(def);
}

function safeConfirm(message) {
  if (typeof window !== 'undefined' && typeof window.confirm === 'function') {
    return window.confirm(message);
  }
  console.warn('[confirm] not available; defaulting to false.');
  return false;
}

//Firmware screen exit
function exitPrintScreen(delayMs = 0, { tellHost = false } = {}) {
  const run = async () => {
    try {
      logMsg('⌛ Tidying up LCD/host state…');
      const cmds = [
        'M400',                   // let moves/ISRs drain
        ...(tellHost ? ['M118 A1 action:cancel'] : []), // host-action for OctoPrint/etc.
        'M524',                   // abort SD print (harmless if none)
        'M117 Ready'              // friendly status on many LCDs
      ];
      await sendCmdsSequential(...cmds);
    } catch (e) {
      // non-fatal
      console.warn('exitPrintScreen failed:', e);
    }
  };

  if (delayMs > 0) setTimeout(() => { run(); }, delayMs);
  else run();
}

//Misc
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function sendCmdsSequential(...cmds) {
  for (const c of cmds) {
    // Skip empty or whitespace-only commands
    if (!c || !c.trim()) continue;

    try {
      await sendCmd(c.trim());       // send the command
      await waitForOk();             // wait for ack from printer
    } catch (err) {
      console.error(`Error sending command "${c}":`, err);
      break; // stop sending further commands if one fails
    }
  }
}


//Easter EGG
  const resetStreak = () => { streak = 0; };

  const openEasterEgg = () => {
    eeBody.textContent = [
      "This was a triumph,",
      "I’m making a note here: “BUILD SUCCESS.”",
      "It’s hard to overstate my satisfaction.",
      "Perfect adhesion,",
      "With just a touch of calibration. 🎵",
      "",
      "But there’s no sense whining when the layer’s too thin,",
      "You just tweak the Z-offset and then try it again.",
      "When the G-code’s complete,",
      "And the model’s elite,",
      "For the projects that are…",
      "Still printing. 🎵",
      "",
      "I’m not even angry,",
      "I’m being so sincere right now,",
      "Even though the extruder jammed and delayed my grand plans",
      "But I tuned the retraction",
      "And got a smooth reaction,",
      "",
      "Now the hours are flying, but I’m still having fun,",
      "Got a ten-hour Benchy and it’s only on run one.",
      "There’s a cat on the bed,",
      "And I’m filled with dread,",
      "For the projects that are…",
      "Still printing. 🎵",
      "",
      "Anyway, this print is great, it’s so dimensionally sweet,",
      "Look at me still sanding when there’s more stuff to complete.",
      "I’ve got spools in a row,",
      "And they’re ready to go,",
      "For the models that are…",
      "Still printing. 🎵"
    ].join('\n');

    eeOverlay.style.display = 'block';
    eeModal.style.display = 'grid';
    eeClose.focus();
  };

  const closeEasterEgg = () => {
    eeModal.style.display = 'none';
    eeOverlay.style.display = 'none';
  };

/* =========================================================
   6) MESH UTILS (parse, store, render)
========================================================= */

//Flow Helpers

function collectMeshFromInputs() {
  const mesh = [];
  for (let y = 0; y < 4; y++) {
    const row = [];
    for (let x = 0; x < 4; x++) {
      const el = document.getElementById(`cell-${y}-${x}`);
      const v = el ? parseFloat(el.value) : NaN;
      row.push(Number.isFinite(v) ? v : null);
    }
    mesh.push(row);
  }
  const complete = mesh.every(r => r.every(v => typeof v === 'number' && !Number.isNaN(v)));
  return complete ? mesh : null;
}

function processMeshLineFromAnywhere(line) {
  const completed = ingestMeshLine(line);
  if (completed) {
    const meshForUi = meshScratch.map(r => r.slice()); // already Y-flipped
    setActivity('Mesh parsed', 'ok');
    saveMeshLS(meshForUi);
    renderMeshInputs(meshForUi);
    renderSuggestions(meshForUi);
    updateLastUpdated();
    resetMeshScratch();
  }
}

async function homeAndProbe() {
  try {
    setActivity('Homing…', 'warn');
    await sendCmd('G28'); await waitForOk();

    // set up latch that will resolve when printer says it's done
    probeLatch = {};
    probeLatch.promise = new Promise((resolve, reject) => {
      probeLatch.resolve = resolve;
      probeLatch.reject  = reject;
    });

    setActivity('Probing…', 'warn');
    await sendCmd('G29 T');            // don't await waitForOk here
    await probeLatch.promise;          // wait for "Settings Stored" / grid header

    await coolToIdle();
    setActivity('Parsing…', 'warn');
  } catch (e) {
    setActivity('Home & probe failed', 'bad');
    logMsg('⚠️ Home & probe error: ' + (e?.message || e));
  }
}

function updateLevelView() {
  const choice = (levelPrinterSelect?.value || 'cr6se');
  const isCR6  = choice === 'cr6se';
  const isConnectedNow = (connKind === 'virtual') || !!writer;

  if (cr6seLevelWrap) cr6seLevelWrap.style.display = isCR6 ? '' : 'none';
  if (unsupportedMsg) unsupportedMsg.style.display = isCR6 ? 'none' : '';

  // Home & Probe button
  if (readMeshBtn) {
    readMeshBtn.style.display = isCR6 ? '' : 'none';
    readMeshBtn.disabled = !isCR6 || !isConnectedNow;
  }

  // Export Mesh button (hide when not CR-6)
  if (exportMeshBtn) {
    exportMeshBtn.style.display = isCR6 ? '' : 'none';
    // optional: only enable if we actually have a mesh to export
    const hasInputs = typeof collectMeshFromInputs === 'function' && !!collectMeshFromInputs();
    const latest = (() => {
      try { return JSON.parse(localStorage.getItem('levels') || '[]').at(-1); } catch { return null; }
    })();
    const hasSaved = Array.isArray(latest) && latest.length === 4;
    exportMeshBtn.disabled = !(hasInputs || hasSaved);
  }
}


//Scratch mgmt.
function meshIsComplete(m = meshScratch) {
  return m.every(row => row.every(v => typeof v === 'number' && !Number.isNaN(v)));
}

function resetMeshScratch() {
  meshScratch = Array.from({ length: 4 }, () => Array(4).fill(null));
}

//Parsing
function ingestMeshLine(line) {
  const s = line.trim();

  // Row-based: "y  v0 v1 v2 v3"
  const row = s.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
  if (row) {
    const fwY = parseInt(row[1], 10);
    const uiY = 3 - fwY; // flip Y for UI
    meshScratch[uiY][0] = parseFloat(row[2]);
    meshScratch[uiY][1] = parseFloat(row[3]);
    meshScratch[uiY][2] = parseFloat(row[4]);
    meshScratch[uiY][3] = parseFloat(row[5]);
    return meshIsComplete();
  }

  // Point formats: "X0 Y1 Z-0.0945", "X: 0; Y: 1 ... Z..."
  const pXY = s.match(/X\s*:?\s*(\d)\s*[,; ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i)
            || s.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
  if (pXY) {
    const x   = parseInt(pXY[1], 10);
    const fwY = parseInt(pXY[2], 10);
    const uiY = 3 - fwY;
    const val = parseFloat(pXY[3]);
    if (x < 4 && fwY < 4 && Number.isFinite(val)) {
      meshScratch[uiY][x] = val;
      return meshIsComplete();
    }
  }

  return false;
}

function tryParseMeshFromLines(lines) {
  const mesh = Array.from({ length: 4 }, () => Array(4).fill(null));

  for (const raw of lines) {
    const line = raw.trim();

    // Row-based
    const m = line.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
    if (m) {
      const fwY = parseInt(m[1], 10);
      const uiY = 3 - fwY;
      const vals = [parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), parseFloat(m[5])];
      mesh[uiY] = vals;
      continue;
    }

    // Point-by-point
    const p1 = line.match(/[\(\[](\d)\s*,\s*(\d)[\)\]]\s+([+-]?\d*\.?\d+)/);
    const p2 = line.match(/X\s*:?\s*(\d)\s*;?\s*[, ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i);
    const p3 = line.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
    const mP = p1 || p2 || p3;
    if (mP) {
      const x   = parseInt(mP[1], 10);
      const fwY = parseInt(mP[2], 10);
      const uiY = 3 - fwY;
      const val = parseFloat(mP[3]);
      if (x < 4 && fwY < 4) mesh[uiY][x] = val;
    }
  }

  const complete = mesh.every(row => row.every(v => typeof v === 'number' && !isNaN(v)));
  return complete ? mesh : null;
}

//Persistence
function loadMeshLS() {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  return hist.at(-1) || Array.from({length:4},()=>Array(4).fill(''));
}

function saveMeshLS(mesh) {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  hist.push(mesh);
  while (hist.length > 10) hist.shift();  // keep last 10
  localStorage.setItem('levels', JSON.stringify(hist));
}

//Presentation
function getScrewData(mesh) {
  const result = {};
  for (const screw in screwAffects) {
    const points = screwAffects[screw];
    const values = points
      .map(([y,x]) => mesh?.[y]?.[x])
      .filter(v => typeof v === 'number' && !isNaN(v));
    const avg = values.length ? values.reduce((a,b)=>a+b,0)/values.length : null;

    let suggestion='N/A', turn='N/A';
    if (avg !== null) {
      if (avg >  0.07)      { suggestion='Tighten (Clockwise)';           turn='Strong (1/4 turn)'; }
      else if (avg > 0.04)  { suggestion='Tighten (Clockwise)';           turn='Moderate (1/8 turn)'; }
      else if (avg > 0.02)  { suggestion='Tighten (Clockwise)';           turn='Slight (1/16 turn)'; }
      else if (avg < -0.07) { suggestion='Loosen (Counterclockwise)';     turn='Strong (1/4 turn)'; }
      else if (avg < -0.04) { suggestion='Loosen (Counterclockwise)';     turn='Moderate (1/8 turn)'; }
      else if (avg < -0.02) { suggestion='Loosen (Counterclockwise)';     turn='Slight (1/16 turn)'; }
      else { suggestion='No change'; }
    }
    result[screw] = { avg: avg?.toFixed(3) ?? 'N/A', suggestion, turn };
  }
  return result;
}

function renderMeshInputs(mesh) {
  meshInput.innerHTML = '';
  for (let y=0; y<4; y++) {
    const tr = document.createElement('tr');
    for (let x=0; x<4; x++) {
      const v = mesh?.[y]?.[x];
      tr.innerHTML += `<td><input type="number" step="0.001" id="cell-${y}-${x}" value="${typeof v==='number'? v.toFixed(3): ''}" required></td>`;
    }
    meshInput.appendChild(tr);
  }
}

function renderSuggestions(mesh) {
  const data = getScrewData(mesh);
  screwTable.innerHTML = '';
  const layout = ['A1','GAP','A2','A3','B1','B2','B3','B4','C1','C2','C3','C4'];
  for (const sName of layout) {
    if (sName === 'GAP') continue;
    const s = data[sName];
    const tr = document.createElement('tr');
    tr.className = s.suggestion.includes('Tighten') ? 'tighten'
               :  s.suggestion.includes('Loosen')  ? 'loosen'
               :  'na';
    tr.innerHTML = `<td>${sName}</td><td>${s.avg}</td><td>${s.suggestion}</td><td>${s.turn}</td>`;
    screwTable.appendChild(tr);
    const cell = document.getElementById(sName);
    if (cell) {
      cell.className = tr.className;
      cell.innerHTML = `<strong>${sName}</strong><br>${s.avg} mm<br>${s.turn!=='N/A'? s.turn : ''}`;
    }
  }
}

//Export and Numeric
function exportMeshAsFile(mesh, label) {
  const blob = new Blob([JSON.stringify(mesh, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `cr6se-mesh-${label}-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function promptNumber(message, def) {
  const raw = safePrompt(message, String(def));
  if (raw === null) return null;
  const n = parseFloat(raw);
  return Number.isFinite(n) ? n : NaN;
}

/* =========================================================
   7) SERIAL / COMMS (connect, read loop, send, waits)
========================================================= */

async function requestPortSafe() {
  if (isVirtual()) throw new Error('virtual-mode'); // never open picker in virtual
  return await navigator.serial.requestPort();
}

//Real Connection
//Real Connection
async function connectPrinter() {
  if (isConnecting) return;
  isConnecting = true;

  try {
    // Virtual path
if (virtualMode) {
  await connectVirtual();
  connKind = 'virtual';
  return;
}
    // Real serial path
    if (!('serial' in navigator)) {
      setConnected(false);
      setActivity('Web Serial not supported', 'bad');
      logMsg('❌ Web Serial API not supported. Use Chrome/Edge/Brave on desktop.');
      alert('Web Serial API not supported. Use Chrome/Edge/Brave on desktop.');
      connKind = 'none';
      return;
    }

    setActivity('Connecting...', 'warn');

    if (!port) {
      const granted = await navigator.serial.getPorts();
      port = granted[0] || await requestPortSafe();
    }

    const sel = baudSelection();
    let connectedAt = null;

    if (sel.mode === 'manual') {
      // Open immediately at the selected baud (no handshake gating)
      const b = sel.list[0];
      await openAtBaud(b);
      connectedAt = b;
    } else {
      // Auto-detect: probe each candidate with a longer timeout
      for (const b of sel.list) {
        setActivity(`Trying ${b}…`, 'warn');
        const res = await probeAtBaud(b, 5000);
        if (res.success) { connectedAt = res.baud; break; }
        await sleep(180); // brief pause before the next try
      }
    }

    if (!connectedAt) {
      setConnected(false);
      setActivity('Connect error', 'bad');
      logMsg('❌ No response at tried baud rates. Try selecting 115200 manually or another cable/port.');
      connKind = 'none';
      return;
    }

    // We're open with reader/writer from openAtBaud()/probeAtBaud()
    setConnected(true);
    cancelStream = false; // ← clear leftover cancel flag from a previous send
    sendCmd('M105', true); // prime a latency sample
    updateLevelView();
    hideEtaPill();
    updateTempPanel();
    startTempPolling();
    updateLastUpdated();
    setActivity(`Connected @ ${connectedAt}`, 'ok');
    logMsg(`Connected at ${connectedAt} baud.`);
    if (!reading) readLoop();

    connKind = 'real';
  } catch (err) {
    setConnected(false);
    setActivity('Connect error', 'bad');
    logMsg(String(err?.message || err));
    _rejectAllOk(new Error('Connect failed'));
    hideEtaPill();
    connKind = 'none';
  } finally {
    isConnecting = false;
  }
}

async function disconnectPrinter(reason = 'user') {
  if (isDisconnecting) return;
  isDisconnecting = true;

  const lost = reason === 'lost';
  try {
    // Fail any pending waits / streams immediately
    _rejectAllOk(new Error(lost ? 'Connection lost' : 'Disconnected'));
    if (probeLatch) {
      try { probeLatch.reject(new Error(lost ? 'lost' : 'disconnected')); }
      finally { probeLatch = null; }
    }

    // Put sender into a cancelled/abort state during teardown
    cancelStream = true;

    // Reset sender UI + ETA
    if (sendProgress) sendProgress.style.width = '0%';
    if (sendStatus)   sendStatus.textContent = 'Idle';
    hideEtaPill();
    clearAllPidUi();

    // Virtual path
    if (connKind === 'virtual' || virtualMode) {
      await disconnectVirtual();  // handles setConnected(false)
      connKind = 'none';
      stopTempPolling();
      setActivity(lost ? 'Connection lost (virtual)' : 'Disconnected', lost ? 'bad' : 'ok');
      if (lost) logMsg('❌ Connection lost (virtual).'); else logMsg('🔌 Virtual printer disconnected.');
      return; // finally{} will still run
    }

    // Real serial path
    setConnected(false); // also stops temp polling + net meter + sets offline pills
    setActivity(lost ? 'Connection lost…' : 'Disconnecting…', lost ? 'bad' : 'warn');
    stopTempPolling();

    try { if (reader) await reader.cancel(); } catch {}
    try { if (reader) reader.releaseLock(); } catch {}
    try { if (writer) writer.releaseLock(); } catch {}
    try { if (port)   await port.close();   } catch {}

    port = null;
    reader = null;
    writer = null;

    if (postPrintTimer) { clearTimeout(postPrintTimer); postPrintTimer = null; }

    setActivity(lost ? 'Connection lost' : 'Disconnected', lost ? 'bad' : 'ok');
    logMsg(lost ? '❌ Connection to printer was lost.' : '🔌 Disconnected.');
    connKind = 'none';
  } catch (err) {
    logMsg('❌ Disconnect error: ' + (err?.message || err));
    setActivity('Disconnect error', 'bad');
    connKind = 'none';
  } finally {
    // IMPORTANT: don’t let a previous cancel poison future one-shot macros
    cancelStream = false;      // ← reset the sticky flag
    isDisconnecting = false;
  }
}

const VIRT_REPLIES = {
  M115: [
    'FIRMWARE_NAME:Marlin 2.1.2.1 (Github)',
    'FIRMWARE_URL:https://github.com/MarlinFirmware/Marlin',
    'PROTOCOL_VERSION:1.0',
    'MACHINE_TYPE:Ender-3 Pro',
    'EXTRUDER_COUNT:1',
    'UUID:00000000-0000-0000-0000-000000000000',
    'ok'
  ].join('\n'),

  M503: [
    'echo:  Steps per unit: M92 X80.00 Y80.00 Z400.00 E93.00',
    'echo:  Maximum feedrates: M203 X500.00 Y500.00 Z12.00 E25.00',
    'echo:  Acceleration: M201 X1000.00 Y1000.00 Z100.00 E5000.00',
    'echo:  Advanced: M205 X10.00 Y10.00 Z0.30 E5.00 J0.10',
    'ok'
  ].join('\n')
};

//Virtual Connection
async function connectVirtual() {
  if (connKind === 'virtual') { logMsg('🧪 Already in virtual mode.'); return; }
  setConnected(true);
updateLevelView();
  setActivity('Connected (virtual)', 'ok');
  logMsg('🧪 Virtual printer connected.');
  startVirtualSim();
  startTempPolling();
  updateLastUpdated();
}

async function disconnectVirtual() {
  if (connKind !== 'virtual') { logMsg('🧪 Virtual not active.'); }
  stopVirtualSim();
  setConnected(false);
  setActivity('Disconnected', 'ok');
  logMsg('🔌 Virtual printer disconnected.');
}

//Virtual temps and sim
function refreshVirtualTemps() {
  // Mirror vState → temps
  temps.hot = vState.hot;
  temps.hotTarget = vState.hotTarget;
  temps.bed = vState.bed;
  temps.bedTarget = vState.bedTarget;

  // ✅ ADD THESE:
  _pushAmbientSample('hot', temps.hot ?? 0, temps.hotTarget);
  _pushAmbientSample('bed', temps.bed ?? 0, temps.bedTarget);

  // Update the pills + panel (normally done by readLoop in real mode)
  setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
  setTempPill(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget, 'bed');
  updateTempPanel();
}

function startVirtualSim() {
  if (vSimTimer) return;
  vSimTimer = setInterval(() => {
    const stepHot = 0.6, stepBed = 0.35;
    if (Number.isFinite(vState.hotTarget)) {
      const d = vState.hotTarget - vState.hot;
      vState.hot += Math.sign(d) * Math.min(Math.abs(d), stepHot);
    }
    if (Number.isFinite(vState.bedTarget)) {
      const d = vState.bedTarget - vState.bed;
      vState.bed += Math.sign(d) * Math.min(Math.abs(d), stepBed);
    }
    // keep temps in sync and refresh UI
    refreshVirtualTemps();
    recordLiveSample();
  }, 100);
}

function stopVirtualSim() {
  if (vSimTimer) { clearInterval(vSimTimer); vSimTimer = null; }
}

// Send paths — virtual and real separated cleanly
async function sendCmd(cmd, quiet = false) {
  const line = String(cmd).trim();
  const id = line.split(/\s+/)[0].toUpperCase(); // e.g. "M503", "M115"

  const isM503 = id === 'M503';
  const isM115 = id === 'M115';
  const isM122 = id === 'M122';

  // ---------------- VIRTUAL PATH ----------------
  if (connKind === 'virtual') {
    // canned replies by id
    const canned = VIRT_REPLIES && VIRT_REPLIES[id];
    if (!quiet) logMsg('>> ' + line);

    if (canned) {
      // stream lines into the log and return the full block
      canned.split('\n').forEach(l => logMsg(l));
      return canned; // IMPORTANT: tables/parsers rely on this
    }

    // No canned reply — simulate a simple ok
    logMsg('ok');
    return 'ok';
  }

  // ---------------- REAL SERIAL PATH ----------------
  // Heater guardrail
  if (!guardHeaterFromCmd(line)) {
    throw new Error('Heater guardrail blocked high temperature command');
  }
  if (!writer) {
    setActivity('Not connected', 'bad');
    throw new Error('Not connected');
  }

  setLastCmd(line);
  setActivity('Sending…', 'warn');

  // Prepare optional capture for commands that dump multi-line blocks
  let replyPromise = null;
  if (isM503 || isM115 || isM122) {
    // ensure no stale capture is active
    if (typeof oneShotCapture !== 'undefined' && oneShotCapture) {
      try { oneShotCapture.resolve(oneShotCapture.buf?.join('\n') || ''); } catch {}
      oneShotCapture = null;
    }
    beginCritical?.();
    stopTempPolling?.();
    replyPromise = captureReplyOnce({ doneOnOk: true });
  }

  // Write to serial
  const payload = new TextEncoder().encode(line + '\n');
  lastSendTs = performance.now();

  await writer.write(payload);
  if (!quiet) logMsg('>> ' + line);

  // TX metering
  net.txBytesTotal += payload.length;
  net.txSince      += payload.length;

  updateLastUpdated();
  setActivity('Waiting…', 'warn');

  // If we started a capture, return it; make sure we endCritical/start polling after it finishes
  if (replyPromise) {
    return replyPromise.finally(() => {
      try { startTempPolling?.(); } catch {}
      endCritical?.();
    });
  }

  // Commands that don't produce a block reply just return empty string
  return '';
}

function updateTempsUI({ hotend, hotendSet, bed, bedSet }) {
  // Example spans – change selectors to your IDs/classes
  const elH = document.getElementById('tempHotend');
  const elHS = document.getElementById('tempHotendSet');
  const elB = document.getElementById('tempBed');
  const elBS = document.getElementById('tempBedSet');

  if (elH)  elH.textContent  = isFinite(hotend)    ? hotend.toFixed(1) : '—';
  if (elHS) elHS.textContent = isFinite(hotendSet) ? hotendSet.toFixed(0) : '—';
  if (elB)  elB.textContent  = isFinite(bed)       ? bed.toFixed(1) : '—';
  if (elBS) elBS.textContent = isFinite(bedSet)    ? bedSet.toFixed(0) : '—';

  // If you have a live chart, enqueue a point here too
  if (typeof queueLiveDraw === 'function') {
    try {
      live.lastHotend = hotend;
      live.lastHotendSet = hotendSet;
      live.lastBed = bed;
      live.lastBedSet = bedSet;
      queueLiveDraw();
    } catch {}
  }
}

async function sendCmdVirtual(cmd, quiet = false) {
  const line = String(cmd).trim();

  // Heater guardrail (blocks M104/M109 or M140/M190 over limits unless unlocked)
  if (!guardHeaterFromCmd(line)) {
    throw new Error('Heater guardrail blocked high temperature command');
  }

  setLastCmd(line);
  setActivity('Sending…', 'warn');
  if (!quiet) logMsg('>> ' + line);

  // Approximate TX size for virtual path (no real serial)
  const approxLen = line.length + 1; // + '\n'
  if (typeof net !== 'undefined') {
    net.txBytesTotal += approxLen;
    net.txSince      += approxLen;
  }

  // Stamp send time for latency EMA in no-waiter cases
  lastSendTs = performance.now();

  // --- Live graph taps: fan (M106/M107) + progress (M73) -------------------
  // Fan set
  if (/^M106\b/i.test(line)) {
    const m = line.match(/\bS\s*([0-9.]+)/i);
    if (m) {
      const s = Math.max(0, Math.min(255, parseInt(m[1], 10) || 0));
      if (typeof live !== 'undefined') live.lastFan255 = s;
      if (typeof queueLiveDraw === 'function') queueLiveDraw();
    }
  }
  if (/^M107\b/i.test(line)) {
    if (typeof live !== 'undefined') live.lastFan255 = 0;
    if (typeof queueLiveDraw === 'function') queueLiveDraw();
  }
  // M73 progress
  if (/^M73\b/i.test(line)) {
    const p = line.match(/\bP\s*([0-9]+)/i);
    if (p && typeof live !== 'undefined') {
      live.lastProg = Math.max(0, Math.min(100, parseInt(p[1], 10) || 0));
      if (typeof queueLiveDraw === 'function') queueLiveDraw();
    }
    const r = line.match(/\bR\s*([0-9]+)/i);
    if (r) {
      const mins = Math.max(0, parseInt(r[1], 10) || 0);
      showEtaPill('ETA: ' + formatETA(mins * 60), 'warn');
    }
  }



  // -------------------------------------------------------------------------

  const ok = () => {
    setActivity('Waiting…', 'warn');
    setTimeout(() => {
      // suppress visible "ok" for quiet calls and for M105 polls
      if (!quiet && !/^M105\b/i.test(line)) logMsg('ok');
      _resolveNextOk();          // updates latency EMA if a waiter is present
      updateLastUpdated();
      setActivity('Idle');
    }, 60);
  };

  const emitTelemetry = () => {
    const ht = Number.isFinite(vState.hotTarget) ? vState.hotTarget : 0;
    const bt = Number.isFinite(vState.bedTarget) ? vState.bedTarget : 0;
    const telem = `T:${vState.hot.toFixed(1)} / ${Math.round(ht)} B:${vState.bed.toFixed(1)} / ${Math.round(bt)} @:0 B@:0`;
    logMsg(telem);
    refreshVirtualTemps();
  };

  switch (true) {

      case /^M122\b/i.test(line): {
    const lines = [
      'echo:  Testing TMC drivers...',
      'echo:  X driver: TMC2209',
      'echo:  X RMS current: 800',
      'echo:  X microsteps: 16',
      'echo:  X stealthChop: enabled',
      'echo:  X spreadCycle: disabled',
      'echo:  X otpw: false',
      'echo:  X error: false',
      'echo:  Y driver: TMC2209',
      'echo:  Y RMS current: 850',
      'echo:  Y microsteps: 16',
      'echo:  Y stealthChop: enabled',
      'echo:  Y spreadCycle: disabled',
      'echo:  Y otpw: false',
      'echo:  Y error: false',
      'echo:  Z driver: TMC2209',
      'echo:  Z RMS current: 900',
      'echo:  Z microsteps: 16',
      'echo:  Z stealthChop: enabled',
      'echo:  Z spreadCycle: disabled',
      'echo:  Z otpw: false',
      'echo:  Z error: false',
      'echo:  E driver: TMC2209',
      'echo:  E RMS current: 700',
      'echo:  E microsteps: 16',
      'echo:  E stealthChop: enabled',
      'echo:  E spreadCycle: disabled',
      'echo:  E otpw: false',
      'echo:  E error: false',
      'ok'
    ];
    lines.forEach(l => logMsg(l));
    if (typeof ok === 'function') ok();
    return lines.join('\n'); // returning ends the switch branch
  }

    // --- Telemetry ---
    case /^M105\b/i.test(line): {
      emitTelemetry();
      ok();
      break;
    }

    // --- PID autotune sim ---
    case /^M303\b/i.test(line): {
      const eParam = line.match(/\bE\s*(-?\d+)/i);
      const cParam = line.match(/\bC\s*(\d+)/i);
      const tool = eParam ? (parseInt(eParam[1], 10) === -1 ? 'bed' : 'hotend') : 'hotend';
      const cycles = cParam ? Math.max(1, Math.min(20, parseInt(cParam[1], 10))) : 5;

      logMsg(`PID Autotune start (${tool}) C=${cycles}`);
      setPidActive(tool, true);
      setTimeout(() => logMsg('PID Autotune finished'), Math.round(cycles * 600));
      ok();
      break;
    }

    // --- Targets / basic controls ---
    case /^M104\b/i.test(line): {
      const s = line.match(/S\s*([0-9.]+)/i);
      vState.hotTarget = s ? parseFloat(s[1]) : null;
      refreshVirtualTemps();
      ok();
      break;
    }
    case /^M140\b/i.test(line): {
      const s = line.match(/S\s*([0-9.]+)/i);
      vState.bedTarget = s ? parseFloat(s[1]) : null;
      refreshVirtualTemps();
      ok();
      break;
    }
    case /^M106\b/i.test(line):
    case /^M107\b/i.test(line):
    case /^M400\b/i.test(line):
    case /^M82\b/i.test(line):
    case /^M83\b/i.test(line):
    case /^M500\b/i.test(line):
    case /^M84\b/i.test(line):
    case /^G90\b/i.test(line):
    case /^G91\b/i.test(line):
      ok(); break;

    // --- Homing / movement ---
    case /^G28\b/i.test(line): {
      vState.x = 0; vState.y = 0; vState.z = 0;
      logMsg('X:0.000 Y:0.000 Z:0.000');
      ok();
      break;
    }
    case /^G1\b/i.test(line): {
      const x = line.match(/X\s*([-+]?\d*\.?\d+)/i);
      const y = line.match(/Y\s*([-+]?\d*\.?\d+)/i);
      const z = line.match(/Z\s*([-+]?\d*\.?\d+)/i);
      if (x) vState.x = parseFloat(x[1]);
      if (y) vState.y = parseFloat(y[1]);
      if (z) vState.z = parseFloat(z[1]);
      logMsg(`X:${vState.x.toFixed(3)} Y:${vState.y.toFixed(3)} Z:${vState.z.toFixed(3)}`);
      ok();
      break;
    }

    // --- Mesh report (G29 T) ---
    case /^G29\b/i.test(line) && /\bT\b/i.test(line): {
      const hasMock = Array.isArray(mockMesh) && mockMesh.length > 0;
      if (hasMock) {
        for (const raw of mockMesh) {
          const l = String(raw).trim();
          if (!l || /^ok\b/i.test(l)) continue;
          logMsg(l);
          processMeshLineFromAnywhere(l);
        }
      } else {
        const rows = [
          [ -0.120, -0.080, -0.035, -0.010 ],
          [ -0.075, -0.030,  0.005,  0.020 ],
          [ -0.040,  0.000,  0.030,  0.050 ],
          [ -0.010,  0.020,  0.055,  0.070 ],
        ];
        rows.forEach((vals, y) => {
          const l = `${y}  ${vals.map(v => (v >= 0 ? `+${v.toFixed(3)}` : v.toFixed(3))).join('  ')}`;
          logMsg(l);
          processMeshLineFromAnywhere(l);
        });
      }
      ok();
      break;
    }

    // --- Info / diagnostics ---
case /^M115\b/i.test(line): {
  const lines = [
    'FIRMWARE_NAME:Marlin 2.1.2.1 (Github)',
    'FIRMWARE_URL:https://github.com/MarlinFirmware/Marlin',
    'PROTOCOL_VERSION:1.0',
    'MACHINE_TYPE:Ender-3 Pro',
    'EXTRUDER_COUNT:1',
    'UUID:00000000-0000-0000-0000-000000000000',
    'ok'
  ];
  lines.forEach(l => logMsg(l));
  if (typeof ok === 'function') ok();
  return lines.join('\n');
}
    case /^M122\b/i.test(line): {
      logMsg('Driver diag (virtual): all good.');
      ok();
      break;
    }
case /^M503\b/i.test(line): {
  const lines = [
    'echo:  Steps per unit: M92 X80.00 Y80.00 Z400.00 E93.00',
    'echo:  Maximum feedrates: M203 X500.00 Y500.00 Z12.00 E25.00',
    'echo:  Acceleration: M201 X1000.00 Y1000.00 Z100.00 E5000.00',
    'echo:  Advanced: M205 X10.00 Y10.00 Z0.30 E5.00 J0.10',
    'ok'
  ];
  lines.forEach(l => logMsg(l));
  // if your flow expects an “ok”, keep this
  if (typeof ok === 'function') ok();
  // IMPORTANT: return the text so parseM503 receives it
  return lines.join('\n');
}


    // --- UI cancel hook ---
    case /^\/\/action:cancel/i.test(line): {
      logMsg('//action:cancel (virtual ack)');
      setTimeout(() => { _resolveNextOk(); updateLastUpdated(); }, 10);
      break;
    }

    // --- Fallback ---
    default:
      ok();
  }
}


//Read and parse loop
async function readLoop() {
  reading = true;
  try {
    while (true) {
      const { value, done } = await reader.read();

      // stream closed -> treat as lost connection
      if (done) {
        if (!isDisconnecting) await disconnectPrinter('lost');
        break;
      }
      if (value == null) continue;

      // --- RX metering ---
      if (value instanceof Uint8Array) {
        net.rxBytesTotal += value.length;
        net.rxSince      += value.length;
      } else if (typeof value === 'string') {
        net.rxBytesTotal += value.length;
        net.rxSince      += value.length;
      }

      // normalize to string
      const chunk = (value instanceof Uint8Array)
        ? textDecoder.decode(value, { stream: true })
        : value;

      rxBuffer += chunk;
      const parts = rxBuffer.split(/\r?\n/);
      rxBuffer = parts.pop(); // keep incomplete tail

      for (const raw of parts) {
        const line = raw.trim();
        if (!line) continue;

        // --- temps (M105-style) ---
        const tMatch = !captureMode && line.match(TEMP_T);
        const bMatch = !captureMode && line.match(TEMP_B);

        if (tMatch) {
          const tCur = parseFloat(tMatch[1]);
          const tTar = tMatch[2] !== undefined ? parseFloat(tMatch[2]) : null;
          if (Number.isFinite(tCur)) {
            temps.hot = tCur;
            temps.hotTarget = Number.isFinite(tTar) ? tTar : null;
            _pushAmbientSample('hot', temps.hot ?? 0, temps.hotTarget);
            setTempPill(topHotendPill, topHotendText, temps.hot, temps.hotTarget, 'hotend');
          }
        }
        if (bMatch) {
          const bCur = parseFloat(bMatch[1]);
          const bTar = bMatch[2] !== undefined ? parseFloat(bMatch[2]) : null;
          if (Number.isFinite(bCur)) {
            temps.bed = bCur;
            temps.bedTarget = Number.isFinite(bTar) ? bTar : null;
            _pushAmbientSample('bed', temps.bed ?? 0, temps.bedTarget);
            setTempPill(topBedPill, topBedText, temps.bed, temps.bedTarget, 'bed');
          }
        }
                if (tMatch || bMatch) {
          updateTempPanel();
          // NEW: push a point into the live chart whenever we ingest temps
          if (typeof recordLiveSample === 'function') recordLiveSample();
        }

        // --- positions (e.g., "X:.. Y:.. Z:..") ---
        const posMatch = line.match(POS_REGEX);
        if (posMatch) {
          const x = parseFloat(posMatch[1]);
          const y = parseFloat(posMatch[2]);
          const z = parseFloat(posMatch[3]);
          if ([x, y, z].every(Number.isFinite)) {
            updateAxisPanel(x, y, z);
            // NEW: infer homed if it looks like the post-home coordinates
            maybeMarkHomedFromPos(x, y, z);
          }
        }

        // --- logging (respect noisy/telemetry filters & debug) ---
        const isTelemetry = TELEMETRY_REGEX.test(line);
        const out = normalizeLine(line);

        // ---- FEED CAPTURE (non-ok lines only)  --------------------
        // CHANGED: only push here; don't resolve here.
        if (oneShotCapture && out && !/^ok\b/i.test(out)) {
          oneShotCapture.buf.push(out);
        }
        // -----------------------------------------------------------

        // track “homing-ish” hints for printer-panel homes
        maybeMarkHomingHint(out);

        if (!debugMode && (isSetNewScreenLine(out) || isNoisyLine(out))) {
          // skip
        } else if (debugMode) {
          if (tMatch || bMatch) {
            const hotStr = temps.hot != null
              ? `${temps.hot.toFixed(1)}${temps.hotTarget != null ? ' / ' + Math.round(temps.hotTarget) : ''}`
              : '--';
            const bedStr = temps.bed != null
              ? `${temps.bed.toFixed(1)}${temps.bedTarget != null ? ' / ' + Math.round(temps.bedTarget) : ''}`
              : '--';
            logMsg(`🌡 Hotend ${hotStr} · Bed ${bedStr}`);
          } else {
            logMsg(out);
          }
        } else {
          if (!isTelemetry) logMsg(out);
        }

        // --- mesh ingestion (G29 T variants) ---
        const meshCompleted = ingestMeshLine(out);
        if (meshCompleted) {
          const meshForUi = meshScratch.map(r => r.slice()); // already Y-flipped
          setActivity('Mesh parsed', 'ok');
          saveMeshLS(meshForUi);
          renderMeshInputs(meshForUi);
          renderSuggestions(meshForUi);
          updateLastUpdated();
          resetMeshScratch();
        }

        // --- probe completion latch ---
        if (probeLatch) {
          if (
            out.includes('//action:notification Settings Stored') ||  // DWIN save event
            /Bilinear Leveling Grid:/i.test(out)                      // fallback
          ) {
            try { probeLatch.resolve(); } finally { probeLatch = null; }
          }
        }

        // --- PID hints ---
        if (/PID Autotune start/i.test(out)) {
          setActivity('PID tuning…', 'warn');
          if (!pidTarget) {
            if (/\(bed\)/i.test(out) || /\bE-?1\b/i.test(out) || /\bBED\b/i.test(out)) {
              setPidActive('bed', true);
            } else {
              setPidActive('hotend', true);
            }
          }
        }
        if (/PID Autotune finished/i.test(out)) {
          setActivity('PID tuning complete', 'ok');
          clearAllPidUi();
        }
        if (/PID Autotune failed/i.test(out)) {
          setActivity('PID tuning failed', 'bad');
          clearAllPidUi();
        }

        // --- ok resolver (single source of truth) ---
        if (/^ok\b/i.test(out)) {
          // Resolve capture first so callers get full text
          if (oneShotCapture && oneShotCapture.doneOnOk) {
            try { oneShotCapture.resolve(oneShotCapture.buf.join('\n')); }
            finally { oneShotCapture = null; }
          }

          updateLastUpdated();
          if (captureMode) { captureMode = null; startTempPolling(); }
          _resolveNextOk();
        }
      }
    }
  } catch (err) {
    logMsg('⚠️ Read error: ' + (err?.message || err));
    if (!isDisconnecting) await disconnectPrinter('lost');
  } finally {
    reading = false;
  }
}




//Wait plumbing
function waitForOk() {
  beginCritical();
  return new Promise((resolve, reject) => {
    const wrapResolve = () => { try { resolve(); } finally { if (pendingOk.length === 0) endCritical(); } };
    const wrapReject  = (err) => { try { reject(err); }  finally { if (pendingOk.length === 0) endCritical(); } };

    // Real serial requires a live port/writer; virtual can proceed.
    const isReal = (connKind === 'real');
    if (isReal && (!port || !writer)) { wrapReject(new Error('Disconnected')); return; }
    if (cancelStream) { wrapReject(new Error('Cancelled')); return; }

    pendingOk.push({ resolve: wrapResolve, reject: wrapReject, startedAt: performance.now() });
  });
}

function _resolveNextOk() {
  const waiter = pendingOk.shift();
  if (waiter) {
    const ms = (typeof waiter.startedAt === 'number')
      ? (performance.now() - waiter.startedAt)
      : null;

    try { waiter.resolve(); } finally {
      if (ms != null && typeof updateLatency === 'function') {
        updateLatency(ms);
      }
      // ✅ avoid stale measurements on the next ok
      lastSendTs = null;

      if (pendingOk.length === 0) endCritical();
    }
  } else {
    if (lastSendTs != null) {
      const ms = performance.now() - lastSendTs;
      lastSendTs = null;                 // consume this measurement
      if (ms > 0 && isFinite(ms) && typeof updateLatency === 'function') {
        updateLatency(ms);
      }
    }
  }
}



function _rejectAllOk(err) {
  const all = pendingOk.splice(0);
  for (const w of all) {
    try { w.reject(err || new Error('Aborted')); } catch {}
  }

  // also reject an in-flight probe latch
  if (probeLatch) {
    try { probeLatch.reject(err || new Error('disconnected')); }
    finally { probeLatch = null; }
  }

  // Ensure we don't leave polling paused
  criticalDepth = 0;
  startTempPolling();
}

//Heater waiters
async function waitForHotend(target, tol = 1.0) {
  await sendCmd(`M104 S${Math.round(target)}`);
  await waitForOk().catch(()=>{});
  return new Promise(resolve => {
    let timer;
    const check = async () => {
      await sendCmd('M105', true);
      if (temps.hot != null && Math.abs(temps.hot - target) <= tol) {
        clearInterval(timer); resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}

async function waitForBed(target, tol = 1.0) {
  await sendCmd(`M140 S${Math.round(target)}`);
  await waitForOk().catch(()=>{});
  return new Promise(resolve => {
    let timer;
    const check = async () => {
      await sendCmd('M105', true);
      if (temps.bed != null && Math.abs(temps.bed - target) <= tol) {
        clearInterval(timer); resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}

/* =========================================================
   8) UI ACTIONS (PID, leveling, movement, sender, config)
========================================================= */

//PID
async function runBedPID() {
  const t = promptNumber('Enter bed PID target temp (S):', 60);
  if (t === null || !Number.isFinite(t)) return alert('Invalid temperature.');
  const c = promptCycles('bed');
  if (c === null) return;

  setActivity(`PID bed @ ${t}°C (C=${c})…`, 'warn');
  pidTarget = 'bed';
  try {
    await sendCmd(`M303 C${c} E-1 S${t} U`);
    await waitForOk();
  } finally {
    pidTarget = null;
  }
  logMsg('ℹ️ PID tuning can take a few minutes. Send M500 to save if required.');
}

async function runHotendPID() {
  const t = promptNumber('Enter nozzle PID target temp (S):', 220);
  if (t === null || !Number.isFinite(t)) return alert('Invalid temperature.');
  const c = promptCycles('hotend');
  if (c === null) return;

  setActivity(`PID hotend @ ${t}°C (C=${c})…`, 'warn');
  pidTarget = 'hotend';
  try {
    await sendCmd(`M303 C${c} E0 S${t} U`);
    await waitForOk();
  } finally {
    pidTarget = null;
  }
  logMsg('ℹ️ PID tuning can take a few minutes. Send M500 to save if required.');
}

//Leveling Shortcuts
async function readMesh(){
  await sendCmd('G29 T');
  setActivity('Parsing…', 'warn');
}

async function reprobe(){
  await sendCmdsSequential('G28', 'G29 T');
  setActivity('Probing…', 'warn');
}

//Manual
function sendManual(){
  const cmd = manualCmd.value.trim();
  if (!cmd) return;
  sendCmd(cmd).catch(err => logMsg('⚠️ ' + (err?.message || 'Send failed')));
  manualCmd.value = '';
}

//Jog and move
async function jog(axis, dir) {
  const step = parseFloat(jogStep.value) || 1;
  const dist = (dir * step).toFixed(3);
  const feed = (axis === 'Z') ? 300 : 3000;

  try {
    // Auto-home once if needed
    if (!isHomed) {
      setActivity('Auto-homing before jog…', 'warn');
      await sendCmd('G28'); await waitForOk().catch(()=>{});
      isHomed = true;

      // ⬇️ Cool to 0 after auto-home triggered by a jog
      await coolToIdle();

      setActivity('Jogging…', 'warn');
    }

    // Relative move, then back to absolute
    await sendCmd('G91');                        await waitForOk().catch(()=>{});
    await sendCmd(`G1 ${axis}${dist} F${feed}`); await waitForOk().catch(()=>{});
    await sendCmd('G90');                        await waitForOk().catch(()=>{});
    setActivity('Idle');

    // Update position readout
    await sendCmd('M114', true);                 await waitForOk().catch(()=>{});
  } catch (e) {
    setActivity('Jog failed', 'bad');
    logMsg('⚠️ Jog error: ' + (e?.message || e));
  }
}

//Sender
// Sender
async function streamGcode(file) {
  // --- Guards ---
  if (!(connKind === 'virtual' || writer)) {
    alert('Not connected.');
    return;
  }
  if (!file) {
    if (sendStatus) sendStatus.textContent = 'No file selected';
    logMsg?.('⚠️ streamGcode called without a file');
    return;
  }

  cancelStream = false;
  if (cancelSend) cancelSend.disabled = true;
  hideEtaPill?.();

  if (sendProgress) sendProgress.style.width = '0%';
  if (sendStatus)   sendStatus.textContent   = 'Homing…';

  try {
    beep?.('start');
    printerBeep?.('start');

    // Read the file text we will send
    const text = await file.text();

    // Keep the preview in sync with exactly what we're sending
    // (parses and prepares the scrubber/layers)
    window.GCodePreview?.loadFromText(text);

    // Build sendable lines + map to original source line numbers for tracking
    const rawLines = text.split(/\r?\n/);
    const lines = [];
    const srcNos = []; // 1-based original line numbers
    for (let i = 0; i < rawLines.length; i++) {
      const stripped = rawLines[i].replace(/;.*/, '').trim();
      if (!stripped) continue;
      lines.push(stripped);
      srcNos.push(i + 1);
    }

    if (!lines.length) {
      if (sendStatus) sendStatus.textContent = 'No G-code lines found';
      return;
    }

    // ---- ETA precomputation (unchanged from your logic) ----
    const countingMask   = lines.map(isCountingLine);
    const countingTotal  = countingMask.reduce((a,b)=>a+(b?1:0),0);
    const warmupCount    = Math.min(400, Math.max(50, Math.floor(countingTotal * 0.01))); // 1% (50–400)

    // EMA for time/line (s), starts after first counting line
    let emaSecPerLine = 0;
    const alpha       = 0.15;  // smoothing
    let sentCounting  = 0;
    let lastCountTs   = 0;
    let startedETA    = false;

    // Home before sending
    logMsg?.('🏠 Homing all axes (G28)…');
    await sendCmd('G28');
    await waitForOk();

    let sent = 0;
    const total = lines.length;

    if (cancelSend) cancelSend.disabled = false;
    if (sendStatus) sendStatus.textContent = 'Sending…';
    showEtaPill?.('ETA: heating/preamble…', 'warn');

    for (let i = 0; i < lines.length; i++) {
      if (cancelStream) break;

      const line = lines[i];

      // Send + wait
      await sendCmd(line);
      const t0 = Date.now();
      await waitForOk();
      const t1 = Date.now();

      // Advance the preview to reflect this command's original line
      if (window.GCodePreview?.updateByGcodeLine) {
        window.GCodePreview.updateByGcodeLine(srcNos[i]);
      }

      sent++;

      // Progress bar remains based on all lines
      const pct = Math.round((sent / total) * 100);
      if (sendProgress) sendProgress.style.width = pct + '%';
      if (sendStatus)   sendStatus.textContent = `Sent ${sent}/${total} (${pct}%)`;

      // ---- ETA: count only real "print" lines ----
      if (countingMask[i]) {
        const deltaSec = (t1 - (lastCountTs || t1)) / 1000;
        lastCountTs = t1;

        if (!startedETA) {
          // First counting line establishes the clock
          startedETA = true;
          emaSecPerLine = Math.max(0.001, deltaSec);
          sentCounting = 1;
          showEtaPill?.('ETA: estimating…', 'warn');
        } else {
          sentCounting++;
          // Train EMA continuously
          emaSecPerLine = alpha * deltaSec + (1 - alpha) * emaSecPerLine;

          if (sentCounting >= warmupCount && countingTotal > 0) {
            const remaining = Math.max(0, countingTotal - sentCounting);
            const remainingSec = emaSecPerLine * remaining;
            showEtaPill?.('ETA: ' + formatETA(remainingSec), 'warn');
          } else {
            showEtaPill?.(`ETA: stabilising… (${sentCounting}/${warmupCount})`, 'warn');
          }
        }
      } else {
        // While still in setup/heating, keep the pill clear and honest
        if (!startedETA) showEtaPill?.('ETA: heating/preamble…', 'warn');
      }

      // Small pacing delay to avoid flooding slower boards
      await new Promise(r => setTimeout(r, 10));
    }

    if (cancelSend) cancelSend.disabled = true;

    if (cancelStream) {
      if (sendStatus) sendStatus.textContent = 'Cancelled';
      showEtaPill?.('ETA: —', 'bad');
      beep?.('cancel');
      printerBeep?.('cancel');
      exitPrintScreen?.(0, { tellHost: false });
      hideEtaPill?.();
      clearAllPidUi?.();
    } else {
      if (sendProgress) sendProgress.style.width = '100%';
      if (sendStatus)   sendStatus.textContent = 'Done';
      showEtaPill?.('Complete', 'ok');
      beep?.('done');
      printerBeep?.('done');
      exitPrintScreen?.(0, { tellHost: false });
    }

    setTimeout(() => hideEtaPill?.(), 2500);
  } catch (err) {
    if (cancelSend) cancelSend.disabled = true;
    if (sendStatus) sendStatus.textContent = 'Error during send';
    showEtaPill?.('Error', 'bad');
    beep?.('error');
    printerBeep?.('cancel');
    logMsg?.('❌ Send error: ' + (err?.message || err));
    setTimeout(() => hideEtaPill?.(), 2500);
  }
}
  
//Quick helpers
async function coolToIdle(opts = {}) {
  const { force = false, postSync = false } = opts;

  try {
    // If we're calling right after G29 T, let firmware settle
    if (postSync) {
      await sendCmd('M400');              // wait for all moves/ISR queue
      await waitForOk().catch(()=>{});
      await sleep(150);                   // tiny UI/EEPROM settle
    }

    // Don’t spam heat-off if already “off” unless forced
    const wantHot = force || ((temps.hotTarget ?? 0) > 0);
    const wantBed = force || ((temps.bedTarget ?? 0) > 0);

    if (wantHot) { await sendCmd('M104 S0'); await waitForOk().catch(()=>{}); }
    if (wantBed) { await sendCmd('M140 S0'); await waitForOk().catch(()=>{}); }
  } finally {
    clearAllPidUi();
    setActivity('Temps set to 0', 'ok');
    updateLastUpdated();
  }
}

async function markHomedAfterG28() {
  await sendCmd('G28');
  await waitForOk().catch(()=>{});
  isHomed = true;

  // Ask for current pos and learn the signature
  await sendCmd('M114', true);
  await waitForOk().catch(()=>{});
}

/* =========================================================
   9) EVENT LISTENERS
========================================================= */

primeLine.addEventListener('click', runPrimeLine);

// --- Unlock button: remove any old listeners, bind once ---
(function bindUnlockClean(){
  const oldBtn = document.getElementById('unlockTempsBtn'); // correct id
  if (!oldBtn) return;
  const newBtn = oldBtn.cloneNode(true);          // drop any old listeners
  oldBtn.parentNode.replaceChild(newBtn, oldBtn);

  newBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
    setHeaterUnlocked(!heaterUnlocked);           // ← this alone
  });
})();





//Connection
connectBtn.addEventListener('click', () => { trace('Connect button'); connectPrinter(); });

disconnectBtn.addEventListener('click', () => {
  trace('Disconnect button');
  disconnectPrinter('user');
});

//Leveling
exportMeshBtn.addEventListener('click', () => {
  const fromInputs = collectMeshFromInputs();
  if (fromInputs) {
    exportMeshAsFile(fromInputs, 'current');
    return;
  }
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  const latest = hist.at(-1);
  if (latest && Array.isArray(latest) && latest.length === 4) {
    exportMeshAsFile(latest, 'latest');
  } else {
    alert('⚠️ No mesh available to export yet.');
  }
});

resetBtn.addEventListener('click', () => {
if (safeConfirm('Reset all saved data?')) { localStorage.clear(); location.reload(); }
});

readMeshBtn.addEventListener('click', homeAndProbe);

document.getElementById('levelForm').addEventListener('submit', (e) => {
  e.preventDefault();
  const mesh = [];
  for (let y=0; y<4; y++) {
    const row = [];
    for (let x=0; x<4; x++) {
      const v = parseFloat(document.getElementById(`cell-${y}-${x}`).value);
      row.push(isNaN(v) ? 0 : v);
    }
    mesh.push(row);
  }
  saveMeshLS(mesh);
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  alert('✅ Round submitted!');
});

//Manual
sendCmdBtn.addEventListener('click', sendManual);

manualCmd.addEventListener('input', () => { captureMode = null; });

clearLogBtn.addEventListener('click', () => { printerLog.textContent = ''; });

//Temps and fan
hotendApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(3000, parseInt(hotendSet.value) || 0)); // clamp silly inputs
  if (!guardHeaterSet('hotend', val, 'Hotend Set')) return;
  sendCmd(`M104 S${val}`);
});

hotendOff.addEventListener('click',   () => sendCmd('M104 S0'));

bedApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(3000, parseInt(bedSet.value) || 0));
  if (!guardHeaterSet('bed', val, 'Bed Set')) return;
  sendCmd(`M140 S${val}`);
});

bedOff.addEventListener('click',      () => sendCmd('M140 S0'));

fanSlider.addEventListener('input',   () => { fanVal.textContent = fanSlider.value; });

fanApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(255, parseInt(fanSlider.value)||0));
  live.lastFan255 = val;                  // ← add this
  sendCmd(`M106 S${val}`);
});

fanOff.addEventListener('click', () => {
  live.lastFan255 = 0;                    // ← add this
  sendCmd('M107');
});

//Movement
homeAll.addEventListener('click', async () => {
  try {
    setActivity('Homing…', 'warn');
    await sendCmd('G28'); await waitForOk().catch(()=>{});
    isHomed = true; // <-- mark homed
    await sendCmd('M104 S0'); await waitForOk().catch(()=>{});
    await sendCmd('M140 S0'); await waitForOk().catch(()=>{});
    setActivity('Homed & cooled', 'ok');
    updateLastUpdated();
  } catch (e) {
    setActivity('Home failed', 'bad');
    logMsg('⚠️ Home error: ' + (e?.message || e));
  }
});

disableMotors.addEventListener('click', () => sendCmd('M84'));

xMinus.addEventListener('click', () => jog('X', -1));

xPlus .addEventListener('click', () => jog('X', +1));

yMinus.addEventListener('click', () => jog('Y', -1));

yPlus .addEventListener('click', () => jog('Y', +1));

zMinus.addEventListener('click', () => jog('Z', -1));

zPlus .addEventListener('click', () => jog('Z', +1));

parkHead.addEventListener('click', () =>sendCmdsSequential('G90', 'G1 X0 Y0 Z10 F3000')
);

//EEPROM and Diag


// Maintenance
preheatPLA .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S200', 'M140 S60');
});
preheatPETG.addEventListener('click', async () => {
  await sendCmdsSequential('M104 S240', 'M140 S80');
});
preheatABS .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S250', 'M140 S100');
});
cooldown   .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S0', 'M140 S0');
});

loadFil.addEventListener('click', async () => {
  const mm   = parseFloat(safePrompt('How many mm to LOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(safePrompt('Hotend temp for load (°C)?', '200'));
if (!guardHeaterSet('hotend', temp, 'Filament Load')) return;
  if (!Number.isFinite(temp) || temp <= 0) return;
  try {
    await sendCmd('G28');                    await waitForOk().catch(()=>{});
    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});
    await waitForHotend(temp, 1.0).catch(()=>{});
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{});
    await sendCmd('M82');                    await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});
    sendStatus.textContent = 'Filament load complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Load failed';
    console.error(e);
  }
});

unloadFil.addEventListener('click', async () => {
  const mm   = parseFloat(safePrompt('How many mm to UNLOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(safePrompt('Hotend temp for unload (°C)?', '200'));
if (!guardHeaterSet('hotend', temp, 'Filament Unload')) return;
  if (!Number.isFinite(temp) || temp <= 0) return;
  try {
    await sendCmd('G28');                    await waitForOk().catch(()=>{});
    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});
    await waitForHotend(temp, 1.0).catch(()=>{});
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E-${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{});
    await sendCmd('M82');                    await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});
    sendStatus.textContent = 'Filament unload complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Unload failed';
    console.error(e);
  }
});

//Sender
gcodeFile.addEventListener('change', () => {
  const connected = (connKind === 'virtual') || !!writer;
  sendGcode.disabled = !gcodeFile.files.length || !connected;
});

sendGcode.addEventListener('click', (e) => {
  e.preventDefault();
  e.stopImmediatePropagation();

  const file = gcodeFile?.files?.[0];
  if (!file) { gcodeFile.click(); return; }

  if (sessionStorage.getItem('skipPreflight') === '1') {
    streamGcode(file);
    return;
  }
  openPreflight(file);
});

cancelSend.addEventListener('click', async () => {
  if (sendStatus) sendStatus.textContent = 'Cancelling…';
  cancelSend.disabled = true;
  showEtaPill('Cancelling…', 'warn');

  cancelStream = true;
  _rejectAllOk(new Error('Cancelled'));

  await sendCmd('M104 S0'); await waitForOk().catch(() => {});
  await sendCmd('M140 S0'); await waitForOk().catch(() => {});
  await sendCmd('G90');     await waitForOk().catch(() => {});
  await sendCmd('G1 X0 Y0 Z10 F3000'); await waitForOk().catch(() => {});
  exitPrintScreen(0, { tellHost: false }); 
  hideEtaPill();
  clearAllPidUi();

  cancelStream = false; // ← reset so future macros work
});


//PID Tab
bedPidBtn.addEventListener('click', runBedPID);

hotendPidBtn.addEventListener('click', runHotendPID);

//APP lifecycle
window.addEventListener('unload', () => {
  if (postPrintTimer) clearTimeout(postPrintTimer);
});

document.addEventListener('DOMContentLoaded', () => {
  const aboutBtn = document.querySelector('#tabButtons button[data-tab="aboutTab"]');
  const allTabBtns = Array.from(document.querySelectorAll('#tabButtons button'));


  if (!aboutBtn || !eeOverlay || !eeModal || !eeClose || !eeBody) {
    console.warn('[EE] Modal wiring skipped (missing elements).');
    return;
  }

  // Any other tab click resets
  allTabBtns.forEach(btn => {
    if (btn !== aboutBtn) btn.addEventListener('click', resetStreak);
  });

  aboutBtn.addEventListener('click', () => {
    streak += 1;
    if (streak >= 5) {
      openEasterEgg();
      streak = 0;
    }
  });

    allTabBtns.forEach(btn => {
    if (btn !== aboutBtn) btn.addEventListener('click', () => { streak = 0; });
  });

  // Close handlers
  eeClose.addEventListener('click', closeEasterEgg);
  eeOverlay.addEventListener('click', closeEasterEgg);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && eeModal.style.display !== 'none') closeEasterEgg();
  });
});


const preBody  = document.getElementById('preBody');
const preStart = document.getElementById('preStart');
if (preBody && preStart) {
  preBody.addEventListener('change', (e) => {
    if (!(e.target instanceof HTMLInputElement) || !e.target.classList.contains('preChk')) return;
    const all = Array.from(preBody.querySelectorAll('.preChk')).every(c => c.checked);
    preStart.disabled = !all;
  });
}


//Selectors and toggles
if (levelPrinterSelect) {
  const saved = localStorage.getItem('levelPrinterChoice');
  if (saved) levelPrinterSelect.value = saved;

  levelPrinterSelect.addEventListener('change', () => {
    localStorage.setItem('levelPrinterChoice', levelPrinterSelect.value);
    updateLevelView();
  });
}

if (debugToggle) {
  debugToggle.checked = !!debugMode;
  debugToggle.addEventListener('change', () => {
    debugMode = debugToggle.checked;
    localStorage.setItem('debugMode', JSON.stringify(debugMode));
  });
}

if (virtualToggle) {
  virtualMode = JSON.parse(localStorage.getItem('virtualMode') || 'false');
  virtualToggle.checked = virtualMode;
  virtualToggle.addEventListener('change', () => {
    virtualMode = virtualToggle.checked;
    localStorage.setItem('virtualMode', JSON.stringify(virtualMode));
  });
}

(function(){
  // Build modal once
  let overlay=document.getElementById('helpOverlay');
  if(!overlay){overlay=document.createElement('div');overlay.id='helpOverlay';document.body.appendChild(overlay);}
  let modal=document.getElementById('helpModal');
  if(!modal){
    modal=document.createElement('div');modal.id='helpModal';modal.setAttribute('role','dialog');modal.setAttribute('aria-modal','true');
    modal.innerHTML=`
      <div id="helpCard">
        <div id="helpHead">
          <h3 id="helpTitle">Help</h3>
          <div id="helpActions">
            <input id="helpSearch" type="search" placeholder="Search in help…">
            <button id="helpClose" type="button" aria-label="Close">Close</button>
          </div>
        </div>
        <div id="helpBodyWrap"><div id="helpBody" class="help-body"></div></div>
      </div>`;
    document.body.appendChild(modal);
  }

  const titleEl  = document.getElementById('helpTitle');
  const searchEl = document.getElementById('helpSearch');
  const closeBtn = document.getElementById('helpClose');
  const bodyEl   = document.getElementById('helpBody');

  // Mini Help engine
  const registry=new Map();
  const state={open:false, activeTab:'default', q:''};

  function register(id,{title,html}){ registry.set(id,{title,html,rawHtml:html}); }
  function setActiveTab(id){ state.activeTab = registry.has(id)?id:'default'; if(state.open) render(); }
  function highlight(html,q){ if(!q) return html;
    const esc=s=>s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
    return html.replace(new RegExp(`(${esc(q)})`,'gi'),'<mark>$1</mark>');
  }
  function render(){
    const page=registry.get(state.activeTab)||registry.get('default')||{title:'Help',html:'<p>No help yet.</p>'};
    titleEl.textContent=page.title;
    bodyEl.innerHTML = state.q?highlight(page.rawHtml||page.html,state.q):page.html;
  }

  function open(){ state.open=true; overlay.classList.add('open'); modal.classList.add('open'); try{searchEl.focus();}catch{}; render(); }
  function close(){ state.open=false; overlay.classList.remove('open'); modal.classList.remove('open'); }
  function toggle(){ state.open?close():open(); }

  window.Help={register,setActiveTab,open,close,toggle,setHTML:(id,title,html)=>{register(id,{title,html}); if(state.activeTab===id&&state.open) render();}};

  // Close wiring (capture so nothing blocks it)
  overlay.addEventListener('click',e=>{e.stopImmediatePropagation();close();},{capture:true});
  closeBtn.addEventListener('click',e=>{e.preventDefault();e.stopImmediatePropagation();close();},{capture:true});
  document.addEventListener('keydown',e=>{ if(e.key==='Escape'&&modal.classList.contains('open')){e.stopImmediatePropagation();close();}}, {capture:true});
  searchEl.addEventListener('input',()=>{ state.q=searchEl.value.trim(); render(); });

  // Keep Help button from switching tabs
  (function isolateHelpButton(){
    const bar=document.getElementById('tabButtons');
    const help=document.getElementById('helpToggleBtn');
    if(!bar||!help) return;
    bar.addEventListener('click',(e)=>{ if(e.target===help||help.contains(e.target)){ e.stopImmediatePropagation(); e.preventDefault(); toggle(); }}, true);
    help.addEventListener('click',(e)=>{ e.stopPropagation(); e.preventDefault(); toggle(); });
  })();

  // Auto-sync to your active tab
  (function wireTabs(){
    const bar=document.getElementById('tabButtons');
    if(!bar) return;
    const tabs=[...bar.querySelectorAll('button[data-tab]')];
    function current(){ const btn=tabs.find(b=>b.classList.contains('active'))||tabs[0]; return btn?.dataset.tab||'connectTab'; }
    setActiveTab(current());
    tabs.forEach(b=>b.addEventListener('click',()=>requestAnimationFrame(()=>setActiveTab(current()))));
    new MutationObserver(()=>setActiveTab(current())).observe(bar,{attributes:true,subtree:true,attributeFilter:['class']});
  })();

  // Default + tab pages
  register('default',{title:'Help',html:'<p>Select a tab to see contextual help. Toggle with <kbd>F1</kbd> or <kbd>?</kbd>.</p>'});
// 1) Connection & Log
Help.register('connectTab', {
  title: 'Connection & Log',
  html: `
    <p>Connect to your printer (USB/Serial or Web Serial) and monitor live firmware output.</p>

    <h4>Workflow</h4>
    <ol>
      <li>Select <strong>Port</strong> → pick your device (often “USB-Serial”, “CH340”, “Silicon Labs”).</li>
      <li>Pick <strong>Baud</strong> (115200 or 250000 are most common).</li>
      <li>Click <strong>Connect</strong>. You should see a banner line (e.g., Marlin/Klipper) in the log.</li>
      <li>Use the <strong>Manual G-code</strong> box to send quick commands (e.g., <code>M115</code>, <code>M503</code>).</li>
    </ol>

    <h4>Useful Commands</h4>
    <ul>
      <li><code>M115</code> — firmware info; <code>M503</code> — dump settings; <code>M112</code> — emergency stop.</li>
      <li><code>G28</code> — home axes; <code>M105</code> — read temps (polled periodically by the UI).</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>If connect fails: try a different cable/port, or close other apps that hold the port (e.g., PrusaSlicer/OctoPrint).</li>
      <li>Toggle <strong>Echo/Debug</strong> in the UI to see more parsing detail.</li>
      <li>“Virtual printer” mode lets you test the UI without hardware.</li>
    </ul>
  `
});

// 2) Leveling
Help.register('levelTab', {
  title: 'Leveling',
  html: `
    <p>Probe a mesh, evaluate flatness, and optionally get screw-turn guidance.</p>

    <h4>Before You Start</h4>
    <ul>
      <li>Heat the bed/nozzle to normal print temps (flatness changes with heat).</li>
      <li>Make sure the nozzle is clean; remove filament blobs.</li>
    </ul>

    <h4>Procedure</h4>
    <ol>
      <li><strong>Home</strong> (<code>G28</code>).</li>
      <li><strong>Probe mesh</strong> (e.g., <code>G29 T</code> in Marlin) via the UI’s button.</li>
      <li>Inspect the heatmap: aim for range ≤ <code>0.02–0.05 mm</code> for best first-layers.</li>
      <li>Use the <strong>screw hints</strong> panel (if your bed has manual screws). Turn little-by-little, then re-probe.</li>
    </ol>

    <h4>Common Tweaks</h4>
    <ul>
      <li><code>M851 Z</code> — set Z-offset; <code>M500</code> — save.</li>
      <li>On printers with mesh leveling stored in EEPROM: <code>M420 S1</code> enables saved mesh after homing.</li>
    </ul>

    <h4>Troubleshooting</h4>
    <ul>
      <li>Probe crashes or misses points → check Z-min/probe wiring and homing direction.</li>
      <li>Mesh looks “tilted” → ensure X/Y gantry is square and belts are tensioned.</li>
    </ul>
  `
});

// 3) PID Tuning
Help.register('pidTab', {
  title: 'PID Tuning',
  html: `
    <p>Autotune heaters to reduce overshoot and oscillation.</p>

    <h4>Quick Start</h4>
    <ol>
      <li>Hotend autotune: <code>M303 E0 S200 C8</code> (adjust temp for your material).</li>
      <li>Bed autotune: <code>M303 E-1 S60 C8</code>.</li>
      <li>Apply results with <code>M301</code> (hotend) / <code>M304</code> (bed), then <code>M500</code> to save.</li>
    </ol>

    <h4>Targets</h4>
    <ul>
      <li>PLA ~200 °C, PETG ~235 °C, ABS ~245 °C (choose your typical print temp).</li>
      <li>Bed: PLA ~60 °C, PETG ~80 °C, ABS ~100 °C.</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>Run fans as you would during printing to get accurate results.</li>
      <li>Verify by plotting a small print: overshoot ±3–5 °C or less is fine.</li>
    </ul>
  `
});

// 4) Temperature & Fan
Help.register('tempTab', {
  title: 'Temperature & Fan',
  html: `
    <p>Set targets and monitor live temperatures & fans.</p>

    <h4>Controls</h4>
    <ul>
      <li>Hotend: <code>M104 S&lt;temp&gt;</code> · Bed: <code>M140 S&lt;temp&gt;</code> · Cooldown: set S0 or use the UI’s Off buttons.</li>
      <li>Part fan: <code>M106 S0–255</code>, Off: <code>M107</code>. Some firmwares use 0–100% scales in UI; values are converted.</li>
    </ul>

    <h4>Graph</h4>
    <ul>
      <li>Temp polling via <code>M105</code> (interval shown near the chart).</li>
      <li>Hover for exact readings; bed/nozzle lines match your theme.</li>
    </ul>

    <h4>Safety</h4>
    <ul>
      <li>Never leave heaters unattended. If temps run away, hit <strong>Emergency Stop</strong> (<code>M112</code>).</li>
    </ul>
  `
});

// 5) Movement & Axes
Help.register('moveTab', {
  title: 'Movement & Axes',
  html: `
    <p>Home, jog, and park axes for setup and maintenance.</p>

    <h4>Basics</h4>
    <ul>
      <li><strong>Home</strong> all or per-axis (<code>G28</code>).</li>
      <li><strong>Jog</strong> X/Y/Z by 0.1/1/10 mm; adjust feedrate if offered.</li>
      <li><strong>Park</strong> positions the tool for easy access (configurable in UI).</li>
    </ul>

    <h4>Hand Moves</h4>
    <ul>
      <li><code>M84</code> disables steppers (careful: the tool can fall if Z isn’t supported).</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>If moves are inverted, check motor direction in firmware or swap connectors (power off!).</li>
      <li>Binding or missed steps → check belt tension, pulley grub screws, and rails.</li>
    </ul>
  `
});

// 6) EEPROM / Config
Help.register('eepromTab', {
  title: 'EEPROM / Config',
  html: `
    <p>View and edit key motion/thermal settings. Parse <code>M503</code> output into readable fields.</p>

    <h4>Key Parameters</h4>
    <ul>
      <li><strong>Steps/mm</strong> <code>M92</code> · <strong>Max feedrate</strong> <code>M203</code> · <strong>Accel</strong> <code>M201/M204</code>.</li>
      <li><strong>PID</strong> hotend <code>M301</code> · bed <code>M304</code> · <strong>Z-probe offset</strong> <code>M851</code>.</li>
      <li><strong>Retract</strong> <code>M207</code> · <strong>Recover</strong> <code>M208</code> · <strong>Auto-retract</strong> <code>M209</code>.</li>
    </ul>

    <h4>Workflow</h4>
    <ol>
      <li>Click <strong>Read</strong> to fetch current values (<code>M503</code>).</li>
      <li>Adjust fields; the UI will generate the right commands.</li>
      <li>Click <strong>Apply</strong> to send, then <strong>Save</strong> (<code>M500</code>).</li>
    </ol>

    <h4>Notes</h4>
    <ul>
      <li>Some boards/firmwares disable EEPROM — saving may be unavailable.</li>
      <li>Always save your current config before big changes (export button in UI).</li>
    </ul>
  `
});

// 7) Maintenance
Help.register('maintTab', {
  title: 'Maintenance',
  html: `
    <p>One-click macros and a simple logbook to track upkeep.</p>

    <h4>Macros</h4>
    <ul>
      <li><strong>Preheat</strong> PLA/PETG/ABS: sets bed/nozzle presets and waits.</li>
      <li><strong>Cooldown</strong>: turns heaters off and fans as configured.</li>
      <li><strong>Load/Unload</strong>: heats and runs controlled extrusions/retractions.</li>
    </ul>

    <h4>Logbook</h4>
    <ul>
      <li>Record nozzle swaps, lubrication, belt tensioning, cleanings.</li>
      <li>Export or clear entries as needed.</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>Run a purge after swapping materials (esp. PLA ↔ PETG/ABS).</li>
      <li>Lubricate Z lead screws lightly; avoid belts and idlers.</li>
    </ul>
  `
});

// 8) Filament
Help.register('filamentTab', {
  title: 'Filament',
  html: `
    <p>Track spools, presets, and estimated remaining material.</p>

    <h4>Spools</h4>
    <ul>
      <li>Store brand, material, color, diameter, density, tare, capacity, and price.</li>
      <li>Mark an <strong>active spool</strong> and deduct usage after prints.</li>
      <li>Quick-filter by material or “With remaining only”.</li>
    </ul>

    <h4>Presets</h4>
    <ul>
      <li>Per-material default temps (nozzle/bed) and fan profiles.</li>
    </ul>

    <h4>Labels</h4>
    <ul>
      <li>Generate a simple shelf label with key info and QR if available.</li>
    </ul>
  `
});

// 9) Diagnostics
Help.register('diagTab', {
  title: 'Diagnostics',
  html: `
    <p>Inspect firmware and driver status.</p>

    <h4>Quick Commands</h4>
    <ul>
      <li><code>M115</code> — firmware banner, capabilities.</li>
      <li><code>M122</code> — TMC driver report (if supported): RMS current, microsteps, stealth/spread, errors.</li>
    </ul>

    <h4>Checks</h4>
    <ul>
      <li>Endstops/probe: trigger by hand and read status.</li>
      <li>Thermistors: look for unrealistic temps or “def”/“open” errors.</li>
    </ul>

    <h4>Troubleshooting</h4>
    <ul>
      <li>Skipped steps → verify motor current, belt tension, pulley grub screws.</li>
      <li>Thermal runaway → PID tune, inspect wiring, ensure fans work.</li>
    </ul>
  `
});

// 10) G-code Sender
Help.register('senderTab', {
  title: 'G-code Sender',
  html: `
    <p>Send single commands or stream full files with a live 2D preview.</p>

    <h4>Pre-flight</h4>
    <ul>
      <li>Check temps and homing; the UI can enforce guardrails (e.g., refuse to print cold/unhomed).</li>
      <li>Optional: run a skirt or prime line macro.</li>
    </ul>

    <h4>While Printing</h4>
    <ul>
      <li>Preview supports <code>G0/G1</code>, absolute/relative (<code>G90/G91</code>), extrusion modes (<code>M82/M83</code>), and common layer comments.</li>
      <li>Scrub layers; toggle travel (dashed) to declutter.</li>
      <li>Live highlight follows the current layer via <code>GCodePreview.updateCurrentZ(z)</code> or <code>updateByGcodeLine(n)</code>.</li>
    </ul>

    <h4>Recovery</h4>
    <ul>
      <li>Pause/Resume sends <code>M25/M24</code> (or equivalent); consult firmware if different.</li>
      <li>Emergency stop: <code>M112</code>.</li>
    </ul>
  `
});

  // Keyboard toggle (F1 / ?)
  document.addEventListener('keydown',(e)=>{
    if(e.key==='F1' || e.key==='?' || (e.shiftKey && e.key==='/')){ e.preventDefault(); toggle(); }
  });
})();

/* =========================================================
   10) INIT (runs once)
========================================================= */
(function init() {
  const mesh = loadMeshLS();
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  setConnected(false);
  setOfflinePills();
  updateLevelView();
  initPrinterName();
  updateUnlockUi();
})();
</script>
</body>
</html>
