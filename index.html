<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Printer Utils</title>
<meta name="author" content="issypup">
<meta name="date" content="2025-08-10">
<style>
  :root { --bar-h: 42px; }
  body {
    font-family: sans-serif;
    padding: calc(var(--bar-h) + 12px) 12px 56px;
    background: #f4f4f4;
  }
  h1, h2 { margin-top: 1rem; }
  table { border-collapse: collapse; margin-top: 0.5rem; }
  td, th { border: 1px solid #ccc; padding: 0.4rem; text-align: center; }
  input[type="number"], input[type="text"] { width: 100px; }
  button { padding: 0.45rem 0.9rem; margin: 0.25rem 0.25rem 0.25rem 0; cursor: pointer; }
  .tighten { background: #ffe0e0; }
  .loosen  { background: #e0f0ff; }
  .na      { background: #eaeaea; }
  .gap { border: none; background: transparent; color: #888; font-weight: bold; }
  #screwMap td { width: 110px; height: 60px; vertical-align: top; font-size: 0.85em; }

  /* Status bar (always visible) */
  #statusBar {
    position: fixed; top: 0; left: 0; right: 0; height: var(--bar-h);
    background: #222; color: #fff; display: flex; align-items: center;
    gap: 12px; padding: 0 12px; z-index: 9999; font-weight: 600;
  }
#statusBar .pill { 
  /* background:#444; */  /* remove this line if needed */
  transition: background-color 200ms ease, filter 200ms ease, transform 200ms ease;
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 10px; border-radius:999px; font-weight:600;
}

/* state colors – more specific than #statusBar .pill */
#statusBar .pill.idle    { background:#555; }     /* no target / idle */
#statusBar .pill.ready   { background:#2ecc71; }  /* green, stable */
#statusBar .pill.heating { background:#e74c3c; }  /* red, heating */
#statusBar .pill.cooling { background:#3498db; }  /* blue, cooling */
#statusBar .pill.offline { background:#444; color:#fff; }

/* pulse effect (used for heating/cooling) */
.pulse { animation: pillPulse 1.0s ease-in-out infinite; }
@keyframes pillPulse {
  0%   { transform:none; filter:brightness(100%); }
  50%  { transform:scale(1.05); filter:brightness(115%); }
  100% { transform:none; filter:brightness(100%); }
}

/* keep hotend/bed pills nicely spaced */
#temps { display: inline-flex; gap: 8px; }

  #statusBar .ok    { background: #2a7; }
  #statusBar .warn  { background: #f39c12; }
  #statusBar .bad   { background: #c0392b; }

  /* Tabs */
  #tabButtons { display:flex; flex-wrap: wrap; gap:6px; margin: 8px 0 4px; }
  #tabButtons button {
    padding: 0.45rem 1rem; cursor: pointer; background: #eee; border: 1px solid #ccc;
  }
  #tabButtons button.active { background: #ddd; font-weight: bold; }
  .tabContent { display: none; }
  .tabContent.active { display: block; }

  /* Controls rows inside tabs */
  .tabControls { display:flex; flex-wrap:wrap; gap:8px; margin: 8px 0 8px; align-items: center; }

  /* Printer log */
  #printerLog {
    background:#111; color:#ddd; border:1px solid #333;
    height: 220px; overflow:auto; padding:8px; white-space:pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    border-radius: 6px;
  }

#printerName.editable {
  cursor: pointer;
}
#printerName.editable:hover {
  text-decoration: underline;
}

  /* Footer status */
  #footerStatus {
    position: fixed; bottom: 0; left: 0; right: 0;
    background: #222; color: #fff; padding: 6px 10px;
    display:flex; justify-content: space-between; font-size: 0.9em;
  }

#aboutTab .aboutCard {
  background: #fff;
  border: 1px solid #ddd;
  padding: 16px 18px;
  border-radius: 8px;
  max-width: 560px;
  margin: 20px auto;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

#aboutTab .aboutCard h2 {
  margin: 0 0 10px;
  font-size: 1.3em;
  color: #333;
  border-bottom: 2px solid #eee;
  padding-bottom: 6px;
}

#aboutTab .aboutCard p { margin: 10px 0 0; color: #555; }

#aboutTab .kv {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  margin-top: 8px;
  font-size: 0.95em;
}
#aboutTab .kv span:first-child { color: #666; }
#aboutTab .kv span:last-child  { font-weight: 600; color: #111; }

  /* Small UI helpers */
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .col { display:flex; flex-direction:column; gap:6px; }
  .box { background:#fff; border:1px solid #ddd; padding:8px; border-radius:6px; }
  .label { font-weight:600; }
  .muted { color:#666; font-size:0.9em; }
  .widen { width: 220px; }
  .progress { height: 10px; background:#ddd; border-radius:999px; overflow:hidden; width:280px; }
  .progress > div { height:100%; background:#2a7; width:0%; }

  /* EE Modal */
#eeOverlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 10000;
}

#eeModal {
  position: fixed; inset: 0;
  display: none;           /* toggled by JS */
  place-items: center;     /* grid centering */
  z-index: 10001;
}

#eeCard {
  width: min(720px, 92vw);
  max-height: 80vh;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.25);
  display: grid;
  grid-template-rows: auto 1fr;
}

#eeHeader {
  display: flex; align-items: center; justify-content: space-between;
  gap: 12px;
  padding: 12px 14px;
  border-bottom: 1px solid #eee;
}

#eeBody {
  padding: 14px 16px;
  white-space: pre-wrap;   /* preserve line breaks */
  overflow: auto;
  line-height: 1.35;
}

#eeClose {
  background: #eee; border: 1px solid #ccc;
  padding: 6px 10px; border-radius: 8px; cursor: pointer;
}
#eeClose:hover { background:#e5e5e5; }

</style>
</head>
<body>

<!-- Global Status Bar -->
<div id="statusBar">
  <span id="printerName" class="editable">PRINTER</span>
  <span id="connBadge" class="pill bad">Disconnected</span>
  <span id="activityBadge" class="pill">Idle</span>
  <span id="lastUpdated" class="pill">Last updated: —</span>
<span id="temps">
  <span class="pill idle" id="topHotendPill">Hotend: <span id="topHotend">--°C</span></span>
  <span class="pill idle" id="topBedPill">Bed: <span id="topBed">--°C</span></span>
</span>
<span id="etaPill" class="pill" style="display:none;">ETA: —</span>
</div>

<h1>3D Printer Utils</h1>

<!-- Tabs -->
<div id="tabButtons">
  <button data-tab="connectTab" class="active">Connection & Log</button>
  <button data-tab="levelTab">Leveling</button>
  <button data-tab="pidTab">PID Tuning</button>
  <button data-tab="tempTab">Temperature & Fan</button>
  <button data-tab="moveTab">Movement & Axes</button>
  <button data-tab="eepromTab">EEPROM / Config</button>
  <button data-tab="maintTab">Maintenance</button>
  <button data-tab="diagTab">Diagnostics</button>
  <button data-tab="senderTab">G-code Sender</button>
  <button data-tab="aboutTab">About</button>
</div>

<!-- TAB 1: Connection & Log -->
<div id="connectTab" class="tabContent active">
  <div class="tabControls" id="printerNavConnect">
    <label style="margin-left:8px;">
  <input type="checkbox" id="debugToggle">
  Debug
</label>
<label style="margin-left:8px;">
  <input type="checkbox" id="virtualToggle">
  Virtual printer
</label>
    <button id="connectBtn">Connect</button>
    <button id="disconnectBtn" disabled>Disconnect</button>
    <input id="manualCmd" placeholder="Manual G-code (e.g., M503)" />
    <button id="sendCmdBtn" disabled>Send</button>
    <button id="clearLogBtn" disabled>Clear Log</button>
  </div>

  <h2>Printer Log</h2>
  <div id="printerLog" aria-live="polite"></div>
</div>

<!-- TAB 2: Leveling -->
<div id="levelTab" class="tabContent">
  <div class="tabControls" id="printerNavLevel">
    <button id="readMeshBtn" disabled>Read Mesh (G29 T)</button>
    <button id="reprobeBtn" disabled>Re-Probe (G28 → G29 → G29 T)</button>
    <button type="button" id="exportManualBtn">Export Manual Mesh</button>
    <button type="button" id="exportPrinterBtn">Export Last Printer Mesh</button>

    <!-- NEW: printer dropdown -->
    <label style="margin-left:auto">
      Printer:
      <select id="levelPrinterSelect">
        <option value="cr6se" selected>CR-6 SE</option>
        <option value="unsupported">Unsupported</option>
      </select>
    </label>
  </div>

  <!-- NEW: message for unsupported printers -->
  <div id="unsupportedMsg" class="box" style="display:none; max-width:560px">
    <strong>Printer unsupported.</strong>
    <div class="muted">Leveling helpers are currently only available for the CR-6 SE.</div>
  </div>

  <!-- Wrap all CR-6 SE specific UI so we can show/hide it easily -->
  <div id="cr6seLevelWrap">
    <!-- Mesh Form (manual + populated from printer) -->
    <form id="levelForm">
      <h2>Enter / View Mesh Readings</h2>
      <table><tbody id="meshInput"></tbody></table>
      <button type="submit">Submit Round</button>
      <button type="button" id="resetBtn">Reset Data</button>
    </form>

    <h2>Screw Suggestions</h2>
    <table>
      <thead>
        <tr><th>Screw</th><th>Avg (mm)</th><th>Action</th><th>Turn Strength</th></tr>
      </thead>
      <tbody id="screwTable"></tbody>
    </table>

    <h2>Screw Layout Map</h2>
    <table id="screwMap">
      <tr>
        <td id="A1"></td>
        <td class="gap">GAP</td>
        <td id="A2"></td>
        <td id="A3"></td>
      </tr>
      <tr>
        <td id="B1"></td>
        <td id="B2"></td>
        <td id="B3"></td>
        <td id="B4"></td>
      </tr>
      <tr>
        <td id="C1"></td>
        <td id="C2"></td>
        <td id="C3"></td>
        <td id="C4"></td>
      </tr>
    </table>
  </div>
</div>

<!-- TAB 3: PID Tuning -->
<div id="pidTab" class="tabContent">
  <div class="tabControls" id="printerNavPID">
    <button id="bedPidBtn"    disabled>PID Bed (M303 E-1)</button>
    <button id="hotendPidBtn" disabled>PID Nozzle (M303 E0)</button>
  </div>
  <p>Runs <code>M303</code> autotune with a temperature you choose. After it completes, send <code>M500</code> if your firmware needs it to save to EEPROM.</p>
</div>

<!-- TAB 4: Temperature & Fan -->
<div id="tempTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Hotend</div>
      <div>
        <input type="number" id="hotendSet" value="200" min="0" max="300" /> °C
        <button id="hotendApply" disabled>Set (M104)</button>
        <button id="hotendOff"   disabled>Off (M104 S0)</button>
      </div>
      <div class="muted" id="hotendNow">Current: —</div>
    </div>
    <div class="col">
      <div class="label">Bed</div>
      <div>
        <input type="number" id="bedSet" value="60" min="0" max="130" /> °C
        <button id="bedApply" disabled>Set (M140)</button>
        <button id="bedOff"   disabled>Off (M140 S0)</button>
      </div>
      <div class="muted" id="bedNow">Current: —</div>
    </div>
    <div class="col">
      <div class="label">Part Cooling Fan</div>
      <div>
        <input type="range" id="fanSlider" min="0" max="255" value="0" />
        <span id="fanVal">0</span>/255
      </div>
      <div>
        <button id="fanApply" disabled>Apply (M106)</button>
        <button id="fanOff"   disabled>Off (M107)</button>
      </div>
    </div>
  </div>
  <div class="row box">
    <div class="label">Live Temperatures</div>
    <div class="muted">Polled via M105 every 3s while connected</div>
  </div>
</div>

<!-- TAB 5: Movement & Axes -->
<div id="moveTab" class="tabContent">
  <div class="row box">
    <div>
      <span class="label">Step</span>
      <select id="jogStep">
        <option value="1">1 mm</option>
        <option value="5" selected>5 mm</option>
        <option value="10">10 mm</option>
      </select>
    </div>
    <div>
      <button id="homeAll" disabled>Home All (G28)</button>
      <button id="disableMotors" disabled>Disable Steppers (M84)</button>
    </div>
  </div>
  <div class="row box">
    <div class="col">
      <div class="label">Move X</div>
      <button id="xMinus" disabled>◀ X-</button>
      <button id="xPlus"  disabled>X+ ▶</button>
    </div>
    <div class="col">
      <div class="label">Move Y</div>
      <button id="yMinus" disabled>▼ Y-</button>
      <button id="yPlus"  disabled>▲ Y+</button>
    </div>
    <div class="col">
      <div class="label">Move Z</div>
      <button id="zMinus" disabled>Z-</button>
      <button id="zPlus"  disabled>Z+</button>
    </div>
    <div id="axisPositions">
  <div>X: <span id="posX">—</span></div>
  <div>Y: <span id="posY">—</span></div>
  <div>Z: <span id="posZ">—</span></div>
</div>
  </div>
  <div class="row box">
    <button id="parkHead" disabled>Park Head (X0 Y0 Z10)</button>
  </div>
</div>

<!-- TAB 6: EEPROM / Config -->
<div id="eepromTab" class="tabContent">
  <div class="row box">
    <button id="readCfg" disabled>Read Config (M503)</button>
    <button id="saveCfg" disabled>Save (M500)</button>
    <!-- <button id="resetCfg" disabled>Factory Reset (M502)</button>-->
  </div>
  <textarea id="configBox" class="widen" rows="14" placeholder="Printer configuration will appear here…"></textarea>
</div>

<!-- TAB 7: Maintenance -->
<div id="maintTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Preheat</div>
      <button id="preheatPLA"  disabled>PLA (200/60)</button>
      <button id="preheatPETG" disabled>PETG (240/80)</button>
      <button id="preheatABS"  disabled>ABS (250/100)</button>
    </div>
    <div class="col">
      <div class="label">Cool Down</div>
      <button id="cooldown" disabled>Cool Down (M104 S0; M140 S0)</button>
    </div>
    <div class="col">
      <div class="label">Filament</div>
      <button id="loadFil"  disabled>Load (200°C)</button>
      <button id="unloadFil" disabled>Unload (200°C)</button>
    </div>
  </div>
</div>

<!-- TAB 8: Diagnostics -->
<div id="diagTab" class="tabContent">
  <div class="row box">
    <button id="fwInfo" disabled>Firmware Info (M115)</button>
    <button id="tmcDiag" disabled>TMC Diagnostics (M122)</button>
  </div>
  <textarea id="diagBox" class="widen" rows="14" placeholder="Diagnostics output…"></textarea>
</div>

<!-- TAB 9: G-code Sender -->
<div id="senderTab" class="tabContent">
  <div class="row box">
    <input type="file" id="gcodeFile" accept=".gcode,.gco,.gc,.txt" />
    <button id="sendGcode" disabled>Send File</button>
    <button id="cancelSend" disabled>Cancel</button>
    <div class="progress"><div id="sendProgress"></div></div>
    <span id="sendStatus" class="muted">Idle</span>
    <span id="etaStatus" class="muted" style="margin-left:10px"></span>
  </div>
  <p class="muted">Sends the file line-by-line over serial. Comments/blank lines are skipped. This is best for short jobs, calibration, or macros.</p>
</div>

<!-- TAB 10: About -->
<div id="aboutTab" class="tabContent">
  <div class="aboutCard">
    <h2>About</h2>
    <div class="kv"><span>Author: issypup</span></div>
    <div class="kv"><span>Date: 10 August 2025</span></div>
    <p>This tool helps manage 3D printer tasks / maintenance from your browser, it needs a web serial capable browser</p>
  </div>
<!-- Easter Egg Modal -->
<div id="eeOverlay" aria-hidden="true" style="display:none"></div>
<div id="eeModal" role="dialog" aria-modal="true" aria-labelledby="eeTitle" style="display:none">
  <div id="eeCard">
    <div id="eeHeader">
      <h3 id="eeTitle">Still Printing — (Still Alive Parody)</h3>
      <button id="eeClose" type="button" aria-label="Close">Close</button>
    </div>
    <div id="eeBody"></div>
  </div>
</div>
</div>


<div id="footerStatus">
  <span id="lastCmd">Last Cmd: —</span>
  <span>GitHub Pages ready · LocalStorage only</span>
</div>

<script>
'use strict';

/* =========================================================
   1) DOM REFERENCES (all const)
========================================================= */
const debugToggle     = document.getElementById('debugToggle');

const mockMesh = [
  "Bed Topography Report:",
  "    0      1      2      3",
  "0  +0.025  +0.013  -0.002  -0.020",
  "1  +0.018  +0.005  -0.010  -0.022",
  "2  +0.030  +0.015  +0.003  -0.015",
  "3  +0.035  +0.020  +0.010  -0.012",
  "ok"
];

const vState = {
  hot: 25, hotTarget: null,
  bed: 25, bedTarget: null,
  x: 0, y: 0, z: 0
};

const posXEl          = document.getElementById('posX');
const posYEl          = document.getElementById('posY');
const posZEl          = document.getElementById('posZ');

const meshInput       = document.getElementById('meshInput');
const screwTable      = document.getElementById('screwTable');
const printerLog      = document.getElementById('printerLog');

const connectBtn      = document.getElementById('connectBtn');
const disconnectBtn   = document.getElementById('disconnectBtn');
const readMeshBtn     = document.getElementById('readMeshBtn');
const reprobeBtn      = document.getElementById('reprobeBtn');
const sendCmdBtn      = document.getElementById('sendCmdBtn');
const manualCmd       = document.getElementById('manualCmd');
const clearLogBtn     = document.getElementById('clearLogBtn');
const resetBtn        = document.getElementById('resetBtn');
const bedPidBtn       = document.getElementById('bedPidBtn');
const hotendPidBtn    = document.getElementById('hotendPidBtn');

const hotendSet       = document.getElementById('hotendSet');
const bedSet          = document.getElementById('bedSet');
const hotendApply     = document.getElementById('hotendApply');
const hotendOff       = document.getElementById('hotendOff');
const bedApply        = document.getElementById('bedApply');
const bedOff          = document.getElementById('bedOff');
const hotendNow       = document.getElementById('hotendNow');
const bedNow          = document.getElementById('bedNow');
const fanSlider       = document.getElementById('fanSlider');
const fanVal          = document.getElementById('fanVal');
const fanApply        = document.getElementById('fanApply');
const fanOff          = document.getElementById('fanOff');

const jogStep         = document.getElementById('jogStep');
const homeAll         = document.getElementById('homeAll');
const disableMotors   = document.getElementById('disableMotors');
const xMinus          = document.getElementById('xMinus');
const xPlus           = document.getElementById('xPlus');
const yMinus          = document.getElementById('yMinus');
const yPlus           = document.getElementById('yPlus');
const zMinus          = document.getElementById('zMinus');
const zPlus           = document.getElementById('zPlus');
const parkHead        = document.getElementById('parkHead');

const readCfg         = document.getElementById('readCfg');
const saveCfg         = document.getElementById('saveCfg');
const configBox       = document.getElementById('configBox');

const preheatPLA      = document.getElementById('preheatPLA');
const preheatPETG     = document.getElementById('preheatPETG');
const preheatABS      = document.getElementById('preheatABS');
const cooldown        = document.getElementById('cooldown');
const loadFil         = document.getElementById('loadFil');
const unloadFil       = document.getElementById('unloadFil');

const fwInfo          = document.getElementById('fwInfo');
const tmcDiag         = document.getElementById('tmcDiag');
const diagBox         = document.getElementById('diagBox');

const gcodeFile       = document.getElementById('gcodeFile');
const sendGcode       = document.getElementById('sendGcode');
const cancelSend      = document.getElementById('cancelSend');
const sendProgress    = document.getElementById('sendProgress');
const sendStatus      = document.getElementById('sendStatus');

const printerNameEl = document.getElementById('printerName');
const connBadge       = document.getElementById('connBadge');
const activityBadge   = document.getElementById('activityBadge');
const lastUpdated     = document.getElementById('lastUpdated');
const lastCmd         = document.getElementById('lastCmd');

const topHotendPill   = document.getElementById('topHotendPill');
const topBedPill      = document.getElementById('topBedPill');
const topHotendText   = document.getElementById('topHotend');
const topBedText      = document.getElementById('topBed');

const etaPill = document.getElementById('etaPill');

const levelPrinterSelect = document.getElementById('levelPrinterSelect');
const unsupportedMsg     = document.getElementById('unsupportedMsg');
const cr6seLevelWrap     = document.getElementById('cr6seLevelWrap');


/* =========================================================
   2) CONSTANTS (maps, regex, fixed values)
========================================================= */
const screwAffects = {
  A1: [[0,0],[0,1],[1,0],[1,1]],
  A2: [[0,1],[0,2],[1,1],[1,2]],
  A3: [[0,2],[0,3],[1,2],[1,3]],
  B1: [[1,0],[1,1],[2,0],[2,1]],
  B2: [[1,1],[1,2],[2,1],[2,2]],
  B3: [[1,2],[1,3],[2,2],[2,3]],
  B4: [[2,3],[1,3],[3,3]],
  C1: [[2,0],[2,1],[3,0],[3,1]],
  C2: [[2,1],[2,2],[3,1],[3,2]],
  C3: [[2,2],[2,3],[3,2],[3,3]],
  C4: [[3,3]]
};

const NOISY_REGEX = /^(?:echo:busy:\s*processing|\/\/action:.*|setnewscreen(?:\s*\([^)]*\))?:?.*|invoking handler for screen.*)/i;
const POS_REGEX   = /X:?\s*([+-]?\d*\.?\d+)\s+Y:?\s*([+-]?\d*\.?\d+)\s+Z:?\s*([+-]?\d*\.?\d+)/i;

const TEMP_T = /T\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;
const TEMP_B = /B\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;

const TELEMETRY_REGEX =
  /(?:\bT\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\bB\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\b@:\s*\d+)|(?:\bB@:\s*\d+)/i;

/* =========================================================
   3) STATE (all let)
========================================================= */
let debugMode      = JSON.parse(localStorage.getItem('debugMode') || 'false');

let meshScratch    = Array.from({ length: 4 }, () => Array(4).fill(null));
let temps          = { hot: null, hotTarget: null, bed: null, bedTarget: null };

let virtualMode = false;      
let vSimTimer = null;         

let connKind = 'none'; // 'none' | 'virtual' | 'real'
let isConnecting = false;
let isDisconnecting = false;

let port           = null;
let reader         = null;
let writer         = null;
let textDecoder    = null;
let reading        = false;
let tempTimer      = null;
let cancelStream   = false;
let captureMode    = null; // null | 'config' | 'diag'
let postPrintTimer = null;

let rxBuffer       = '';

let waitingResolvers = []; // (kept for compatibility)
let isBusyProcessing  = false;
let lastOkAt          = 0;

let pendingOk      = []; // queue for waitForOk()

/* =========================================================
   4) TABS BOOTSTRAP (runs once)
========================================================= */
(function initTabs(){
  document.querySelectorAll('#tabButtons button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const target = btn.getAttribute('data-tab');
      sessionStorage.setItem('currentTab', target);
      document.querySelectorAll('.tabContent').forEach(tab => {
        tab.classList.toggle('active', tab.id === target);
      });
    });
  });
  const savedTab = sessionStorage.getItem('currentTab');
  if (savedTab && document.getElementById(savedTab)) {
    document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
    document.querySelector(`#tabButtons button[data-tab="${savedTab}"]`)?.classList.add('active');
    document.querySelectorAll('.tabContent').forEach(tab => {
      tab.classList.toggle('active', tab.id === savedTab);
    });
  }
})();

/* =========================================================
   5) HELPERS (pure UI / formatting / state)
========================================================= */
if (debugToggle) {
  debugToggle.checked = !!debugMode;
  debugToggle.addEventListener('change', () => {
    debugMode = debugToggle.checked;
    localStorage.setItem('debugMode', JSON.stringify(debugMode));
  });
}

async function sendCmdsSequential(...cmds) {
  for (const c of cmds) {
    // Skip empty or whitespace-only commands
    if (!c || !c.trim()) continue;

    try {
      await sendCmd(c.trim());       // send the command
      await waitForOk();             // wait for ack from printer
    } catch (err) {
      console.error(`Error sending command "${c}":`, err);
      break; // stop sending further commands if one fails
    }
  }
}

async function sendCmdVirtual(cmd, quiet = false) {
  const line = String(cmd).trim();
  setLastCmd(line);
  setActivity('Sending…', 'warn');
  if (!quiet) logMsg('>> ' + line);

  const ok = () => {
    setActivity('Waiting…', 'warn');
    setTimeout(() => {
      // Suppress "ok" for quiet calls and specifically for M105 polling
      if (!quiet && !/^M105\b/i.test(line)) logMsg('ok');
      _resolveNextOk();
      updateLastUpdated();
      setActivity('Idle');
    }, 60);
  };

  const emitTelemetry = () => {
    const ht = Number.isFinite(vState.hotTarget) ? vState.hotTarget : 0;
    const bt = Number.isFinite(vState.bedTarget) ? vState.bedTarget : 0;
    const telem = `T:${vState.hot.toFixed(1)} / ${Math.round(ht)} B:${vState.bed.toFixed(1)} / ${Math.round(bt)} @:0 B@:0`;
    logMsg(telem);             // will be auto-suppressed by logMsg when Debug is off
    refreshVirtualTemps();     // update pills/panels immediately in virtual mode
  };

  switch (true) {
    // --- Telemetry ---
    case /^M105\b/i.test(line): {
      emitTelemetry();
      ok();
      break;
    }

    // --- Targets / basic controls ---
    case /^M104\b/i.test(line): {
      const s = line.match(/S\s*([0-9.]+)/i);
      vState.hotTarget = s ? parseFloat(s[1]) : null;
      refreshVirtualTemps();
      ok();
      break;
    }
    case /^M140\b/i.test(line): {
      const s = line.match(/S\s*([0-9.]+)/i);
      vState.bedTarget = s ? parseFloat(s[1]) : null;
      refreshVirtualTemps();
      ok();
      break;
    }
    case /^M106\b/i.test(line):
    case /^M107\b/i.test(line):
    case /^M400\b/i.test(line):
    case /^M82\b/i.test(line):
    case /^M83\b/i.test(line):
    case /^M500\b/i.test(line):
    case /^M84\b/i.test(line):
    case /^G90\b/i.test(line):
    case /^G91\b/i.test(line):
      ok(); break;

    // --- Homing / movement ---
    case /^G28\b/i.test(line): {
      vState.x = 0; vState.y = 0; vState.z = 0;
      logMsg('X:0.000 Y:0.000 Z:0.000');
      ok();
      break;
    }
    case /^G1\b/i.test(line): {
      const x = line.match(/X\s*([-+]?\d*\.?\d+)/i);
      const y = line.match(/Y\s*([-+]?\d*\.?\d+)/i);
      const z = line.match(/Z\s*([-+]?\d*\.?\d+)/i);
      if (x) vState.x = parseFloat(x[1]);
      if (y) vState.y = parseFloat(y[1]);
      if (z) vState.z = parseFloat(z[1]);
      logMsg(`X:${vState.x.toFixed(3)} Y:${vState.y.toFixed(3)} Z:${vState.z.toFixed(3)}`);
      ok();
      break;
    }

// --- Mesh report (G29 T) ---
case /^G29\b/i.test(line) && /\bT\b/i.test(line): {
  const hasMock = Array.isArray(mockMesh) && mockMesh.length > 0;

  if (hasMock) {
    for (const raw of mockMesh) {
      const l = String(raw).trim();
      if (!l || /^ok\b/i.test(l)) continue;   // avoid double "ok"
      logMsg(l);                               // show in log
      processMeshLineFromAnywhere(l);          // parse + update UI
    }
  } else {
    // fallback demo grid if no mockMesh provided
    const rows = [
      [ -0.120, -0.080, -0.035, -0.010 ],
      [ -0.075, -0.030,  0.005,  0.020 ],
      [ -0.040,  0.000,  0.030,  0.050 ],
      [ -0.010,  0.020,  0.055,  0.070 ],
    ];
    rows.forEach((vals, y) => {
      const l = `${y}  ${vals.map(v => (v >= 0 ? `+${v.toFixed(3)}` : v.toFixed(3))).join('  ')}`;
      logMsg(l);
      processMeshLineFromAnywhere(l);
    });
  }

  ok(); // resolve the command
  break;
}

    // --- Info / diagnostics ---
    case /^M115\b/i.test(line): {
      logMsg('FIRMWARE_NAME:VirtualPrinter PROTOCOL_VERSION:1.0 MACHINE_TYPE:Simulated EXTRUDER_COUNT:1');
      ok();
      break;
    }
    case /^M122\b/i.test(line): {
      logMsg('Driver diag (virtual): all good.');
      ok();
      break;
    }
    case /^M503\b/i.test(line): {
      logMsg('echo:  Steps per unit: M92 X80.00 Y80.00 Z400.00 E93.00');
      logMsg('echo:  Maximum feedrates: M203 X500.00 Y500.00 Z12.00 E25.00');
      ok();
      break;
    }

    // --- UI cancel hook ---
    case /^\/\/action:cancel/i.test(line): {
      logMsg('//action:cancel (virtual ack)');
      setTimeout(() => { _resolveNextOk(); updateLastUpdated(); }, 10);
      break;
    }

    // --- Fallback ---
    default:
      ok();
  }
}


function refreshVirtualTemps() {
  // Mirror vState → temps
  temps.hot = vState.hot;
  temps.hotTarget = vState.hotTarget;
  temps.bed = vState.bed;
  temps.bedTarget = vState.bedTarget;

  // Update the pills + panel (normally done by readLoop in real mode)
  setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget);
  setTempPill(topBedPill, topBedText, temps.bed ?? 0, temps.bedTarget);
  updateTempPanel();
}

function startVirtualSim() {
  if (vSimTimer) return;
  vSimTimer = setInterval(() => {
    const stepHot = 0.6, stepBed = 0.35;
    if (Number.isFinite(vState.hotTarget)) {
      const d = vState.hotTarget - vState.hot;
      vState.hot += Math.sign(d) * Math.min(Math.abs(d), stepHot);
    }
    if (Number.isFinite(vState.bedTarget)) {
      const d = vState.bedTarget - vState.bed;
      vState.bed += Math.sign(d) * Math.min(Math.abs(d), stepBed);
    }
    // keep temps in sync and refresh UI
    refreshVirtualTemps();
  }, 100);
}


function stopVirtualSim() {
  if (vSimTimer) { clearInterval(vSimTimer); vSimTimer = null; }
}

async function connectVirtual() {
  if (connKind === 'virtual') { logMsg('🧪 Already in virtual mode.'); return; }
  setConnected(true);
  setActivity('Connected (virtual)', 'ok');
  logMsg('🧪 Virtual printer connected.');
  startVirtualSim();
  startTempPolling();
  updateLastUpdated();
}

async function disconnectVirtual() {
  if (connKind !== 'virtual') { logMsg('🧪 Virtual not active.'); }
  stopVirtualSim();
  setConnected(false);
  setActivity('Disconnected', 'ok');
  logMsg('🔌 Virtual printer disconnected.');
}

function isNoisyLine(s){ return NOISY_REGEX.test(s); }
function isSetNewScreenLine(s){ return /^setnewscreen\b/i.test(s); }

function normalizeLine(s){
  s = s.replace(/\x1b\[[0-9;]*m/g, '').replace(/[\u0000-\u001F\u007F]/g, '');
  s = s.replace(/\bcontinueing\b/gi, 'continuing');
  return s;
}

function loadPrinterName() {
  const saved = localStorage.getItem('printerName');
  printerNameEl.textContent = saved || 'PRINTER';
}

function savePrinterName(name) {
  const cleanName = name.trim() || 'PRINTER';
  printerNameEl.textContent = cleanName;
  localStorage.setItem('printerName', cleanName);
}

function initPrinterName() {
  loadPrinterName();
  printerNameEl.addEventListener('click', () => {
    const currentName = printerNameEl.textContent.trim();
    const newName = prompt('Enter your printer name:', currentName);
    if (newName !== null) {
      savePrinterName(newName);
    }
  });
}

function setActivity(text, cls='') {
  activityBadge.textContent = text;
  activityBadge.className = 'pill ' + cls;
}
function setConnected(connected) {
  if (connected) {
    connBadge.textContent = 'Connected';
    connBadge.className = 'pill ok';

    topHotendPill.classList.remove('offline');
    topBedPill.classList.remove('offline');
    topHotendPill.classList.add('idle');
    topBedPill.classList.add('idle');
    updateTempPanel();
    startTempPolling();
    hideEtaPill();
  } else {
    connBadge.textContent = 'Disconnected';
    connBadge.className = 'pill bad';
    stopTempPolling();
    setOfflinePills();
  }

  connectBtn.disabled    = connected;
  disconnectBtn.disabled = !connected;
  readMeshBtn.disabled   = !connected;
  reprobeBtn.disabled    = !connected;
  sendCmdBtn.disabled    = !connected;
  bedPidBtn.disabled     = !connected;
  hotendPidBtn.disabled  = !connected;
  clearLogBtn.disabled   = !connected;

  hotendApply.disabled = !connected;
  hotendOff.disabled   = !connected;
  bedApply.disabled    = !connected;
  bedOff.disabled      = !connected;
  fanApply.disabled    = !connected;
  fanOff.disabled      = !connected;

  homeAll.disabled      = !connected;
  disableMotors.disabled= !connected;
  xMinus.disabled = xPlus.disabled =
  yMinus.disabled = yPlus.disabled =
  zMinus.disabled = zPlus.disabled = !connected;
  parkHead.disabled     = !connected;

  readCfg.disabled      = !connected;
  saveCfg.disabled      = !connected;

  preheatPLA.disabled = preheatPETG.disabled =
  preheatABS.disabled = cooldown.disabled =
  loadFil.disabled = unloadFil.disabled = !connected;

  fwInfo.disabled = tmcDiag.disabled = !connected;

  sendGcode.disabled   = !connected || !gcodeFile.files.length;
  cancelSend.disabled  = true;
}

// Level tab: printer selector
if (levelPrinterSelect) {
  const saved = localStorage.getItem('levelPrinterChoice');
  if (saved) levelPrinterSelect.value = saved;

  levelPrinterSelect.addEventListener('change', () => {
    localStorage.setItem('levelPrinterChoice', levelPrinterSelect.value);
    updateLevelView();
  });
}

function formatETA(seconds) {
  if (!isFinite(seconds) || seconds <= 0) return '0s';
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  if (m > 59) {
    const h = Math.floor(m / 60);
    const mm = m % 60;
    return `${h}h ${mm}m`;
  }
  return m > 0 ? `${m}m ${s}s` : `${s}s`;
}

function showEtaPill(text, cls = 'warn') {
  if (!etaPill) return;
  etaPill.textContent = text;
  etaPill.className = 'pill ' + cls;
  etaPill.style.display = 'inline-flex';
}

function hideEtaPill() {
  if (!etaPill) return;
  etaPill.style.display = 'none';
}

function setOfflinePills() {
  topHotendText.textContent = '--°C';
  topBedText.textContent    = '--°C';
  topHotendPill.className   = 'pill offline';
  topBedPill.className      = 'pill offline';
  hotendNow.textContent     = 'Current: —';
  bedNow.textContent        = 'Current: —';
}

function tempState(current, target, tolerance = 0.5) {
  if (target == null || Number.isNaN(target)) return 'idle';
  const diff = target - current;
  if (Math.abs(diff) <= tolerance) return 'ready';
  return diff > 0 ? 'heating' : 'cooling';
}

function setTempPill(pillEl, textEl, curr, target) {
  textEl.textContent = (target != null && !Number.isNaN(target))
    ? `${curr.toFixed(1)}°C / ${Math.round(target)}°`
    : `${curr.toFixed(1)}°C`;

  const state = tempState(curr, target);
  pillEl.classList.remove('offline','idle','ready','heating','cooling','pulse');
  pillEl.classList.add(state);
  if (state === 'heating' || state === 'cooling') pillEl.classList.add('pulse');
}

function updateTempPanel() {
  if (temps.hot != null) {
    hotendNow.textContent = `Current: ${temps.hot.toFixed(1)}°C` +
      (temps.hotTarget != null ? ` / ${Math.round(temps.hotTarget)}°` : '');
  } else hotendNow.textContent = 'Current: —';

  if (temps.bed != null) {
    bedNow.textContent = `Current: ${temps.bed.toFixed(1)}°C` +
      (temps.bedTarget != null ? ` / ${Math.round(temps.bedTarget)}°` : '');
  } else bedNow.textContent = 'Current: —';
}

function updateAxisPanel(x, y, z) {
  posXEl.textContent = x.toFixed(3);
  posYEl.textContent = y.toFixed(3);
  posZEl.textContent = z.toFixed(3);
}

function _logBase(msg) {
  if (!msg.endsWith('\n')) msg += '\n';
  printerLog.textContent += msg;
  printerLog.scrollTop = printerLog.scrollHeight;
}
function logMsg(msg) {
  const lines = String(msg).split(/\r?\n/);
  for (let line of lines) {
    if (!line) continue;
    line = normalizeLine(line);

    if (!debugMode && (isSetNewScreenLine(line) || isNoisyLine(line))) continue;
    if (!debugMode && TELEMETRY_REGEX.test(line)) continue;

    if (captureMode === 'config') {
      configBox.value += line + '\n';
      configBox.scrollTop = configBox.scrollHeight;
    } else if (captureMode === 'diag') {
      diagBox.value += line + '\n';
      diagBox.scrollTop = diagBox.scrollHeight;
    }
    _logBase(line);
  }
}

function updateLastUpdated(){
  lastUpdated.textContent = 'Last updated: ' + new Date().toLocaleTimeString();
  updateTempPanel();
}

function setLastCmd(cmd){ lastCmd.textContent = 'Last Cmd: ' + cmd; }

function startTempPolling(){
  if (!tempTimer) tempTimer = setInterval(() => sendCmd('M105', true), 3000);
}
function stopTempPolling(){
  if (tempTimer){ clearInterval(tempTimer); tempTimer = null; }
}

/* Close (exit) printer’s “printing” screen now or after a delay */
function exitPrintScreen(delayMs = 0) {
  if (postPrintTimer) { clearTimeout(postPrintTimer); postPrintTimer = null; }

  const fire = () => {
    logMsg('⌛ Closing print screen in firmware…');
    // Let sendCmd route to real/virtual; keep it quiet
    sendCmd('//action:cancel', true);
  };

  if (delayMs > 0) {
    postPrintTimer = setTimeout(() => { fire(); postPrintTimer = null; }, delayMs);
  } else {
    fire();
  }
}

window.addEventListener('unload', () => {
  if (postPrintTimer) clearTimeout(postPrintTimer);
});

// Virtual toggle: remember in LS and reflect on UI
const virtualToggle = document.getElementById('virtualToggle');
if (virtualToggle) {
  virtualMode = JSON.parse(localStorage.getItem('virtualMode') || 'false');
  virtualToggle.checked = virtualMode;

  virtualToggle.addEventListener('change', () => {
    virtualMode = virtualToggle.checked;
    localStorage.setItem('virtualMode', JSON.stringify(virtualMode));
    // If user flips on while connected to real printer, we keep the current connection
    // The "Connect" button will use virtual when not already connected.
  });
}

/* =============================
   Easter Egg — "Still Printing"
   (5 clicks on About tab opens a closable modal)
============================= */
document.addEventListener('DOMContentLoaded', () => {
  const aboutBtn = document.querySelector('#tabButtons button[data-tab="aboutTab"]');
  const allTabBtns = Array.from(document.querySelectorAll('#tabButtons button'));
  const eeOverlay = document.getElementById('eeOverlay');
  const eeModal   = document.getElementById('eeModal');
  const eeClose   = document.getElementById('eeClose');
  const eeBody    = document.getElementById('eeBody');

  if (!aboutBtn || !eeOverlay || !eeModal || !eeClose || !eeBody) {
    console.warn('[EE] Modal wiring skipped (missing elements).');
    return;
  }

  let streak = 0;
  const resetStreak = () => { streak = 0; };

  const openEasterEgg = () => {
    eeBody.textContent = [
      "This was a triumph,",
      "I’m making a note here: “BUILD SUCCESS.”",
      "It’s hard to overstate my satisfaction.",
      "Perfect adhesion,",
      "With just a touch of calibration. 🎵",
      "",
      "But there’s no sense whining when the layer’s too thin,",
      "You just tweak the Z-offset and then try it again.",
      "When the G-code’s complete,",
      "And the model’s elite,",
      "For the projects that are…",
      "Still printing. 🎵",
      "",
      "I’m not even angry,",
      "I’m being so sincere right now,",
      "Even though the extruder jammed and delayed my grand plans",
      "But I tuned the retraction",
      "And got a smooth reaction,",
      "",
      "Now the hours are flying, but I’m still having fun,",
      "Got a ten-hour Benchy and it’s only on run one.",
      "There’s a cat on the bed,",
      "And I’m filled with dread,",
      "For the projects that are…",
      "Still printing. 🎵",
      "",
      "Anyway, this print is great, it’s so dimensionally sweet,",
      "Look at me still sanding when there’s more stuff to complete.",
      "I’ve got spools in a row,",
      "And they’re ready to go,",
      "For the models that are…",
      "Still printing. 🎵"
    ].join('\n');

    eeOverlay.style.display = 'block';
    eeModal.style.display = 'grid';
    eeClose.focus();
  };

  const closeEasterEgg = () => {
    eeModal.style.display = 'none';
    eeOverlay.style.display = 'none';
  };

  // Only increments when About is clicked
  aboutBtn.addEventListener('click', () => {
    streak++;
    if (streak >= 5) {
      resetStreak();
      openEasterEgg();
    }
  });

  // Any other tab click resets
  allTabBtns.forEach(btn => {
    if (btn !== aboutBtn) btn.addEventListener('click', resetStreak);
  });

  // Close handlers
  eeClose.addEventListener('click', closeEasterEgg);
  eeOverlay.addEventListener('click', closeEasterEgg);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && eeModal.style.display !== 'none') closeEasterEgg();
  });
});

/* =========================================================
   6) MESH UTILS (parse, store, render)
========================================================= */

function processMeshLineFromAnywhere(line) {
  const completed = ingestMeshLine(line);
  if (completed) {
    const meshForUi = meshScratch.map(r => r.slice()); // already Y-flipped
    setActivity('Mesh parsed', 'ok');
    saveMeshLS(meshForUi);
    renderMeshInputs(meshForUi);
    renderSuggestions(meshForUi);
    updateLastUpdated();
    resetMeshScratch();
  }
}

function updateLevelView() {
  const choice = (levelPrinterSelect?.value || 'cr6se');
  const isCR6  = choice === 'cr6se';
  const isConnectedNow = (connKind === 'virtual') || !!writer;

  if (cr6seLevelWrap) cr6seLevelWrap.style.display = isCR6 ? '' : 'none';
  if (unsupportedMsg) unsupportedMsg.style.display = isCR6 ? 'none' : '';

  readMeshBtn.disabled = !isCR6 || !isConnectedNow;
  reprobeBtn.disabled  = !isCR6 || !isConnectedNow;
}


function meshIsComplete(m = meshScratch) {
  return m.every(row => row.every(v => typeof v === 'number' && !Number.isNaN(v)));
}
function resetMeshScratch() {
  meshScratch = Array.from({ length: 4 }, () => Array(4).fill(null));
}

// Accepts one G29-related line and updates meshScratch
function ingestMeshLine(line) {
  const s = line.trim();

  // Row-based: "y  v0 v1 v2 v3"
  const row = s.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
  if (row) {
    const fwY = parseInt(row[1], 10);
    const uiY = 3 - fwY; // flip Y for UI
    meshScratch[uiY][0] = parseFloat(row[2]);
    meshScratch[uiY][1] = parseFloat(row[3]);
    meshScratch[uiY][2] = parseFloat(row[4]);
    meshScratch[uiY][3] = parseFloat(row[5]);
    return meshIsComplete();
  }

  // Point formats: "X0 Y1 Z-0.0945", "X: 0; Y: 1 ... Z..."
  const pXY = s.match(/X\s*:?\s*(\d)\s*[,; ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i)
            || s.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
  if (pXY) {
    const x   = parseInt(pXY[1], 10);
    const fwY = parseInt(pXY[2], 10);
    const uiY = 3 - fwY;
    const val = parseFloat(pXY[3]);
    if (x < 4 && fwY < 4 && Number.isFinite(val)) {
      meshScratch[uiY][x] = val;
      return meshIsComplete();
    }
  }

  return false;
}

function tryParseMeshFromLines(lines) {
  const mesh = Array.from({ length: 4 }, () => Array(4).fill(null));

  for (const raw of lines) {
    const line = raw.trim();

    // Row-based
    const m = line.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
    if (m) {
      const fwY = parseInt(m[1], 10);
      const uiY = 3 - fwY;
      const vals = [parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), parseFloat(m[5])];
      mesh[uiY] = vals;
      continue;
    }

    // Point-by-point
    const p1 = line.match(/[\(\[](\d)\s*,\s*(\d)[\)\]]\s+([+-]?\d*\.?\d+)/);
    const p2 = line.match(/X\s*:?\s*(\d)\s*;?\s*[, ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i);
    const p3 = line.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
    const mP = p1 || p2 || p3;
    if (mP) {
      const x   = parseInt(mP[1], 10);
      const fwY = parseInt(mP[2], 10);
      const uiY = 3 - fwY;
      const val = parseFloat(mP[3]);
      if (x < 4 && fwY < 4) mesh[uiY][x] = val;
    }
  }

  const complete = mesh.every(row => row.every(v => typeof v === 'number' && !isNaN(v)));
  return complete ? mesh : null;
}

function loadMeshLS() {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  return hist.at(-1) || Array.from({length:4},()=>Array(4).fill(''));
}
function saveMeshLS(mesh) {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  hist.push(mesh);
  localStorage.setItem('levels', JSON.stringify(hist));
}

function getScrewData(mesh) {
  const result = {};
  for (const screw in screwAffects) {
    const points = screwAffects[screw];
    const values = points
      .map(([y,x]) => mesh?.[y]?.[x])
      .filter(v => typeof v === 'number' && !isNaN(v));
    const avg = values.length ? values.reduce((a,b)=>a+b,0)/values.length : null;

    let suggestion='N/A', turn='N/A';
    if (avg !== null) {
      if (avg >  0.07)      { suggestion='Tighten (Clockwise)';           turn='Strong (1/4 turn)'; }
      else if (avg > 0.04)  { suggestion='Tighten (Clockwise)';           turn='Moderate (1/8 turn)'; }
      else if (avg > 0.02)  { suggestion='Tighten (Clockwise)';           turn='Slight (1/16 turn)'; }
      else if (avg < -0.07) { suggestion='Loosen (Counterclockwise)';     turn='Strong (1/4 turn)'; }
      else if (avg < -0.04) { suggestion='Loosen (Counterclockwise)';     turn='Moderate (1/8 turn)'; }
      else if (avg < -0.02) { suggestion='Loosen (Counterclockwise)';     turn='Slight (1/16 turn)'; }
      else { suggestion='No change'; }
    }
    result[screw] = { avg: avg?.toFixed(3) ?? 'N/A', suggestion, turn };
  }
  return result;
}

function renderMeshInputs(mesh) {
  meshInput.innerHTML = '';
  for (let y=0; y<4; y++) {
    const tr = document.createElement('tr');
    for (let x=0; x<4; x++) {
      const v = mesh?.[y]?.[x];
      tr.innerHTML += `<td><input type="number" step="0.001" id="cell-${y}-${x}" value="${typeof v==='number'? v.toFixed(3): ''}" required></td>`;
    }
    meshInput.appendChild(tr);
  }
}
function renderSuggestions(mesh) {
  const data = getScrewData(mesh);
  screwTable.innerHTML = '';
  const layout = ['A1','GAP','A2','A3','B1','B2','B3','B4','C1','C2','C3','C4'];
  for (const sName of layout) {
    if (sName === 'GAP') continue;
    const s = data[sName];
    const tr = document.createElement('tr');
    tr.className = s.suggestion.includes('Tighten') ? 'tighten'
               :  s.suggestion.includes('Loosen')  ? 'loosen'
               :  'na';
    tr.innerHTML = `<td>${sName}</td><td>${s.avg}</td><td>${s.suggestion}</td><td>${s.turn}</td>`;
    screwTable.appendChild(tr);
    const cell = document.getElementById(sName);
    if (cell) {
      cell.className = tr.className;
      cell.innerHTML = `<strong>${sName}</strong><br>${s.avg} mm<br>${s.turn!=='N/A'? s.turn : ''}`;
    }
  }
}

function exportMeshAsFile(mesh, label) {
  const blob = new Blob([JSON.stringify(mesh, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `cr6se-mesh-${label}-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function promptNumber(message, def) {
  const raw = prompt(message, String(def));
  if (raw === null) return null;
  const n = parseFloat(raw);
  return Number.isFinite(n) ? n : NaN;
}

/* =========================================================
   7) SERIAL / COMMS (connect, read loop, send, waits)
========================================================= */
async function connectPrinter() {
  if (isConnecting) return;
  isConnecting = true;
  try {
    // Virtual path
    if (virtualMode) {
      await connectVirtual();
      connKind = 'virtual';
      return;
    }

    // Real serial path
    if (!('serial' in navigator)) {
      alert('Web Serial API not supported. Use Chrome/Edge/Brave on desktop.');
      return;
    }

    setActivity('Connecting...', 'warn');

    if (!port) {
      const granted = await navigator.serial.getPorts();
      port = granted[0] || await navigator.serial.requestPort();
    }

    if (!port.readable || !port.writable) {
      try {
        await port.open({ baudRate: 115200 });
      } catch (e) {
        if (!/already open/i.test(String(e))) throw e;
        logMsg('Port is already open; reusing existing connection.');
      }
    }

    try { if (reader) await reader.cancel(); } catch (e) {}
    try { if (reader) reader.releaseLock(); } catch (e) {}
    try { if (writer) writer.releaseLock(); } catch (e) {}

    const tds = new TextDecoderStream();
    textDecoder = tds;
    port.readable.pipeTo(tds.writable).catch(function(){});
    reader = tds.readable.getReader();
    writer = port.writable.getWriter();

    setConnected(true);
    hideEtaPill();
    updateTempPanel();
    startTempPolling();
    updateLastUpdated();
    setActivity('Connected', 'ok');
    logMsg('Connected.');
    if (!reading) readLoop();

    connKind = 'real';
  } catch (err) {
    setConnected(false);
    setActivity('Connect error', 'bad');
    logMsg(String(err?.message || err));
    connKind = 'none';
  } finally {
    isConnecting = false;
  }
}

async function disconnectPrinter() {
  if (isDisconnecting) return;
  isDisconnecting = true;
  try {
    if (connKind === 'virtual' || virtualMode) {
      await disconnectVirtual();
      connKind = 'none';
      return;
    }

    setConnected(false);
    setActivity('Disconnecting…', 'warn');

    try { if (reader) await reader.cancel(); } catch {}
    try { if (reader) reader.releaseLock(); } catch {}
    try { if (writer) writer.releaseLock(); } catch {}
    try { if (port)   await port.close(); } catch {}

    port = null;
    reader = null;
    writer = null;

    if (postPrintTimer) { clearTimeout(postPrintTimer); postPrintTimer = null; }

    setActivity('Disconnected', 'ok');
    logMsg('🔌 Disconnected.');
    connKind = 'none';
  } catch (err) {
    logMsg('❌ Disconnect error: ' + err.message);
  } finally {
    isDisconnecting = false;
  }
}

function _resolveNextOk() {
  const waiter = pendingOk.shift();
  if (waiter) waiter.resolve();
}
function _rejectAllOk(err) {
  const all = pendingOk.splice(0);
  for (const w of all) w.reject(err || new Error('Aborted'));
}

function resolveAllWaiting() {
  lastOkAt = Date.now();
  waitingResolvers.splice(0).forEach(fn => { try { fn(); } catch {} });
}

function waitForOk(timeoutMs = 30000) {
  return new Promise((resolve, reject) => {
    const needsRealConn = (connKind !== 'virtual' && !virtualMode);
    if (needsRealConn && (!port || !writer)) return reject(new Error('Disconnected'));
    if (cancelStream) return reject(new Error('Cancelled'));
    const entry = { resolve, reject };
    pendingOk.push(entry);
    const t = setTimeout(() => {
      // prune this waiter if still pending
      const i = pendingOk.indexOf(entry);
      if (i >= 0) pendingOk.splice(i, 1);
      reject(new Error('Timeout waiting for ok'));
    }, timeoutMs);
    // clear the timeout when we resolve/reject
    const origResolve = entry.resolve, origReject = entry.reject;
    entry.resolve = () => { clearTimeout(t); origResolve(); };
    entry.reject  = (e) => { clearTimeout(t); origReject(e); };
  });
}


async function readLoop() {
  reading = true;
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      if (value == null) continue;

      rxBuffer += value;
      const parts = rxBuffer.split(/\r?\n/);
      rxBuffer = parts.pop();

      for (const raw of parts) {
        const line = raw.trim();
        if (!line) continue;

        const tMatch = line.match(TEMP_T);
        const bMatch = line.match(TEMP_B);

        if (tMatch) {
          const tCur = parseFloat(tMatch[1]);
          const tTar = tMatch[2] !== undefined ? parseFloat(tMatch[2]) : null;
          if (Number.isFinite(tCur)) {
            temps.hot = tCur;
            temps.hotTarget = Number.isFinite(tTar) ? tTar : null;
            setTempPill(topHotendPill, topHotendText, temps.hot, temps.hotTarget);
          }
        }
        if (bMatch) {
          const bCur = parseFloat(bMatch[1]);
          const bTar = bMatch[2] !== undefined ? parseFloat(bMatch[2]) : null;
          if (Number.isFinite(bCur)) {
            temps.bed = bCur;
            temps.bedTarget = Number.isFinite(bTar) ? bTar : null;
            setTempPill(topBedPill, topBedText, temps.bed, temps.bedTarget);
          }
        }
        if (tMatch || bMatch) updateTempPanel();

        const isTelemetry = TELEMETRY_REGEX.test(line);
        let out = normalizeLine(line);

        const posMatch = line.match(POS_REGEX);
        if (posMatch) {
          const x = parseFloat(posMatch[1]);
          const y = parseFloat(posMatch[2]);
          const z = parseFloat(posMatch[3]);
          if ([x,y,z].every(Number.isFinite)) updateAxisPanel(x,y,z);
        }

        if (!debugMode && (isSetNewScreenLine(out) || isNoisyLine(out))) continue;

        if (debugMode) {
          if (tMatch || bMatch) {
            const hotStr = temps.hot != null
              ? `${temps.hot.toFixed(1)}${temps.hotTarget != null ? ' / ' + Math.round(temps.hotTarget) : ''}`
              : '--';
            const bedStr = temps.bed != null
              ? `${temps.bed.toFixed(1)}${temps.bedTarget != null ? ' / ' + Math.round(temps.bedTarget) : ''}`
              : '--';
            logMsg(`🌡 Hotend ${hotStr} · Bed ${bedStr}`);
          } else {
            logMsg(out);
          }
        } else if (!isTelemetry) {
          logMsg(out);
        }

        const justCompleted = ingestMeshLine(out);
        if (justCompleted) {
          const meshForUi = meshScratch.map(r => r.slice()); // already flipped
          setActivity('Mesh parsed', 'ok');
          saveMeshLS(meshForUi);
          renderMeshInputs(meshForUi);
          renderSuggestions(meshForUi);
          updateLastUpdated();
          resetMeshScratch();
        }

        if (/PID Autotune start/i.test(line))    setActivity('PID tuning…', 'warn');
        if (/PID Autotune finished/i.test(line)) setActivity('PID tuning complete', 'ok');
        if (/PID Autotune failed/i.test(line))   setActivity('PID tuning failed', 'bad');

        if (/^ok\b/i.test(line)) {
          updateLastUpdated();
          if (captureMode) { captureMode = null; startTempPolling(); }
          _resolveNextOk();
        }
      }
    }
  } catch (err) {
    logMsg('⚠️ Read error: ' + err.message);
  } finally {
    reading = false;
  }
}

async function sendCmd(cmd, quiet = false) {
  // Route commands properly in virtual mode
  if (connKind === 'virtual' || virtualMode) {
    return sendCmdVirtual(cmd, quiet);
  }

  if (!writer) { logMsg('⚠️ Not connected.'); return; }
  setLastCmd(cmd);
  setActivity('Sending…', 'warn');

  await writer.write(new TextEncoder().encode(cmd + '\n'));
  if (!quiet) logMsg('>> ' + cmd);

  updateLastUpdated();
  setActivity('Waiting…', 'warn');
}


async function waitForHotend(target, tol = 1.0) {
  await sendCmd(`M104 S${Math.round(target)}`);
  await waitForOk().catch(()=>{});
  return new Promise(resolve => {
    let timer;
    const check = async () => {
      await sendCmd('M105', true);
      if (temps.hot != null && Math.abs(temps.hot - target) <= tol) {
        clearInterval(timer); resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}
async function waitForBed(target, tol = 1.0) {
  await sendCmd(`M140 S${Math.round(target)}`);
  await waitForOk().catch(()=>{});
  return new Promise(resolve => {
    let timer;
    const check = async () => {
      await sendCmd('M105', true);
      if (temps.bed != null && Math.abs(temps.bed - target) <= tol) {
        clearInterval(timer); resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}

/* =========================================================
   8) UI ACTIONS (PID, leveling, movement, sender, config)
========================================================= */
async function runBedPID() {
  const t = promptNumber('Enter bed PID target temp (S):', 60);
  if (t === null) return;
  if (!Number.isFinite(t)) return alert('Invalid temperature.');
  setActivity(`PID bed @ ${t}°C…`, 'warn');
  await sendCmd(`M303 C5 E-1 S${t} U`);
  logMsg('ℹ️ PID tuning can take a few minutes. After success, send M500 to save if required.');
}
async function runHotendPID() {
  const t = promptNumber('Enter nozzle PID target temp (S):', 220);
  if (t === null) return;
  if (!Number.isFinite(t)) return alert('Invalid temperature.');
  setActivity(`PID hotend @ ${t}°C…`, 'warn');
  await sendCmd(`M303 C5 E0 S${t} U`);
  logMsg('ℹ️ PID tuning can take a few minutes. After success, send M500 to save if required.');
}

async function readMesh(){
  await sendCmd('G29 T');
  setActivity('Parsing…', 'warn');
}
async function reprobe(){
  await sendCmdsSequential('G28', 'G29 T');
  setActivity('Probing…', 'warn');
}
function sendManual(){
  const cmd = manualCmd.value.trim();
  if (!cmd) return;
  sendCmd(cmd);
  manualCmd.value = '';
}

function jog(axis, dir) {
  const step = parseFloat(jogStep.value);
  const dist = dir * step;
  const feed = (axis === 'Z') ? 300 : 3000;
  sendCmdsSequential(
    'G91',
    `G1 ${axis}${dist.toFixed(3)} F${feed}`,
    'G90'
  );
}

async function streamGcode(file) {
  // Require either a real writer or virtual connection
  if (!(connKind === 'virtual' || writer)) {
    alert('Not connected.');
    return;
  }

  cancelStream = false;
  cancelSend.disabled = true;
  hideEtaPill(); // reset any previous run

  // ✅ Reset progress UI at start
  sendProgress.style.width = '0%';
  sendStatus.textContent = 'Homing…';

  try {
    // Read and preprocess the file up-front so we can early-exit on empty
    const text = await file.text();
    const lines = text
      .split(/\r?\n/)
      .map(l => l.replace(/;.*/, '').trim()) // strip ';' comments
      .filter(Boolean);

    if (lines.length === 0) {
      sendStatus.textContent = 'No G-code lines found';
      return;
    }

    // Home before sending
    logMsg('🏠 Homing all axes (G28)…');
    await sendCmd('G28');
    await waitForOk();

    let sent = 0;
    const total = lines.length;
    let startTime = 0; // set when first line is actually sent
    const warmupLines = Math.min(10, Math.max(3, Math.floor(total * 0.02)));

    cancelSend.disabled = false;
    sendStatus.textContent = 'Sending…';
    showEtaPill('ETA: estimating…', 'warn');

    for (const line of lines) {
      if (cancelStream) break;

      if (!startTime) startTime = Date.now();

      await sendCmd(line);
      await waitForOk();

      sent++;

      // Progress UI
      const pct = Math.round((sent / total) * 100);
      sendProgress.style.width = pct + '%';
      sendStatus.textContent = `Sent ${sent}/${total} (${pct}%)`;

      // ETA after warmup to avoid early noise
      if (sent >= warmupLines) {
        const elapsedSec = (Date.now() - startTime) / 1000;
        const denom = (sent - warmupLines + 1);
        const avgPerLine = denom > 0 ? elapsedSec / denom : 0;
        const remainingLines = total - sent;
        const remainingSec = avgPerLine * remainingLines;
        showEtaPill('ETA: ' + formatETA(remainingSec), 'warn');
      }

      // Small pacing delay to avoid flooding slower boards
      await new Promise(r => setTimeout(r, 10));
    }

    cancelSend.disabled = true;

    if (cancelStream) {
      sendStatus.textContent = 'Cancelled';
      showEtaPill('ETA: —', 'bad');
      exitPrintScreen(0);
      hideEtaPill();
    } else {
      sendProgress.style.width = '100%';
      sendStatus.textContent = 'Done';
      showEtaPill('Complete', 'ok');
      exitPrintScreen(0);
      hideEtaPill();
    }

    // Optionally fade pill shortly after finish/cancel
    setTimeout(hideEtaPill, 2500);
  } catch (err) {
    cancelSend.disabled = true;
    sendStatus.textContent = 'Error during send';
    showEtaPill('Error', 'bad');
    logMsg('❌ Send error: ' + (err?.message || err));
    setTimeout(hideEtaPill, 2500);
  }
}

/* =========================================================
   9) EVENT LISTENERS
========================================================= */
// Connection
function trace(msg) { console.debug('[TRACE]', msg); }
connectBtn.addEventListener('click', () => { trace('Connect button'); connectPrinter(); });
disconnectBtn.addEventListener('click', () => { trace('Disconnect button'); disconnectPrinter(); });

// Leveling
readMeshBtn.addEventListener('click', readMesh);
reprobeBtn.addEventListener('click', reprobe);

// Manual command & log
sendCmdBtn.addEventListener('click', sendManual);
manualCmd.addEventListener('input', () => { captureMode = null; });
clearLogBtn.addEventListener('click', () => { printerLog.textContent = ''; });

// Level form & export
document.getElementById('levelForm').addEventListener('submit', (e) => {
  e.preventDefault();
  const mesh = [];
  for (let y=0; y<4; y++) {
    const row = [];
    for (let x=0; x<4; x++) {
      const v = parseFloat(document.getElementById(`cell-${y}-${x}`).value);
      row.push(isNaN(v) ? 0 : v);
    }
    mesh.push(row);
  }
  saveMeshLS(mesh);
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  alert('✅ Round submitted!');
});
document.getElementById('exportManualBtn').addEventListener('click', () => {
  const mesh = [];
  for (let y=0; y<4; y++) {
    const row = [];
    for (let x=0; x<4; x++) {
      const v = parseFloat(document.getElementById(`cell-${y}-${x}`).value);
      row.push(isNaN(v) ? 0 : v);
    }
    mesh.push(row);
  }
  exportMeshAsFile(mesh, 'manual');
});
document.getElementById('exportPrinterBtn').addEventListener('click', () => {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  const latest = hist.at(-1);
  if (latest && Array.isArray(latest) && latest.length === 4) {
    exportMeshAsFile(latest, 'printer');
  } else {
    alert('⚠️ No valid printer mesh to export.');
  }
});
resetBtn.addEventListener('click', () => {
  if (confirm('Reset all saved data?')) { localStorage.clear(); location.reload(); }
});

// Temperature & Fan
hotendApply.addEventListener('click', () =>
  sendCmd(`M104 S${Math.max(0, Math.min(300, parseInt(hotendSet.value)||0))}`));
hotendOff.addEventListener('click',   () => sendCmd('M104 S0'));
bedApply.addEventListener('click',    () =>
  sendCmd(`M140 S${Math.max(0, Math.min(130, parseInt(bedSet.value)||0))}`));
bedOff.addEventListener('click',      () => sendCmd('M140 S0'));
fanSlider.addEventListener('input',   () => { fanVal.textContent = fanSlider.value; });
fanApply.addEventListener('click',    () =>
  sendCmd(`M106 S${Math.max(0, Math.min(255, parseInt(fanSlider.value)||0))}`));
fanOff.addEventListener('click',      () => sendCmd('M107'));

// Movement
homeAll.addEventListener('click', async () => {
  try {
    setActivity('Homing…', 'warn');
    await sendCmd('G28'); await waitForOk().catch(()=>{});
    await sendCmd('M104 S0'); await waitForOk().catch(()=>{});
    await sendCmd('M140 S0'); await waitForOk().catch(()=>{});
    setActivity('Homed & cooled', 'ok');
    updateLastUpdated();
  } catch (e) {
    setActivity('Home failed', 'bad');
    logMsg('⚠️ Home error: ' + (e?.message || e));
  }
});
disableMotors.addEventListener('click', () => sendCmd('M84'));
xMinus.addEventListener('click', () => jog('X', -1));
xPlus .addEventListener('click', () => jog('X', +1));
yMinus.addEventListener('click', () => jog('Y', -1));
yPlus .addEventListener('click', () => jog('Y', +1));
zMinus.addEventListener('click', () => jog('Z', -1));
zPlus .addEventListener('click', () => jog('Z', +1));
parkHead.addEventListener('click', () =>sendCmdsSequential('G90', 'G1 X0 Y0 Z10 F3000')
);

// EEPROM / Config
readCfg.addEventListener('click', async () => {
  configBox.value = '';
  captureMode = 'config';
  stopTempPolling();
  await sendCmd('M503');
});
saveCfg.addEventListener('click', async () => { await sendCmd('M500'); });

// Maintenance
preheatPLA .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S200', 'M140 S60');
});
preheatPETG.addEventListener('click', async () => {
  await sendCmdsSequential('M104 S240', 'M140 S80');
});
preheatABS .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S250', 'M140 S100');
});
cooldown   .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S0', 'M140 S0');
});

loadFil.addEventListener('click', async () => {
  const mm   = parseFloat(prompt('How many mm to LOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(prompt('Hotend temp for load (°C)?', '200'));
  if (!Number.isFinite(temp) || temp <= 0) return;
  try {
    await sendCmd('G28');                    await waitForOk().catch(()=>{});
    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});
    await waitForHotend(temp, 1.0).catch(()=>{});
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{});
    await sendCmd('M82');                    await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});
    sendStatus.textContent = 'Filament load complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Load failed';
    console.error(e);
  }
});

unloadFil.addEventListener('click', async () => {
  const mm   = parseFloat(prompt('How many mm to UNLOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(prompt('Hotend temp for unload (°C)?', '200'));
  if (!Number.isFinite(temp) || temp <= 0) return;
  try {
    await sendCmd('G28');                    await waitForOk().catch(()=>{});
    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});
    await waitForHotend(temp, 1.0).catch(()=>{});
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E-${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{});
    await sendCmd('M82');                    await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});
    sendStatus.textContent = 'Filament unload complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Unload failed';
    console.error(e);
  }
});

// Diagnostics
fwInfo.addEventListener('click', () => {
  diagBox.value = '';
  captureMode = 'diag';
  stopTempPolling();
  sendCmd('M115');
});
tmcDiag.addEventListener('click', () => {
  diagBox.value = '';
  captureMode = 'diag';
  stopTempPolling();
  sendCmd('M122');
});

gcodeFile.addEventListener('change', () => {
  const connected = (connKind === 'virtual') || !!writer;
  sendGcode.disabled = !gcodeFile.files.length || !connected;
});

sendGcode.addEventListener('click',  () => {
  if (gcodeFile.files[0]) streamGcode(gcodeFile.files[0]);
});
cancelSend.addEventListener('click', async () => {
  cancelStream = true;
  _rejectAllOk(new Error('Cancelled')); // abort any waits right now
  await sendCmd('M104 S0'); await waitForOk().catch(()=>{});
  await sendCmd('M140 S0'); await waitForOk().catch(()=>{});
  await sendCmd('G90');     await waitForOk().catch(()=>{});
  await sendCmd('G1 X0 Y0 Z10 F3000'); await waitForOk().catch(()=>{});
  exitPrintScreen(0);
  hideEtaPill();
});

/* =========================================================
   10) INIT (runs once)
========================================================= */
(function init() {
  const mesh = loadMeshLS();
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  setConnected(false);
  setOfflinePills();
  updateLevelView();
  initPrinterName();
})();
</script>
</body>
</html>
