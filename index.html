<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Printer Utils</title>
<meta name="author" content="issypup">
<meta name="date" content="2025-08-10">
<style>
/* === G-code Preview === */
.gp-wrap {
  display: grid; gap: 8px;
  background: var(--panel); border: 1px solid var(--border);
  border-radius: 12px; padding: 10px; box-shadow: var(--shadow);
}
.gp-bar { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
.gp-bar label { display:flex; align-items:center; gap:6px; font-size: 14px; color: var(--text); }
.gp-bar input[type="range"] { width: 280px; }
.gp-canvas {
  position: relative; height: 360px; border: 1px dashed var(--border);
  border-radius: 8px; background: color-mix(in oklab, var(--panel) 90%, var(--text) 10%);
  overflow: hidden;
}
#gcodeCanvas { width: 100%; height: 100%; display: block; }
.gp-legend { font-size:12px; color: var(--muted); display:flex; gap:12px; }
.gp-chip { display:inline-flex; align-items:center; gap:6px; }
.gp-dot { width:10px; height:10px; border-radius:999px; display:inline-block; }
.gp-dot.prev { background: color-mix(in oklab, var(--text) 20%, transparent); }
.gp-dot.curr { background: var(--accent); }
.gp-dot.travel { background: color-mix(in oklab, var(--text) 35%, transparent); }

  /* Root variables for layout and theming */
  :root {
    --bar-h: 42px;
    /* Light theme defaults */
    --panel: #ffffff;
    --border: #dddddd;
    --text: #1a1a1a;
    --muted: #666666;
    --accent: #4f46e5;
    --shadow: 0 2px 6px rgba(0,0,0,0.08);
    --background: #f4f4f4;
  }
  /* Dark theme overrides */
  :root.dark {
    --panel: #1f2933;
    --border: #374151;
    --text: #f5f5f5;
    --muted: #9ca3af;
    --accent: #818cf8;
    --shadow: 0 2px 6px rgba(0,0,0,0.5);
    --background: #111827;
  }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    padding: calc(var(--bar-h) + 12px) 12px 56px;
    background: var(--background);
    color: var(--text);
  }
  h1, h2 { margin-top: 1rem; }
  table { border-collapse: collapse; margin-top: 0.5rem; }
  td, th { border: 1px solid #ccc; padding: 0.4rem; text-align: center; }
  input[type="number"], input[type="text"] { width: 100px; }
  /* Buttons adopt the current theme colors */
  button {
    padding: 0.45rem 0.9rem;
    margin: 0.25rem 0.25rem 0.25rem 0;
    cursor: pointer;
    background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 6px;
    transition: background-color 0.2s ease;
  }
  button:hover {
    background: color-mix(in oklab, var(--panel) 70%, var(--text) 30%);
  }
  .tighten { background: #ffe0e0; }
  .loosen  { background: #e0f0ff; }
  .na      { background: #eaeaea; }
  .gap { border: none; background: transparent; color: #888; font-weight: bold; }
  #screwMap td { width: 110px; height: 60px; vertical-align: top; font-size: 0.85em; }

  /* Status bar (always visible) */
  #statusBar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: var(--bar-h);
    background: var(--panel);
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 0 12px;
    z-index: 9999;
    font-weight: 600;
    border-bottom: 1px solid var(--border);
  }
#statusBar .pill { 
  /* background:#444; */  /* remove this line if needed */
  transition: background-color 200ms ease, filter 200ms ease, transform 200ms ease;
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 10px; border-radius:999px; font-weight:600;
}

/* state colors ‚Äì more specific than #statusBar .pill */
#statusBar .pill.idle    { background:#555; }     /* no target / idle */
#statusBar .pill.ready   { background:#2ecc71; }  /* green, stable */
#statusBar .pill.heating { background:#e74c3c; }  /* red, heating */
#statusBar .pill.cooling { background:#3498db; }  /* blue, cooling */
#statusBar .pill.offline { background:#444; color:#fff; }
#statusBar .pill.pid { background:#f39c12; } /* orange */

#pidUi .progress > div.pulse {
  animation: pillPulse 1.0s ease-in-out infinite;
}

.tabButton[aria-disabled="true"] {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none; /* belt & braces */
}

/* pulse effect (used for heating/cooling) */
.pulse { animation: pillPulse 1.0s ease-in-out infinite; }
@keyframes pillPulse {
  0%   { transform:none; filter:brightness(100%); }
  50%  { transform:scale(1.05); filter:brightness(115%); }
  100% { transform:none; filter:brightness(100%); }
}

/* keep hotend/bed pills nicely spaced */
#temps { display: inline-flex; gap: 24px; }

  #statusBar .ok    { background: #2a7; }
  #statusBar .warn  { background: #f39c12; }
  #statusBar .bad   { background: #c0392b; }

  /* Tabs */
  #tabButtons { display:flex; flex-wrap: wrap; gap:6px; margin: 8px 0 4px; }
  #tabButtons button {
    padding: 0.45rem 1rem; cursor: pointer; background: #eee; border: 1px solid #ccc;
  }
  #tabButtons button.active { background: #ddd; font-weight: bold; }
  .tabContent { display: none; }
  .tabContent.active { display: block; }

  /* Controls rows inside tabs */
  .tabControls {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin: 12px 0;
    align-items: center;
  }

  /* Improve spacing and alignment of labels and inputs within tab controls */
  .tabControls label {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-right: 8px;
  }
  .tabControls input[type="text"],
  .tabControls input[type="number"],
  .tabControls select {
    min-width: 140px;
    padding: 4px 6px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  .tabControls button {
    margin-right: 8px;
  }

  /* Manual G-code input should grow to fill available space */
  #manualCmd {
    flex: 1 1 auto;
    min-width: 220px;
    padding: 6px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  /* Uniform styling for text inputs across the app */
  input[type="text"],
  input[type="number"],
  select {
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 6px 8px;
    background: var(--panel);
    color: var(--text);
  }

  /* Improved tab button spacing and appearance */
  #tabButtons {
    gap: 8px;
    margin: 12px 0 8px;
  }
  #tabButtons button {
    padding: 0.5rem 1.2rem;
    border-radius: 6px;
    border: 1px solid var(--border);
    background: color-mix(in oklab, var(--panel) 90%, var(--text) 10%);
    color: var(--text);
    transition: background-color 0.2s ease;
  }
  #tabButtons button.active {
    background: var(--border);
    font-weight: bold;
  }

  /* Webcam tab layout: use responsive grid for controls */
  #webcamTab .box {
    display: grid;
    gap: 12px;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    align-items: start;
  }

  /* Stack rows vertically in the connection tab controls */
  #printerNavConnect {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }

  /* Printer log */
  #printerLog {
    background: var(--panel);
    color: var(--text);
    border: 1px solid var(--border);
    height: 220px;
    overflow: auto;
    padding: 8px;
    white-space: pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    border-radius: 6px;
  }

#webcamTab video, #webcamTab img, #webcamTab canvas { background:#000; }

#printerName.editable {
  cursor: pointer;
}
#printerName.editable:hover {
  text-decoration: underline;
}

  /* Footer status */
  #footerStatus {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--panel);
    color: var(--text);
    padding: 6px 10px;
    display: flex;
    justify-content: space-between;
    font-size: 0.9em;
    border-top: 1px solid var(--border);
  }

#aboutTab .aboutCard {
  background: var(--panel);
  border: 1px solid var(--border);
  padding: 16px 18px;
  border-radius: 8px;
  max-width: 560px;
  margin: 20px auto;
  box-shadow: var(--shadow);
  color: var(--text);
}

#aboutTab .aboutCard h2 {
  margin: 0 0 10px;
  font-size: 1.3em;
  color: var(--text);
  border-bottom: 2px solid var(--border);
  padding-bottom: 6px;
}

#aboutTab .aboutCard p { margin: 10px 0 0; color: var(--muted); }

#aboutTab .kv {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  margin-top: 8px;
  font-size: 0.95em;
}
#aboutTab .kv span:first-child { color: var(--muted); }
#aboutTab .kv span:last-child  { font-weight: 600; color: var(--text); }

  /* Small UI helpers */
  /* Base row flexbox with generous spacing */
  .row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
  }
  /* Column flexbox with unified vertical spacing */
  .col {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  /* Panel containers with padding and margin */
  .box {
    background: var(--panel);
    border: 1px solid var(--border);
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 12px;
    color: var(--text);
  }
  .label { font-weight: 600; color: var(--text); }
  .muted { color: var(--muted); font-size: 0.9em; }
  .widen { width: 220px; }
  .progress { height: 10px; background: #ddd; border-radius: 999px; overflow: hidden; width: 280px; }
  .progress > div { height: 100%; background: #2a7; width: 0%; }

#preOverlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000;
}
#preModal   {
  position: fixed; inset: 0; display: none; place-items: center; z-index: 10001;
}
#preCard    {
  width: min(720px, 92vw);
  max-height: 80vh;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: var(--shadow);
  display: grid;
  grid-template-rows: auto 1fr;
  color: var(--text);
}
#preHeader  {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:12px 14px;
  border-bottom:1px solid var(--border);
  color: var(--text);
}
#preBody    {
  padding:14px 16px;
  overflow:auto;
  line-height:1.35;
  color: var(--text);
}
#preClose   {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border);
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  color: var(--text);
}
#preClose:hover {
  background: color-mix(in oklab, var(--panel) 70%, var(--text) 30%);
}


  /* EE Modal */
#eeOverlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 10000;
}

#eeModal {
  position: fixed; inset: 0;
  display: none;           /* toggled by JS */
  place-items: center;     /* grid centering */
  z-index: 10001;
}

#eeCard {
  width: min(720px, 92vw);
  max-height: 80vh;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: var(--shadow);
  display: grid;
  grid-template-rows: auto 1fr;
  color: var(--text);
}

#eeHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 14px;
  border-bottom: 1px solid var(--border);
  color: var(--text);
}

.pidDebug { max-height: 160px; overflow: auto; }

#eeBody {
  padding: 14px 16px;
  white-space: pre-wrap;   /* preserve line breaks */
  overflow: auto;
  line-height: 1.35;
  color: var(--text);
}

#eeClose {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border);
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  color: var(--text);
}
#eeClose:hover {
  background: color-mix(in oklab, var(--panel) 70%, var(--text) 30%);
}

#liveChart { width: 100%; height: 260px; display: block; }


/* ===== HELP DRAWER ===== */
.help-drawer {
  position: fixed; right: 0; top: var(--bar-h, 42px);
  width: min(420px, 88vw); height: calc(100vh - var(--bar-h, 42px));
  background: var(--panel); color: var(--text);
  border-left: 1px solid var(--border);
  box-shadow: var(--shadow);
  display: none; flex-direction: column; z-index: 9998;
}
.help-drawer.open { display: flex; }

.help-head {
  display:flex; align-items:center; gap:8px; padding:10px 12px;
  border-bottom:1px solid var(--border);
}
.help-head h3 { margin:0; font-size:16px; flex:1; }
.help-actions { display:flex; gap:8px; }
.help-actions input[type="search"] { width: 180px; }

.help-body {
  overflow: auto; padding: 12px 14px; line-height: 1.45;
}
.help-body h4 { margin: 1em 0 .4em; }
.help-body p { margin: .5em 0; }
.help-body code, .help-body kbd {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border); padding: .1em .35em; border-radius: 6px;
}
.help-body pre {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border); padding: 8px; border-radius: 8px;
  overflow: auto;
}
.help-resize {
  position: absolute; left: -6px; top: 0; bottom: 0; width: 8px; cursor: ew-resize;
}
.help-toggle-btn {
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; border:1px solid var(--border);
  background: var(--panel); border-radius: 8px; cursor: pointer;
}
/* ============ Docked Help layout ============ */

/* Two-column grid that holds the whole app area (tabs + tabContent) and the Help aside */
.app-layout {
  display: grid;
  grid-template-columns: 1fr minmax(300px, 420px);
  gap: 12px;
  align-items: start;
  margin-top: 8px; /* tiny breathing room under the tab bar */
}

/* Make the drawer live "in flow" when docked */
.app-layout .help-drawer {
  position: sticky;      /* stays visible while you scroll */
  top: calc(var(--bar-h, 42px) + 8px);
  height: calc(100vh - var(--bar-h, 42px) - 24px);
  border-left: 1px solid var(--border);
  box-shadow: var(--shadow);
  display: none;         /* hidden until Help is toggled */
}

/* Visible when toggled */
.app-layout .help-drawer.open { display: flex; }

/* The main content column */
#appMain { min-width: 0; } /* allow content to shrink and not overflow */

/* Responsiveness: on small screens, fall back to the original overlay behavior */
@media (max-width: 1000px) {
  .app-layout {
    grid-template-columns: 1fr; /* single column */
  }
  .app-layout .help-drawer {
    position: fixed;
    right: 0; top: var(--bar-h, 42px);
    width: min(420px, 88vw);
    height: calc(100vh - var(--bar-h, 42px));
    display: none; /* still controlled by .open */
  }
  .app-layout .help-drawer.open { display: flex; }
}

/* Position vars the JS will update */
:root {
  --help-top: calc(var(--bar-h, 42px) + 8px);
}
.help-drawer {
  position: fixed;
  right: 0;
  top: var(--help-top);
  height: calc(100vh - var(--help-top) - 16px);
  width: min(420px, 88vw);
}

#helpCard {
  width: min(760px, 92vw); max-height: 82vh;
  background: var(--panel); color: var(--text);
  border: 1px solid var(--border); border-radius: 12px; box-shadow: var(--shadow);
  display: grid; grid-template-rows: auto 1fr;
}
#helpHead {
  display:flex; align-items:center; gap:8px;
  padding:12px 14px; border-bottom:1px solid var(--border); cursor: move; /* draggable handle */
}
#helpHead h3 { margin:0; font-size:16px; flex:1; }
#helpActions { display:flex; gap:8px; align-items:center; }
#helpBodyWrap { overflow:auto; padding: 12px 14px; }

/* Reuse existing help content styles */
#helpBodyWrap .help-body h4 { margin: 1em 0 .4em; }
#helpBodyWrap .help-body p  { margin: .5em 0; }
#helpBodyWrap .help-body code, 
#helpBodyWrap .help-body kbd {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border); padding: .1em .35em; border-radius: 6px;
}
#helpBodyWrap .help-body pre {
  background: color-mix(in oklab, var(--panel) 85%, var(--text) 15%);
  border: 1px solid var(--border); padding: 8px; border-radius: 8px; overflow:auto;
}

/* ==== HELP MODAL (fixed) ==== */
#helpOverlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.45);
  display: none; z-index: 10000;
}
#helpModal {
  position: fixed; inset: 0; display: none; place-items: center; z-index: 10001;
}

/* show */
#helpOverlay.open, #helpModal.open { display: grid; }

/* Force a clean, white Help modal regardless of theme */
#helpCard {
  background: #fff !important;
  color: #111 !important;
  border: 1px solid #e5e7eb !important;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0,0,0,.25);
}
#helpHead { background: transparent; }
#helpBodyWrap { background: transparent; }

#helpActions input[type="search"] { width: 220px; }

/* Reuse your help body typography */
#helpBodyWrap .help-body h4 { margin: 1em 0 .4em; }
#helpBodyWrap .help-body p  { margin: .5em 0; }
#helpBodyWrap .help-body code, 
#helpBodyWrap .help-body kbd {
  background: #f4f6f8;
  border: 1px solid #e5e7eb; padding: .1em .35em; border-radius: 6px;
}
#helpBodyWrap .help-body pre {
  background: #f4f6f8;
  border: 1px solid #e5e7eb; padding: 8px; border-radius: 8px; overflow:auto;
}

/* Doc typography */
#helpBody code,#helpBody kbd{background:#f4f6f8;border:1px solid #e5e7eb;padding:.1em .35em;border-radius:6px;}
#helpBody pre{background:#f4f6f8;border:1px solid #e5e7eb;padding:8px;border-radius:8px;overflow:auto;}

</style>
</head>
<body>

<!-- Global Status Bar -->
  <div id="statusBar">
  <span id="printerName" class="editable">PRINTER</span>
  <span id="connBadge" class="pill bad">Disconnected</span>
  <span id="activityBadge" class="pill">Idle</span>
  <span id="lastUpdated" class="pill">Last updated: ‚Äî</span>
<span id="temps">
  <span class="pill idle" id="topHotendPill">Hotend: <span id="topHotend">--¬∞C</span></span>
  <span class="pill idle" id="topBedPill">Bed: <span id="topBed">--¬∞C</span></span>
</span>
<span id="etaPill" class="pill" style="display:none;">ETA: ‚Äî</span>
<span id="netPill" class="pill" title="Live serial throughput and OK latency">
  TX ‚Äî ¬∑ RX ‚Äî ¬∑ Lat ‚Äî
</span>
    <!-- Dark mode toggle button -->
    <button id="themeToggle" title="Toggle light/dark mode" style="margin-left:auto;">Dark Mode</button>
</div>

<h1>3D Printer Utils</h1>

<!-- Tabs -->
<div id="tabButtons">
  <button data-tab="connectTab" class="active">Connection & Log</button>
  <button data-tab="webcamTab">Webcam</button>
  <button data-tab="levelTab">Leveling</button>
  <button data-tab="pidTab">PID Tuning</button>
  <button data-tab="tempTab">Temperature & Fan</button>
  <button data-tab="moveTab">Movement & Axes</button>
  <button data-tab="eepromTab">EEPROM / Config</button>
  <button data-tab="maintTab">Maintenance</button>
  <button data-tab="filamentTab">Filament</button>
  <button data-tab="diagTab">Diagnostics</button>
  <button data-tab="senderTab">G-code Sender</button>
  <button data-tab="telegramTab">Telegram</button>
  <button data-tab="aboutTab">About</button>
</div>

<!-- TAB 1: Connection & Log -->
<div id="connectTab" class="tabContent active">
  <div class="tabControls" id="printerNavConnect">
    <div class="row" style="flex-wrap:wrap; align-items:center;">
      <label><input type="checkbox" id="debugToggle"> Debug</label>
      <label><input type="checkbox" id="virtualToggle"> Virtual printer</label>
      <label>Baud:
        <select id="baudSelect">
          <option value="auto" selected>Auto-detect</option>
          <option value="250000">250000</option>
          <option value="115200">115200</option>
          <option value="230400">230400</option>
          <option value="500000">500000</option>
          <option value="1000000">1000000</option>
          <option value="57600">57600</option>
        </select>
      </label>
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>
    <div class="row" style="flex-wrap:wrap; align-items:center;">
      <input id="manualCmd" placeholder="Manual G-code (e.g., M503)" />
      <button id="sendCmdBtn" disabled>Send</button>
      <button id="clearLogBtn" disabled>Clear Log</button>
    </div>
  </div>

  <h2>Printer Log</h2>
  <div id="printerLog" aria-live="polite"></div>
</div>

<!-- TAB: Webcam -->
<div id="webcamTab" class="tabContent">
  <div class="box">
    <div class="col">
      <div class="label">Source</div>
      <label><input type="radio" name="camMode" id="camModeMjpeg" checked> MJPEG URL</label>
      <label><input type="radio" name="camMode" id="camModeWebrtc"> Local WebRTC</label>
    </div>

    <div id="mjpegControls" class="col" style="min-width:280px">
      <label class="label">MJPEG URL</label>
      <!-- Input for a single MJPEG stream; users can add multiple streams via the + button below -->
      <input id="mjpegUrl" class="widen" placeholder="http://printer.local/webcam/?action=stream">
      <div class="row" style="gap:8px; align-items:center">
        <!-- Add the current MJPEG URL to the camera list -->
        <button id="mjpegAdd" title="Add camera">+</button>
        <!-- List of saved MJPEG cameras; hidden until at least one is added -->
        <select id="mjpegList" style="min-width:200px; display:none"></select>
        <button id="mjpegStart">Start</button>
        <button id="mjpegStop" disabled>Stop</button>
      </div>
      <div class="muted">Note: To record or snapshot an MJPEG stream, the server must allow CORS or the canvas will be tainted.</div>
    </div>

    <div id="webrtcControls" class="col" style="min-width:280px; display:none">
      <div class="row" style="gap:8px">
        <button id="rtcStart">Start Camera</button>
        <button id="rtcStop"  disabled>Stop</button>
      </div>
      <label>Device
        <select id="rtcDevices" style="min-width:240px"></select>
      </label>
      <div class="muted">Uses navigator.mediaDevices.getUserMedia()</div>
    </div>

    <div class="col">
      <div class="label">Timelapse</div>
      <div class="row" style="gap:8px; align-items:center">
        <label>FPS <input id="tlFps" type="number" min="1" max="30" value="2" style="width:64px"></label>
        <label>Scale <input id="tlScale" type="number" min="0.1" step="0.1" value="1.0" style="width:64px"></label>
        <button id="tlStart" disabled>Start TL</button>
        <button id="tlStop"  disabled>Stop TL</button>
        <a id="tlDownload" download="timelapse.webm" style="display:none">Download</a>
      </div>
      <div class="muted" id="tlStatus">‚Äî</div>
      <!-- Octolapse style capture controls -->
      <div class="label" style="margin-top:8px;">Octolapse</div>
      <div class="row" style="gap:8px; align-items:center">
        <button id="octoStart" disabled>Start Octo TL</button>
        <button id="octoStop"  disabled>Stop Octo TL</button>
        <a id="octoDownload" download="octolapse.webm" style="display:none">Download Octo</a>
      </div>
    </div>
  </div>

  <div class="gp-canvas" style="height:420px; margin-top:10px">
    <!-- Render area -->
    <img id="mjpegImg" alt="" style="max-width:100%; max-height:100%; display:none">
    <video id="rtcVideo" playsinline autoplay muted style="max-width:100%; max-height:100%; display:none"></video>
    <canvas id="camCanvas" width="1280" height="720" style="display:none"></canvas>
  </div>

  <div class="row" style="gap:8px; margin-top:8px">
    <button id="snapBtn" disabled>Snapshot</button>
    <a id="snapDownload" style="display:none">Download Snapshot</a>
    <span class="muted" id="camHint">Idle.</span>
  </div>
</div>


<!-- TAB 2: Leveling -->
<div id="levelTab" class="tabContent">
<div class="tabControls" id="printerNavLevel">
  <button id="readMeshBtn" disabled>Home &amp; Probe (G28 ‚Üí G29 T)</button>
  <button type="button" id="exportMeshBtn">Export Mesh</button>

  <label style="margin-left:auto">
    Printer:
    <select id="levelPrinterSelect">
      <option value="cr6se" selected>CR-6 SE</option>
      <option value="unsupported">Unsupported</option>
    </select>
  </label>
</div>

  <!-- NEW: message for unsupported printers -->
  <div id="unsupportedMsg" class="box" style="display:none; max-width:560px">
    <strong>Printer unsupported.</strong>
    <div class="muted">Leveling helpers are currently only available for the CR-6 SE.</div>
  </div>

  <!-- Wrap all CR-6 SE specific UI so we can show/hide it easily -->
  <div id="cr6seLevelWrap">
    <!-- Mesh Form (manual + populated from printer) -->
    <form id="levelForm">
      <h2>Enter / View Mesh Readings</h2>
      <table><tbody id="meshInput"></tbody></table>
      <button type="submit">Submit Round</button>
      <button type="button" id="resetBtn">Reset Data</button>
    </form>

    <h2>Screw Suggestions</h2>
    <table>
      <thead>
        <tr><th>Screw</th><th>Avg (mm)</th><th>Action</th><th>Turn Strength</th></tr>
      </thead>
      <tbody id="screwTable"></tbody>
    </table>

    <h2>Screw Layout Map</h2>
    <table id="screwMap">
      <tr>
        <td id="A1"></td>
        <td class="gap">GAP</td>
        <td id="A2"></td>
        <td id="A3"></td>
      </tr>
      <tr>
        <td id="B1"></td>
        <td id="B2"></td>
        <td id="B3"></td>
        <td id="B4"></td>
      </tr>
      <tr>
        <td id="C1"></td>
        <td id="C2"></td>
        <td id="C3"></td>
        <td id="C4"></td>
      </tr>
    </table>
  </div>
</div>

<!-- TAB 3: PID Tuning -->
<div id="pidTab" class="tabContent">
  <div class="tabControls" id="printerNavPID">
    <button id="bedPidBtn"    disabled>PID Bed (M303 E-1)</button>
    <button id="hotendPidBtn" disabled>PID Nozzle (M303 E0)</button>
  </div>
  <p>Runs <code>M303</code> autotune with a temperature you choose. After it completes, send <code>M500</code> if your firmware needs it to save to EEPROM.</p>
  <!-- PID options: apply results and debug toggle -->
  <div class="row" style="gap:12px; margin:6px 0;">
    <label style="display:flex; align-items:center; gap:6px;">
      <input type="checkbox" id="pidUseCb" checked />
      Apply results (M303&nbsp;U)
    </label>
    <button id="pidDebugBtn" class="btn btn--sm">Toggle PID Debug (M303&nbsp;D)</button>
  </div>
  <!-- Note about PID_DEBUG requirement -->
  <div class="muted" style="margin:4px 0 8px 0; max-width:680px;">
    Note: PID_DEBUG must be enabled (compiled into Marlin) for debug output to work.
  </div>
  <div class="box" id="pidUi">
  <div class="label" style="margin-bottom:6px">PID Autotune Progress</div>

<div class="label" style="margin-top:14px">Live Telemetry (last 10 min)</div>
<canvas class="liveChart" id="liveChartPID" width="900" height="260" aria-label="Live temperatures, fan %, and M73 %"></canvas>
<div class="muted">Left axis: ¬∞C ¬∑ Right axis: % (Fan, M73)</div>

  <!-- Hotend -->
  <div class="col" style="gap:6px; margin-bottom:10px">
    <div class="row" style="align-items:center; gap:10px">
      <strong>Nozzle</strong>
      <span id="pidHotStatus" class="muted">Idle</span>
    </div>
    <div class="progress" style="width:360px">
      <div id="pidHotBar" style="width:0%"></div>
    </div>
    <div class="muted" id="pidHotInfo">T: ‚Äî / Target: ‚Äî (Œî ‚Äî)</div>
    <div class="muted" id="pidHotResult">Kp: ‚Äî ¬∑ Ki: ‚Äî ¬∑ Kd: ‚Äî</div>
    <div class="pid-prev-row">
  <p class="muted" id="pidHotPrev">Prev ‚Äî Kp: ‚Äî ¬∑ Ki: ‚Äî ¬∑ Kd: ‚Äî (Œî ‚Äî)</p>
  <button id="pidHotRevertBtn" class="btn btn--sm" title="Revert Nozzle PID (M301 + M500)">Revert</button>
</div>
    <details class="muted" id="pidHotDbgBox">
  <summary>PID Debug</summary>
  <pre id="pidHotDbg" class="pidDebug"></pre>
</details>
  </div>

  <!-- Bed -->
  <div class="col" style="gap:6px">
    <div class="row" style="align-items:center; gap:10px">
      <strong>Bed</strong>
      <span id="pidBedStatus" class="muted">Idle</span>
    </div>
    <div class="progress" style="width:360px">
      <div id="pidBedBar" style="width:0%"></div>
    </div>
    <div class="muted" id="pidBedInfo">T: ‚Äî / Target: ‚Äî (Œî ‚Äî)</div>
    <div class="muted" id="pidBedResult">Kp: ‚Äî ¬∑ Ki: ‚Äî ¬∑ Kd: ‚Äî</div>
    <div class="pid-prev-row">
  <p class="muted" id="pidBedPrev">Prev ‚Äî Kp: ‚Äî ¬∑ Ki: ‚Äî ¬∑ Kd: ‚Äî (Œî ‚Äî)</p>
  <button id="pidBedRevertBtn" class="btn btn--sm" title="Revert Bed PID (M304 + M500)">Revert</button>
</div>
    <details class="muted" id="pidBedDbgBox">
  <summary>PID Debug</summary>
  <pre id="pidBedDbg" class="pidDebug"></pre>
</details>
  </div>
</div>
  <!-- Manual PID Control -->
  <hr style="margin:8px 0;">
  <div class="col" style="gap:8px">
    <div class="label">Manual PID Control</div>
    <!-- Manual Hotend -->
    <div class="col" style="gap:6px; margin-bottom:6px;">
      <strong>Nozzle (M301)</strong>
      <div class="row" style="flex-wrap:wrap; gap:6px; align-items:center;">
        <label>Kp <input id="pidHotInpP" type="number" step="0.01" style="width:80px;"></label>
        <label>Ki <input id="pidHotInpI" type="number" step="0.01" style="width:80px;"></label>
        <label>Kd <input id="pidHotInpD" type="number" step="0.01" style="width:80px;"></label>
        <button id="pidHotApply" class="btn btn--sm" type="button">Apply</button>
        <button id="pidHotOver" class="btn btn--sm" type="button">Some¬†Overshoot</button>
        <button id="pidHotNoOver" class="btn btn--sm" type="button">No¬†Overshoot</button>
      </div>
    </div>
    <!-- Manual Bed -->
    <div class="col" style="gap:6px;">
      <strong>Bed (M304)</strong>
      <div class="row" style="flex-wrap:wrap; gap:6px; align-items:center;">
        <label>Kp <input id="pidBedInpP" type="number" step="0.01" style="width:80px;"></label>
        <label>Ki <input id="pidBedInpI" type="number" step="0.01" style="width:80px;"></label>
        <label>Kd <input id="pidBedInpD" type="number" step="0.01" style="width:80px;"></label>
        <button id="pidBedApply" class="btn btn--sm" type="button">Apply</button>
        <button id="pidBedOver" class="btn btn--sm" type="button">Some¬†Overshoot</button>
        <button id="pidBedNoOver" class="btn btn--sm" type="button">No¬†Overshoot</button>
      </div>
    </div>
  </div>

</div>

<!-- TAB 4: Temperature & Fan -->
<div id="tempTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Hotend</div>
      <div>
        <input type="number" id="hotendSet" value="200" min="0" max="300" /> ¬∞C
        <button id="hotendApply" disabled>Set (M104)</button>
        <button id="hotendOff"   disabled>Off (M104 S0)</button>
      </div>
      <div class="muted" id="hotendNow">Current: ‚Äî</div>
    </div>
    <div class="col">
      <div class="label">Bed</div>
      <div>
        <input type="number" id="bedSet" value="60" min="0" max="130" /> ¬∞C
        <button id="bedApply" disabled>Set (M140)</button>
        <button id="bedOff"   disabled>Off (M140 S0)</button>
      </div>
      <div class="muted" id="bedNow">Current: ‚Äî</div>
    </div>
    <div class="col">
      <div class="label">Part Cooling Fan</div>
      <div>
        <input type="range" id="fanSlider" min="0" max="255" value="0" />
        <span id="fanVal">0</span>/255
      </div>
      <div>
        <button id="fanApply" disabled>Apply (M106)</button>
        <button id="fanOff"   disabled>Off (M107)</button>
      </div>
    </div>
  </div>
  <div class="box">
  <div class="label">Live Telemetry (last 10 min)</div>
  <canvas id="liveChart" class="liveChart" width="900" height="260"></canvas>
  <div class="muted">Left axis: ¬∞C ¬∑ Right axis: % (Fan, M73)</div>
</div>
  <div class="row box">
<div class="col">
  <div class="label">Safety</div>
  <button id="unlockTempsBtn" type="button">Unlock high hotend temps</button>
  <div class="muted" id="unlockHint">Guardrail ON ‚Äî max 250¬∞C</div>
</div>
    <div class="muted">Polled via M105 every 3s while connected</div>
  </div>
</div>

<!-- TAB 5: Movement & Axes -->
<div id="moveTab" class="tabContent">
  <div class="row box">
    <div>
      <span class="label">Step</span>
      <select id="jogStep">
        <option value="1">1 mm</option>
        <option value="5" selected>5 mm</option>
        <option value="10">10 mm</option>
      </select>
    </div>
    <div>
      <button id="homeAll" disabled>Home All (G28)</button>
      <button id="disableMotors" disabled>Disable Steppers (M84)</button>
    </div>
  </div>
  <div class="row box">
    <div class="col">
      <div class="label">Move X</div>
      <button id="xMinus" disabled>‚óÄ X-</button>
      <button id="xPlus"  disabled>X+ ‚ñ∂</button>
    </div>
    <div class="col">
      <div class="label">Move Y</div>
      <button id="yMinus" disabled>‚ñº Y-</button>
      <button id="yPlus"  disabled>‚ñ≤ Y+</button>
    </div>
    <div class="col">
      <div class="label">Move Z</div>
      <button id="zMinus" disabled>Z-</button>
      <button id="zPlus"  disabled>Z+</button>
    </div>
    <div id="axisPositions">
  <div>X: <span id="posX">‚Äî</span></div>
  <div>Y: <span id="posY">‚Äî</span></div>
  <div>Z: <span id="posZ">‚Äî</span></div>
</div>
  </div>
  <div class="row box">
    <button id="parkHead" disabled>Park Head (X0 Y0 Z10)</button>
  </div>
</div>

<!-- TAB 6: EEPROM / Config -->
<div id="eepromTab" class="tabContent">
  <div class="row box">
  <button id="parseM503Btn" type="button">Parse M503 ‚Üí Fields</button>
  <button id="exportCfgBtn" type="button">Export JSON</button>
  <span class="muted">Paste/receive M503 below, then Parse.</span>
    <!-- <button id="resetCfg" disabled>Factory Reset (M502)</button>-->
  </div>
  <table class="box" style="width:100%; max-width:900px; margin-bottom:8px">
  <thead>
    <tr><th style="width:220px">Setting</th><th>Value</th></tr>
  </thead>
<table id="m503Table" style="border-collapse:collapse;width:100%;max-width:900px">
  <thead><tr><th style="text-align:left;width:240px">Field</th><th style="text-align:left">Value</th></tr></thead>
  <tbody></tbody>
</table>
</table>
</div>

<!-- TAB 7: Maintenance -->
<div id="maintTab" class="tabContent">
  <div class="row box">
    <div class="col">
      <div class="label">Preheat</div>
      <button id="preheatPLA"  disabled>PLA (200/60)</button>
      <button id="preheatPETG" disabled>PETG (240/80)</button>
      <button id="preheatABS"  disabled>ABS (250/100)</button>
    </div>
    <div class="col">
      <div class="label">Cool Down</div>
      <button id="cooldown" disabled>Cool Down (M104 S0; M140 S0)</button>
    </div>
    <div class="col">
      <div class="label">Filament</div>
      <button id="loadFil"  disabled>Load (200¬∞C)</button>
      <button id="unloadFil" disabled>Unload (200¬∞C)</button>
    </div>
        <div class="col">
<div class="row" style="gap:12px; align-items:center; margin:6px 0 10px">
  <label>
    <input type="checkbox" id="autoProbeAging">
    Auto-probe bed before print if last mesh &gt; 30 days
  </label>
  <span id="meshAgeHint" class="muted"></span>
</div>
      <div class="label">Nozzle Prep</div>
      <button id="primeLine" disabled>Wipe + Prime Line</button>
    </div>
      <div class="box col" style="margin-top:8px; max-width:840px">
    <div class="label">Maintenance logbook</div>
    <form id="maintForm" class="row" style="align-items:flex-start">
      <input id="maintDate" type="date" />
      <textarea id="maintNote" class="widen" rows="2" placeholder="What did you do? (e.g., Cleaned bed, lubed Z lead screw)"></textarea>
      <button id="maintSave" type="submit">Save</button>
      <button id="maintReset" type="button">Reset</button>
    </form>

    <div class="row" style="justify-content:space-between; margin-top:4px">
      <div class="muted" id="maintSummary">‚Äî</div>
      <div class="row">
        <button id="maintExport" type="button">Export JSON</button>
        <button id="maintClearAll" type="button">Clear all</button>
      </div>
    </div>

    <table style="width:100%; margin-top:8px">
      <thead>
        <tr><th style="width:120px">Date</th><th>Note</th><th style="width:160px">Actions</th></tr>
      </thead>
      <tbody id="maintTable"></tbody>
    </table>
  </div>
  </div>
</div>

<!-- TAB 8: Filament -->
<div id="filamentTab" class="tabContent">
  <div class="row" style="gap:12px; align-items:flex-start">
    <!-- Form: Add/Edit spool -->
    <form id="spoolForm" class="box col" style="min-width:300px; max-width:420px">
      <div class="label">Spool details</div>
      <div class="row">
        <input id="spBrand"  class="widen" placeholder="Brand (e.g., eSun)"/>
        <input id="spMaterial" class="widen" list="matList" placeholder="Material (PLA/PETG/ABS/TPU/Nylon/‚Ä¶)" />
        <datalist id="matList">
          <option>PLA</option><option>PETG</option><option>ABS</option>
          <option>TPU</option><option>Nylon</option><option>PC</option><option>PVA</option>
        </datalist>
      </div>

      <div class="row">
        <label>√ò
          <select id="spDiameter">
            <option value="1.75" selected>1.75</option>
            <option value="2.85">2.85</option>
          </select> mm
        </label>
        <label>Density
          <input id="spDensity" type="number" step="0.01" min="0.5" max="3" value="1.24" style="width:110px"/> g/cm¬≥
        </label>
      </div>

      <div class="row">
        <input id="spColorName" class="widen" placeholder="Color name (e.g., Deep Black)"/>
        <label>Hex <input id="spColorHex" type="color" value="#000000" /></label>
        <input id="spFinish" class="widen" placeholder="Finish (matte/silk/carbon/glow)"/>
      </div>

      <div class="row">
        <label>Tare <input id="spTare" type="number" step="1" min="0" value="250" style="width:120px"/> g</label>
        <label>Capacity <input id="spCapacity" type="number" step="1" min="0" value="1000" style="width:120px"/> g</label>
      </div>

      <div class="row">
        <label>Total $ <input id="spCostTotal" type="number" step="0.01" min="0" style="width:110px"/></label>
        <label>$/kg <input id="spCostPerKg" type="number" step="0.01" min="0" style="width:110px"/></label>
      </div>

      <div class="row">
        <input id="spLot" class="widen" placeholder="Lot / batch"/>
        <label>Date <input id="spDate" type="date" style="width:160px"/></label>
      </div>

      <input id="spVendor" class="widen" placeholder="Vendor link (https://‚Ä¶)" />

      <div class="row" style="justify-content:flex-end; gap:8px; margin-top:8px">
        <button id="spReset" type="button">Reset</button>
        <button id="spSave"  type="submit">Save spool</button>
      </div>

      <div class="muted" id="spFormHint">Spool ID: <span id="spIdShow">‚Äî (new)</span></div>
    </form>

    <!-- Library / List -->
    <div class="box col" style="flex:1 1 420px">
      <div class="row" style="gap:8px; flex-wrap:wrap">
        <input id="spSearch" class="widen" placeholder="Search brand/color/ID‚Ä¶"/>
        <select id="spMatFilter">
          <option value="">All materials</option>
          <option>PLA</option><option>PETG</option><option>ABS</option>
          <option>TPU</option><option>Nylon</option><option>PC</option><option>PVA</option>
        </select>
        <label><input id="spOnlyRemaining" type="checkbox" checked/> Only with remaining</label>
        <select id="spSort">
          <option value="remainingDesc" selected>Sort: Most remaining</option>
          <option value="brandAsc">Brand A‚ÜíZ</option>
          <option value="materialAsc">Material A‚ÜíZ</option>
          <option value="createdDesc">Newest first</option>
        </select>
        <label style="margin-left:auto">Active:
          <select id="spActiveSel" style="min-width:200px"></select>
        </label>
        <button id="spPrintLbl" type="button">Print label</button>
      </div>

      <div class="row" style="gap:8px; margin-top:6px">
        <button id="spWeigh"  type="button">Weigh now</button>
        <button id="spDeduct5" type="button">Deduct‚Ä¶</button>
        <button id="spMarkEmpty" type="button">Mark as empty</button>
      </div>

      <table style="width:100%; margin-top:10px">
        <thead>
          <tr>
            <th>ID</th><th>Brand</th><th>Mat</th><th>Color</th>
            <th>√ò</th><th>Remain (g)</th><th>Cap (g)</th><th>Actions</th>
          </tr>
        </thead>
        <tbody id="spTable"></tbody>
      </table>
      <div class="muted" id="spSummary" style="margin-top:6px">‚Äî</div>
    </div>
  </div>
</div>

<!-- TAB 9: Diagnostics -->
<div id="diagTab" class="tabContent">
  <div class="row box">
    <button id="parseM115Btn" type="button">Parse M115 ‚Üí Fields</button>
    <button id="parseM122Btn" type="button">Parse M122 ‚Üí Fields</button>
  </div>
<table id="m115Table" style="border-collapse:collapse;width:100%;max-width:900px">
  <thead><tr><th style="text-align:left;width:240px">Field</th><th style="text-align:left">Value</th></tr></thead>
  <tbody></tbody>
</table>
<h3>TMC Diagnostics (M122)</h3>
<table id="tmcTable" style="border-collapse:collapse; width:100%; max-width:900px">
  <thead>
    <tr>
      <th style="width:60px">Axis</th>
      <th>Driver</th>
      <th>RMS (mA)</th>
      <th>Microsteps</th>
      <th>stealthChop</th>
      <th>spreadCycle</th>
      <th>OTPW</th>
      <th>Error</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>X</td><td id="tmc_X_drv">‚Äî</td><td id="tmc_X_rms">‚Äî</td><td id="tmc_X_ms">‚Äî</td><td id="tmc_X_sc">‚Äî</td><td id="tmc_X_sp">‚Äî</td><td id="tmc_X_ot">‚Äî</td><td id="tmc_X_er">‚Äî</td></tr>
    <tr><td>Y</td><td id="tmc_Y_drv">‚Äî</td><td id="tmc_Y_rms">‚Äî</td><td id="tmc_Y_ms">‚Äî</td><td id="tmc_Y_sc">‚Äî</td><td id="tmc_Y_sp">‚Äî</td><td id="tmc_Y_ot">‚Äî</td><td id="tmc_Y_er">‚Äî</td></tr>
    <tr><td>Z</td><td id="tmc_Z_drv">‚Äî</td><td id="tmc_Z_rms">‚Äî</td><td id="tmc_Z_ms">‚Äî</td><td id="tmc_Z_sc">‚Äî</td><td id="tmc_Z_sp">‚Äî</td><td id="tmc_Z_ot">‚Äî</td><td id="tmc_Z_er">‚Äî</td></tr>
    <tr><td>E</td><td id="tmc_E_drv">‚Äî</td><td id="tmc_E_rms">‚Äî</td><td id="tmc_E_ms">‚Äî</td><td id="tmc_E_sc">‚Äî</td><td id="tmc_E_sp">‚Äî</td><td id="tmc_E_ot">‚Äî</td><td id="tmc_E_er">‚Äî</td></tr>
  </tbody>
</table>
</div>

<!-- TAB 10: G-code Sender -->
<div id="senderTab" class="tabContent">
  <div class="row box">
    <input type="file" id="gcodeFile" accept=".gcode,.gco,.gc,.txt" />
    <button id="sendGcode" disabled>Send File</button>
    <button id="cancelSend" disabled>Cancel</button>
    <div class="progress"><div id="sendProgress"></div></div>
    <span id="sendStatus" class="muted">Idle</span>
    <span id="etaStatus" class="muted" style="margin-left:10px"></span>
  </div>
  <p class="muted">Sends the file line-by-line over serial. Comments/blank lines are skipped. This is best for short jobs, calibration, or macros.</p>


<div class="gp-wrap" id="gcodePreview">
  <div id="previewBusy" class="muted" style="display:none">Building preview‚Ä¶</div>
  <div class="gp-bar">
    <label>Layer
      <input type="range" id="layerScrub" min="0" max="0" value="0" step="1">
      <span id="layerInfo">‚Äî</span>
    </label>
    <label>
      <input type="checkbox" id="showTravel" checked>
      Show travel
    </label>
    <button id="zoomFit">Fit</button>
    <button id="zoom1">1:1</button>
    <button id="resetPan">Center</button>
  </div>

  <div class="gp-canvas">
    <canvas id="gcodeCanvas"></canvas>
  </div>

  <div class="gp-legend">
    <span class="gp-chip"><span class="gp-dot prev"></span> Previous layers</span>
    <span class="gp-chip"><span class="gp-dot curr"></span> Current layer</span>
    <span class="gp-chip"><span class="gp-dot travel"></span> Travel moves</span>
  </div>
    </div>
    <!-- End of senderTab -->
    </div>

<!-- TAB 11: Telegram -->
<div id="telegramTab" class="tabContent">
  <h2>Telegram Notifications</h2>
  <div class="box" style="max-width:600px; display:flex; flex-direction:column; gap:8px;">
    <label class="row" style="gap:8px; align-items:center;">
      <span style="min-width:80px">Bot Token</span>
      <input id="tgToken" type="text" class="widen" placeholder="123456789:ABCDEF..." />
    </label>
    <label class="row" style="gap:8px; align-items:center;">
      <span style="min-width:80px">Chat ID</span>
      <input id="tgChatId" type="text" class="widen" placeholder="123456789" />
    </label>
    <div class="row" style="gap:12px; margin-top:8px; flex-wrap:wrap;">
      <label><input id="tgStartChk" type="checkbox" /> Notify on start</label>
      <label><input id="tgDoneChk" type="checkbox" /> Notify on completion</label>
      <label><input id="tgCancelChk" type="checkbox" /> Notify on cancel/error</label>
    </div>
    <!-- Custom test message input -->
    <label class="row" style="gap:8px; align-items:center;">
      <span style="min-width:80px">Test Msg</span>
      <input id="tgTestMessage" type="text" class="widen" placeholder="Test message text" />
    </label>
    <div class="row" style="gap:8px; margin-top:8px; flex-wrap:wrap;">
      <button id="tgSave" type="button">Save Settings</button>
      <button id="tgTest" type="button">Send Test Message</button>
    </div>
    <div class="muted" id="tgStatus">‚Äî</div>
    <div class="muted">Your token, chat ID and test message are stored locally in your browser.</div>
    <!-- FAQ for obtaining a Telegram bot token -->
    <details style="margin-top:8px;">
      <summary>How do I get a bot token?</summary>
      <p style="margin-left:16px; margin-top:4px;">1. Open Telegram and search for <code>@BotFather</code>. Send <code>/newbot</code> and follow the instructions; BotFather will give you a token like <code>123456:ABCDEF‚Ä¶</code>.</p>
      <p style="margin-left:16px;">2. Send a message to your new bot, then open <code>https://api.telegram.org/bot&lt;token&gt;/getUpdates</code> in a browser. In the JSON response, find <code>message.chat.id</code>; that value is your chat ID.</p>
    </details>
  </div>
</div>



  <!-- Preflight Modal -->
<div id="preOverlay" aria-hidden="true" style="display:none"></div>
<div id="preModal" role="dialog" aria-modal="true" aria-labelledby="preTitle" style="display:none">
  <div id="preCard">
    <div id="preHeader">
      <h3 id="preTitle">Pre-flight checks</h3>
      <button id="preClose" type="button" aria-label="Close">Close</button>
    </div>
    <div id="preBody">
      <div class="muted" style="margin-bottom:8px">
        File: <strong id="preFileName">‚Äî</strong> ¬∑
        Guardrail: <strong id="preGuardrail">‚Äî</strong> ¬∑
        Temps (hot/bed): <strong id="preTemps">‚Äî</strong> ¬∑
        Mode: <strong id="preMode">‚Äî</strong> ¬∑
        Homed: <strong id="preHomed">‚Äî</strong>
      </div>

      <fieldset style="border:none; padding:0; margin:0 0 8px 0;">
        <legend class="label" style="margin-bottom:6px">Confirm all:</legend>
        <label><input type="checkbox" class="preChk" id="chkBedClear"> Bed is clear (no clips, tools, hands, pets üê±)</label><br>
        <label><input type="checkbox" class="preChk" id="chkObstructions"> Gantry path clear (cables, spool, camera arms)</label><br>
        <label><input type="checkbox" class="preChk" id="chkFilament"> Correct filament loaded & nozzle clean</label><br>
        <label><input type="checkbox" class="preChk" id="chkAdhesion"> Adhesion ready (sheet, glue, texture)</label><br>
        <label><input type="checkbox" class="preChk" id="chkZSafe"> Z head parked safely (‚â•10 mm)</label>
      </fieldset>

      <div class="row" style="margin:8px 0 12px">
        <button id="preHome" type="button">Home Now (G28)</button>
        <button id="prePark" type="button">Park Head (X0 Y0 Z10)</button>
        <label style="margin-left:auto">
          <input type="checkbox" id="preSkip"> Don‚Äôt ask again (this session)
        </label>
      </div>

      <div class="row" style="justify-content:flex-end; gap:8px">
        <button id="preCancel" type="button">Cancel</button>
        <button id="preStart"  type="button" disabled>Start Print</button>
      </div>
    </div>
  </div>
</div>

</div>

<!-- TAB 11: About -->
<div id="aboutTab" class="tabContent">
  <div class="aboutCard">
    <h2>About</h2>
    <div class="kv"><span>Author: issypup</span></div>
    <div class="kv"><span>Date: 10 August 2025</span></div>
    <p>This tool helps manage 3D printer tasks / maintenance from your browser, it needs a web serial capable browser</p>
  </div>
<!-- Easter Egg Modal -->
<div id="eeOverlay" aria-hidden="true" style="display:none"></div>
<div id="eeModal" role="dialog" aria-modal="true" aria-labelledby="eeTitle" style="display:none">
  <div id="eeCard">
    <div id="eeHeader">
      <h3 id="eeTitle">Still Printing ‚Äî (Still Alive Parody)</h3>
      <button id="eeClose" type="button" aria-label="Close">Close</button>
    </div>
    <div id="eeBody"></div>
  </div>
</div>
</div>

<div id="footerStatus">
  <span id="lastCmd">Last Cmd: ‚Äî</span>
  <span>GitHub Pages ready ¬∑ LocalStorage only</span>
</div>

<script>
'use strict';

/* =========================================================
   THEME TOGGLING
   Provides a dark/light mode toggle. The current theme
   preference is stored in localStorage. On page load the
   saved theme (or system preference) is applied to the
   document.documentElement. A button with id="themeToggle"
   toggles between modes and updates its label accordingly.
========================================================= */
function initTheme() {
  try {
    const saved = localStorage.getItem('theme');
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const shouldDark = saved ? (saved === 'dark') : prefersDark;
    if (shouldDark) document.documentElement.classList.add('dark');
    else document.documentElement.classList.remove('dark');
  } catch (ex) {
    // Fail silently if localStorage disabled
  }
}

function toggleTheme() {
  const isDark = document.documentElement.classList.toggle('dark');
  try {
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
  } catch (ex) {
    /* ignore */
  }
  updateThemeToggleText();
}

function updateThemeToggleText() {
  const btn = document.getElementById('themeToggle');
  if (!btn) return;
  const isDark = document.documentElement.classList.contains('dark');
  btn.textContent = isDark ? 'Light Mode' : 'Dark Mode';
}

// Immediately apply saved or preferred theme before the rest of the UI draws
initTheme();

// Defer binding of the toggle button until DOM ready
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('themeToggle');
  if (btn) btn.addEventListener('click', toggleTheme);
  // Update the button text once DOM exists
  updateThemeToggleText();
});

/* =========================================================
   1) DOM REFERENCES (all const)
========================================================= */

let oneShotCapture = null;









// --- Helpers to read previous PID from storage ---
function _getPrevPid(which) {
  try {
    const raw = localStorage.getItem('pidPrev:' + which);
    if (!raw) return null;
    const j = JSON.parse(raw);
    if (Number.isFinite(j?.Kp) && Number.isFinite(j?.Ki) && Number.isFinite(j?.Kd)) return j;
  } catch {}
  return null;
}

// Tiny UI updater that ONLY touches the current <div>, not the stored "Prev"
function _writePidResultDiv(which, Kp, Ki, Kd) {
  const id = (which === 'bed') ? 'pidBedResult' : 'pidHotResult';
  const el = document.getElementById(id);
  const fmt = n => Number.isFinite(n) ? (+n).toFixed(2) : '‚Äî';
  if (el) el.textContent = `Kp: ${fmt(Kp)} ¬∑ Ki: ${fmt(Ki)} ¬∑ Kd: ${fmt(Kd)}`;
}

// --- Main action: revert and save ---
async function revertPid(which) {
  which = (which === 'bed') ? 'bed' : 'hotend';

  const prev = _getPrevPid(which);
  if (!prev) { logMsg?.(`‚ö† No previous PID stored for ${which}.`); return; }

  // busy guard
  if (which === 'bed'   && (window.pidActiveBed   || window.pidActiveHotend)) { logMsg?.('‚ö† Busy: PID is running.'); return; }
  if (which === 'hotend'&& (window.pidActiveHotend|| window.pidActiveBed))    { logMsg?.('‚ö† Busy: PID is running.'); return; }

  const P = +prev.Kp, I = +prev.Ki, D = +prev.Kd;
  const line = (which === 'bed')
    ? `M304 P${P.toFixed(4)} I${I.toFixed(4)} D${D.toFixed(4)}`
    : `M301 P${P.toFixed(4)} I${I.toFixed(4)} D${D.toFixed(4)}`;

  try {
    const statusEl = document.getElementById((which === 'bed' ? 'pidBedStatus' : 'pidHotStatus'));
    statusEl && (statusEl.textContent = 'Reverting‚Ä¶');

    logMsg?.(`‚Ü©Ô∏è Reverting ${which} PID ‚Üí ${line}; then M500`);

    // send via your app‚Äôs pipeline
    await sendCmd(line);
    if (typeof waitForOk === 'function') await waitForOk();

    await sendCmd('M500');
    if (typeof waitForOk === 'function') await waitForOk();

    _writePidResultDiv(which, P, I, D);  // update current result line
    statusEl && (statusEl.textContent = 'Saved');
    queueLiveDraw?.();
  } catch (e) {
    logMsg?.(`‚ö†Ô∏è Revert failed: ${e?.message || e}`);
  }
}


// --- Wire up buttons (if present) ---
(function(){
  const hotBtn = document.getElementById('pidHotRevertBtn');
  const bedBtn = document.getElementById('pidBedRevertBtn');
  if (hotBtn) {
    hotBtn.addEventListener('click', async () => {
      if (typeof safeConfirm === 'function') {
        if (!safeConfirm('Revert NOZZLE to previous PID and save (M301 + M500)?')) return;
      }
      hotBtn.disabled = true;
      try { await revertPid('hotend'); } finally { hotBtn.disabled = false; }
    });
  }
  if (bedBtn) {
    bedBtn.addEventListener('click', async () => {
      if (typeof safeConfirm === 'function') {
        if (!safeConfirm('Revert BED to previous PID and save (M304 + M500)?')) return;
      }
      bedBtn.disabled = true;
      try { await revertPid('bed'); } finally { bedBtn.disabled = false; }
    });
  }
})();

// --- PID options and manual control (apply, overshoot transforms, debug toggle) ---
(function(){
  // Apply results checkbox
  const pidUseCb = document.getElementById('pidUseCb');
  if (pidUseCb) {
    window.pidUseResults = pidUseCb.checked;
    pidUseCb.addEventListener('change', () => {
      window.pidUseResults = pidUseCb.checked;
    });
  }
  // PID debug toggle
  const pidDebugBtn = document.getElementById('pidDebugBtn');
  if (pidDebugBtn) {
    pidDebugBtn.addEventListener('click', async () => {
      pidDebugBtn.disabled = true;
      try {
        logMsg?.('üîß Sending M303 D (toggle PID debug)‚Ä¶');
        await sendCmd('M303 D');
        if (typeof waitForOk === 'function') await waitForOk();
        logMsg?.('üõà PID debug toggled.');
      } catch (e) {
        logMsg?.(`‚ö†Ô∏è PID debug toggle failed: ${e?.message || e}`);
      } finally {
        pidDebugBtn.disabled = false;
      }
    });
  }
  // Helper to update PID result display via _writePidResultDiv
  function updatePidResult(which, p, i, d) {
    if (typeof _writePidResultDiv === 'function') {
      _writePidResultDiv(which === 'Hot' ? 'hotend' : 'bed', p, i, d);
    }
  }
  // Apply manual PID values
  async function applyManualPid(which) {
    const p = parseFloat(document.getElementById(`pid${which}InpP`)?.value);
    const i = parseFloat(document.getElementById(`pid${which}InpI`)?.value);
    const d = parseFloat(document.getElementById(`pid${which}InpD`)?.value);
    if (!(Number.isFinite(p) && Number.isFinite(i) && Number.isFinite(d))) {
      alert('Please enter valid Kp, Ki, Kd values.');
      return;
    }
    const cmd = (which === 'Hot') ? `M301 P${p} I${i} D${d}` : `M304 P${p} I${i} D${d}`;
    try {
      logMsg?.(`üõ† Applying ${which === 'Hot' ? 'nozzle' : 'bed'} PID: P=${p} I=${i} D=${d}`);
      await sendCmd(cmd);
      if (typeof waitForOk === 'function') await waitForOk();
      await sendCmd('M500');
      if (typeof waitForOk === 'function') await waitForOk();
      updatePidResult(which, p, i, d);
      logMsg?.('‚úÖ PID updated and saved (M500).');
    } catch (e) {
      logMsg?.(`‚ö†Ô∏è PID apply failed: ${e?.message || e}`);
    }
  }
  // Compute Zeigler‚ÄìNichols transform values
  function computeZNT(which, mode) {
    const resEl = document.getElementById(which === 'Hot' ? 'pidHotResult' : 'pidBedResult');
    if (!resEl) return null;
    const m = /Kp:\s*([0-9.+-]+)\s*¬∑\s*Ki:\s*([0-9.+-]+)\s*¬∑\s*Kd:\s*([0-9.+-]+)/i.exec(resEl.textContent);
    if (!m) return null;
    let kp = parseFloat(m[1]), ki = parseFloat(m[2]), kd = parseFloat(m[3]);
    if (!(Number.isFinite(kp) && Number.isFinite(ki) && Number.isFinite(kd))) return null;
    let newKp, newKi, newKd;
    if (mode === 'over') {
      newKp = kp * 0.55;
      newKi = ki;
      newKd = kd * 8 / 3;
    } else if (mode === 'noover') {
      newKp = kp / 3;
      newKi = ki;
      newKd = kd * 8 / 3;
    } else {
      return null;
    }
    return { kp: newKp, ki: newKi, kd: newKd };
  }
  // Set manual inputs with new values
  function setManualInputs(which, vals) {
    document.getElementById(`pid${which}InpP`).value = vals.kp.toFixed(3);
    document.getElementById(`pid${which}InpI`).value = vals.ki.toFixed(3);
    document.getElementById(`pid${which}InpD`).value = vals.kd.toFixed(3);
  }
  // Wire up manual PID control buttons
  const hotApply   = document.getElementById('pidHotApply');
  const bedApply   = document.getElementById('pidBedApply');
  const hotOver    = document.getElementById('pidHotOver');
  const hotNoOver  = document.getElementById('pidHotNoOver');
  const bedOver    = document.getElementById('pidBedOver');
  const bedNoOver  = document.getElementById('pidBedNoOver');
  if (hotApply)  hotApply.addEventListener('click', () => applyManualPid('Hot'));
  if (bedApply)  bedApply.addEventListener('click', () => applyManualPid('Bed'));
  if (hotOver)   hotOver.addEventListener('click', () => {
    const vals = computeZNT('Hot', 'over');
    if (!vals) { alert('No autotune result to transform.'); return; }
    setManualInputs('Hot', vals);
    applyManualPid('Hot');
  });
  if (hotNoOver) hotNoOver.addEventListener('click', () => {
    const vals = computeZNT('Hot', 'noover');
    if (!vals) { alert('No autotune result to transform.'); return; }
    setManualInputs('Hot', vals);
    applyManualPid('Hot');
  });
  if (bedOver)   bedOver.addEventListener('click', () => {
    const vals = computeZNT('Bed', 'over');
    if (!vals) { alert('No autotune result to transform.'); return; }
    setManualInputs('Bed', vals);
    applyManualPid('Bed');
  });
  if (bedNoOver) bedNoOver.addEventListener('click', () => {
    const vals = computeZNT('Bed', 'noover');
    if (!vals) { alert('No autotune result to transform.'); return; }
    setManualInputs('Bed', vals);
    applyManualPid('Bed');
  });
})();








function captureReplyOnce({ doneOnOk = true } = {}) {
  if (oneShotCapture) throw new Error('capture already active');
  return new Promise((resolve, reject) => {
    oneShotCapture = { buf: [], resolve, reject, doneOnOk };
  });
}

const _fmt1 = v => Number.isFinite(v) ? (+v).toFixed(1) : '‚Äî';
const _fmt0 = v => Number.isFinite(v) ? Math.round(v)    : '‚Äî';

function inferKuTuFromPid(kp, ki, kd, rule /* 'classic' | 'no-overshoot' */) {
  if (!(Number.isFinite(kp) && Number.isFinite(ki) && Number.isFinite(kd))) return null;

  const fromClassic = () => {
    const Ku = kp / 0.6;
    const TuA = 2 * kp / ki;    // from Ki
    const TuB = 8 * kd / kp;    // from Kd
    const Tu = (TuA + TuB) / 2; // average; they should be nearly equal
    return { Ku, Tu, TuA, TuB, rule: 'classic' };
  };

  const fromNoOv = () => {
    const Ku = kp / 0.2;        // = 5*kp
    const TuA = 2 * kp / ki;    // from Ki
    const TuB = 3 * kd / kp;    // from Kd
    const Tu = (TuA + TuB) / 2;
    return { Ku, Tu, TuA, TuB, rule: 'no-overshoot' };
  };

  if (rule === 'classic') return fromClassic();
  if (rule === 'no-overshoot') return fromNoOv();

  // If rule string is unknown, guess by checking Ti and Td consistency
  const Ti = kp / ki, Td = kd / kp;
  const scoreClassic  = Math.abs(2*Ti - 8*Td); // should be ~0 for classic
  const scoreNoOv     = Math.abs(2*Ti - 3*Td); // should be ~0 for no-overshoot
  return (scoreClassic <= scoreNoOv) ? fromClassic() : fromNoOv();
}

let lastHomeHintAt = 0;  // when we last saw a "homing-ish" line

let _audioCtx = null;

let _preflightFile = null;

let net = {
  txBytesTotal: 0,
  rxBytesTotal: 0,
  txSince: 0,
  rxSince: 0,
  lastSample: performance.now(),
  txRate: 0,
  rxRate: 0,
  latencyEMA: null,   // ms
  timer: null
};

let lastSendTs = null; 

let heaterUnlocked = JSON.parse(localStorage.getItem('heaterUnlocked') || 'false');

//Filament
let spools = [];
let activeSpoolId = null;
let editingId = null;
let _pendingFilament = null;

//UI and State flags
let debugMode      = JSON.parse(localStorage.getItem('debugMode') || 'false');
let criticalDepth = 0;
let pidTargetTemp = null;  
let pidActiveHotend = false;
let pidActiveBed    = false;
let pidTarget = null; // 'hotend', 'bed', or null
let isHomed = false;

// Leveling / Probing flow control
let probeLatch = null; // resolved when G29 T finishes (grid header or DWIN ‚ÄúSettings Stored‚Äù)

//Mesh and Temps
let meshScratch    = Array.from({ length: 4 }, () => Array(4).fill(null));
let temps          = { hot: null, hotTarget: null, bed: null, bedTarget: null };

//Connection lifecycle
let connKind = 'none'; // 'none' | 'virtual' | 'real'
let isConnecting = false;
let isDisconnecting = false;

//Serial ‚Äî device handles
let port           = null;
let reader         = null;
let writer         = null;
let textDecoder    = null;

//Comms - I/O state, buffers, timers
let reading        = false;
let rxBuffer       = '';
let cancelStream   = false;
let captureMode    = null; // null | 'config' | 'diag'
let tempTimer      = null;
let postPrintTimer = null;

//Read and Telemetry
let waitingResolvers = []; // (kept for compatibility)
let isBusyProcessing  = false;
let lastOkAt          = 0;
let pendingOk      = []; // queue for waitForOk()

//Virtual printer
let virtualMode = false;
let vSimTimer = null;

//Easter Egg
let streak = 0;

let previewWorkerUrl = null;
let previewWorker = null;

// State
let _camMode = 'mjpeg';                // 'mjpeg' | 'webrtc'
let _rtcStream = null;                 // MediaStream for WebRTC
let _drawTimer = null;                 // canvas draw interval

// Timelapse
let _tlRecorder = null;                // MediaRecorder for canvas stream
let _tlChunks = [];
let _tlDrawing = null;                 // interval ID while recording

const pidCap = { kind: null, pending: false, kp: null, ki: null, kd: null, committed: false };

const SETTINGS_KEY = 'settings'; // change if your app uses another key




// Webcam DOM
const camModeMjpeg   = document.getElementById('camModeMjpeg');
const camModeWebrtc  = document.getElementById('camModeWebrtc');

const mjpegControls  = document.getElementById('mjpegControls');
const webrtcControls = document.getElementById('webrtcControls');

const mjpegUrl   = document.getElementById('mjpegUrl');
const mjpegStart = document.getElementById('mjpegStart');
const mjpegStop  = document.getElementById('mjpegStop');

const rtcStart   = document.getElementById('rtcStart');
const rtcStop    = document.getElementById('rtcStop');
const rtcDevices = document.getElementById('rtcDevices');

const mjpegImg   = document.getElementById('mjpegImg');
const rtcVideo   = document.getElementById('rtcVideo');
const camCanvas  = document.getElementById('camCanvas');

const snapBtn       = document.getElementById('snapBtn');
const snapDownload  = document.getElementById('snapDownload');

const tlFps      = document.getElementById('tlFps');
const tlScale    = document.getElementById('tlScale');
const tlStart    = document.getElementById('tlStart');
const tlStop     = document.getElementById('tlStop');
const tlDownload = document.getElementById('tlDownload');

// MJPEG multi-camera controls
const mjpegAdd    = document.getElementById('mjpegAdd');
const mjpegList   = document.getElementById('mjpegList');

// Octolapse controls
const octoStart   = document.getElementById('octoStart');
const octoStop    = document.getElementById('octoStop');
const octoDownload= document.getElementById('octoDownload');

// Octolapse state
let _octoRecorder = null;
let _octoChunks   = [];
let octoActive    = false;
let octoLastLayer = -1;
let octoLayerForLine = null;

const camHint = document.getElementById('camHint');

// Telegram DOM
const tgToken     = document.getElementById('tgToken');
const tgChatId    = document.getElementById('tgChatId');
const tgStartChk  = document.getElementById('tgStartChk');
const tgDoneChk   = document.getElementById('tgDoneChk');
const tgCancelChk = document.getElementById('tgCancelChk');
const tgSave      = document.getElementById('tgSave');
const tgTest      = document.getElementById('tgTest');
const tgStatus    = document.getElementById('tgStatus');
const tgTestMsg   = document.getElementById('tgTestMessage');

const BEEP_BROWSER_ON = true;   // browser chime via Web Audio
const BEEP_PRINTER_ON = false;  // send M300 to the printer (off by default)
const primeLine = document.getElementById('primeLine');

// =============== FILAMENT: DOM refs ===============
const spoolForm = document.getElementById('spoolForm');
const spIdShow = document.getElementById('spIdShow');
const spBrand = document.getElementById('spBrand');
const spMaterial = document.getElementById('spMaterial');
const spDiameter = document.getElementById('spDiameter');
const spDensity = document.getElementById('spDensity');
const spColorName = document.getElementById('spColorName');
const spColorHex = document.getElementById('spColorHex');
const spFinish = document.getElementById('spFinish');
const spTare = document.getElementById('spTare');
const spCapacity = document.getElementById('spCapacity');
const spCostTotal = document.getElementById('spCostTotal');
const spCostPerKg = document.getElementById('spCostPerKg');
const spLot = document.getElementById('spLot');
const spDate = document.getElementById('spDate');
const spVendor = document.getElementById('spVendor');
const spReset = document.getElementById('spReset');
const spSave = document.getElementById('spSave');

const spSearch = document.getElementById('spSearch');
const spMatFilter = document.getElementById('spMatFilter');
const spOnlyRemaining = document.getElementById('spOnlyRemaining');
const spSort = document.getElementById('spSort');
const spActiveSel = document.getElementById('spActiveSel');
const spPrintLbl = document.getElementById('spPrintLbl');

const spWeigh = document.getElementById('spWeigh');
const spDeduct5 = document.getElementById('spDeduct5');
const spMarkEmpty = document.getElementById('spMarkEmpty');

const spTable = document.getElementById('spTable');
const spSummary = document.getElementById('spSummary');

//Toggles and core controls
const debugToggle     = document.getElementById('debugToggle');
const virtualToggle = document.getElementById('virtualToggle');
const connectBtn      = document.getElementById('connectBtn');
const disconnectBtn   = document.getElementById('disconnectBtn');
const sendCmdBtn      = document.getElementById('sendCmdBtn');
const clearLogBtn     = document.getElementById('clearLogBtn');

//Log/UI text
const printerLog      = document.getElementById('printerLog');
window.logBox = printerLog;
const lastUpdated     = document.getElementById('lastUpdated');
const lastCmd         = document.getElementById('lastCmd');
const activityBadge   = document.getElementById('activityBadge');
const connBadge       = document.getElementById('connBadge');
const printerNameEl = document.getElementById('printerName');

//Top status pills
const topHotendPill   = document.getElementById('topHotendPill');
const topBedPill      = document.getElementById('topBedPill');
const topHotendText   = document.getElementById('topHotend');
const topBedText      = document.getElementById('topBed');
const etaPill = document.getElementById('etaPill');

//Manual G-code
const manualCmd       = document.getElementById('manualCmd');

//Leveling UI
const readMeshBtn     = document.getElementById('readMeshBtn');
const exportMeshBtn   = document.getElementById('exportMeshBtn');
const meshInput       = document.getElementById('meshInput');
const screwTable      = document.getElementById('screwTable');
const levelPrinterSelect = document.getElementById('levelPrinterSelect');
const unsupportedMsg     = document.getElementById('unsupportedMsg');
const cr6seLevelWrap     = document.getElementById('cr6seLevelWrap');
const resetBtn        = document.getElementById('resetBtn');

//PID UI
const bedPidBtn       = document.getElementById('bedPidBtn');
const hotendPidBtn    = document.getElementById('hotendPidBtn');

//Temps and fan
const hotendSet       = document.getElementById('hotendSet');
const bedSet          = document.getElementById('bedSet');
const hotendApply     = document.getElementById('hotendApply');
const hotendOff       = document.getElementById('hotendOff');
const bedApply        = document.getElementById('bedApply');
const bedOff          = document.getElementById('bedOff');
const hotendNow       = document.getElementById('hotendNow');
const bedNow          = document.getElementById('bedNow');
const fanSlider       = document.getElementById('fanSlider');
const fanVal          = document.getElementById('fanVal');
const fanApply        = document.getElementById('fanApply');
const fanOff          = document.getElementById('fanOff');
const unlockTempsBtn = document.getElementById('unlockTempsBtn');
const unlockHint     = document.getElementById('unlockHint');
const MAX_HOTEND = 250;
const MAX_BED    = 110;

//Movement UI
const jogStep         = document.getElementById('jogStep');
const homeAll         = document.getElementById('homeAll');
const disableMotors   = document.getElementById('disableMotors');
const xMinus          = document.getElementById('xMinus');
const xPlus           = document.getElementById('xPlus');
const yMinus          = document.getElementById('yMinus');
const yPlus           = document.getElementById('yPlus');
const zMinus          = document.getElementById('zMinus');
const zPlus           = document.getElementById('zPlus');
const parkHead        = document.getElementById('parkHead');
const posXEl          = document.getElementById('posX');
const posYEl          = document.getElementById('posY');
const posZEl          = document.getElementById('posZ');

//eeprom and Config
const configBox       = document.getElementById('configBox');

//Diagnostics
const fwInfo          = document.getElementById('fwInfo');
const diagBox         = document.getElementById('diagBox');

//Sender
const gcodeFile       = document.getElementById('gcodeFile');
const sendGcode       = document.getElementById('sendGcode');
const cancelSend      = document.getElementById('cancelSend');
const sendProgress    = document.getElementById('sendProgress');
const sendStatus      = document.getElementById('sendStatus');

//Maintenance controls
const preheatPLA      = document.getElementById('preheatPLA');
const preheatPETG     = document.getElementById('preheatPETG');
const preheatABS      = document.getElementById('preheatABS');
const cooldown        = document.getElementById('cooldown');
const loadFil         = document.getElementById('loadFil');
const unloadFil       = document.getElementById('unloadFil');

//Easter egg
  const eeOverlay = document.getElementById('eeOverlay');
  const eeModal   = document.getElementById('eeModal');
  const eeClose   = document.getElementById('eeClose');
  const eeBody    = document.getElementById('eeBody');

const pidEls = {
  hot: {
    status: document.getElementById('pidHotStatus'),
    bar:    document.getElementById('pidHotBar'),
    info:   document.getElementById('pidHotInfo'),
    res:    document.getElementById('pidHotResult'),
    prev:   document.getElementById('pidHotPrev'),
    dbgBox: document.getElementById('pidHotDbgBox'),
    dbg:    document.getElementById('pidHotDbg')
  },
  bed: {
    status: document.getElementById('pidBedStatus'),
    bar:    document.getElementById('pidBedBar'),
    info:   document.getElementById('pidBedInfo'),
    res:    document.getElementById('pidBedResult'),
    prev:   document.getElementById('pidBedPrev'),
    dbgBox: document.getElementById('pidBedDbgBox'),
    dbg:    document.getElementById('pidBedDbg')
  }
};

const pidCurr = {
  hotend: null, // {Kp,Ki,Kd,ts} after a run
  bed: null
};

/* =========================================================
   2) CONSTANTS (maps, regex, fixed values)
========================================================= */

(function () {
  const fmt = (n, d = 4) => Number.isFinite(n) ? (+n).toFixed(d) : '‚Äî';

  const ids = (which) => {
    const bed = (which === 'bed');
    return {
      boxId:  bed ? 'pidBedDbgBox'  : 'pidHotDbgBox',
      preId:  bed ? 'pidBedDbg'     : 'pidHotDbg',
      metaId: bed ? 'pidBedDbgMeta' : 'pidHotDbgMeta',
    };
  };

  function ensureEls(which) {
    const { boxId, preId, metaId } = ids(which);
    let box = document.getElementById(boxId);
    let pre = document.getElementById(preId);
    if (!box && pre) box = pre.closest('details') || null;

    let metaEl = document.getElementById(metaId);
    // If we have a <details> and <pre> but no meta line, create one before the <pre>
    if (!metaEl && box && pre) {
      metaEl = document.createElement('div');
      metaEl.id = metaId;
      metaEl.className = 'pidDebugMeta muted';
      metaEl.style.margin = '6px 0';
      box.insertBefore(metaEl, pre);
    }
    return { box, pre, metaEl };
  }

  // Start: clear the log and open the <details>
  window.pidDebugStart ||= function (which) {
    const { box, pre } = ensureEls(which);
    if (pre) pre.textContent = '';
    if (box) box.setAttribute('open', '');
  };

  // Append a line to the <pre>
  window.pidDebugLine ||= function (which, line) {
    const { pre } = ensureEls(which);
    if (!pre || !line) return;
    pre.textContent += (pre.textContent ? '\n' : '') + line;
    pre.scrollTop = pre.scrollHeight;
  };

  // End marker
  window.pidDebugEnd ||= function (which, ok) {
    window.pidDebugLine?.(which, ok ? '‚Äî autotune finished ‚Äî' : '‚Äî autotune failed ‚Äî');
  };

  // Meta summary (rule, bias, d, min/max, Ku, Tu)
  // Call site example: pidDebugMeta(kind, { rule, bias, d, min, max, Ku, Tu })
  window.pidDebugMeta ||= function (which, meta) {
    const { metaEl } = ensureEls(which);

    const rule = (meta?.rule) ? String(meta.rule) : '‚Äî';
    const bias = Number.isFinite(meta?.bias) ? fmt(meta.bias, 2) : '‚Äî';
    const d    = Number.isFinite(meta?.d)    ? fmt(meta.d, 2)    : '‚Äî';
    const vmin = Number.isFinite(meta?.min)  ? fmt(meta.min, 4)  : '‚Äî';
    const vmax = Number.isFinite(meta?.max)  ? fmt(meta.max, 4)  : '‚Äî';
    const ku   = Number.isFinite(meta?.Ku)   ? fmt(meta.Ku, 4)   : '‚Äî';
    const tu   = Number.isFinite(meta?.Tu)   ? fmt(meta.Tu, 4)   : '‚Äî';

    const line = `Rule: ${rule} ¬∑ bias:${bias} d:${d} ¬∑ min:${vmin} max:${vmax} ¬∑ Ku:${ku} Tu:${tu}`;

    if (metaEl) {
      metaEl.textContent = line;
    } else {
      // If there's no meta container, just log it into the <pre>
      window.pidDebugLine?.(which, line);
    }
  };
})();

const isDebug = () => !!window.debugMode;

const HOME_SIG_DEFAULT = { x: 117, y: 117, z: 10.0, tolX: 2.0, tolY: 2.0, tolZ: 4.0 };

connectBtn?.addEventListener('click', () => connectPrinter());

//Mesh and screws map
const screwAffects = {
  A1: [[0,0],[0,1],[1,0],[1,1]],
  A2: [[0,1],[0,2],[1,1],[1,2]],
  A3: [[0,2],[0,3],[1,2],[1,3]],
  B1: [[1,0],[1,1],[2,0],[2,1]],
  B2: [[1,1],[1,2],[2,1],[2,2]],
  B3: [[1,2],[1,3],[2,2],[2,3]],
  B4: [[2,3],[1,3],[3,3]],
  C1: [[2,0],[2,1],[3,0],[3,1]],
  C2: [[2,1],[2,2],[3,1],[3,2]],
  C3: [[2,2],[2,3],[3,2],[3,3]],
  C4: [[3,3]]
};

document.getElementById('parseM503Btn')?.addEventListener('click', async () => {
  try {
    const raw = await readFullBlock('M503');
    if (!raw.trim()) throw new Error('empty');
    const cfg = parseM503Response(raw);
    renderM503Table('#m503Table', cfg);
    window._lastParsedCfg = cfg;
  } catch (err) {
    console.error('Failed to read M503:', err);
    const fallback = prompt('No M503 received.\nPaste M503 output to parse:') || '';
    const cfg = parseM503Response(fallback);
    renderM503Table('#m503Table', cfg);
    window._lastParsedCfg = cfg;
  }
});

document.getElementById('parseM115Btn')?.addEventListener('click', async () => {
  try {
    stopTempPolling?.(); // optional, avoids temperature spam while capturing
    const raw = await readFullBlock('M115'); // waits until full banner and 'ok' received

    if (!raw || !raw.trim()) {
      // If no reply, ask the user
      const fallback = prompt('No M115 received.\nPaste firmware banner to parse:');
      if (!fallback) return; // user cancelled
      renderM115Table('#m115Table', parseM115Response(fallback));
      return;
    }

    renderM115Table('#m115Table', parseM115Response(raw));
  } catch (err) {
    console.error('Failed to read M115:', err);
    const fallback = prompt('No M115 received.\nPaste firmware banner to parse:');
    if (!fallback) return;
    renderM115Table('#m115Table', parseM115Response(fallback));
  }
});


function pidDebugStart(which) {
  const k = (which === 'bed') ? 'bed' : 'hot';
  if (pidEls[k]?.dbg)  pidEls[k].dbg.textContent = '';
  if (pidEls[k]?.dbgBox) {
    if (isDebug?.()) pidEls[k].dbgBox.setAttribute('open', '');
    else             pidEls[k].dbgBox.removeAttribute('open');
  }
}

function pidDebugLine(which, line) {
  const k = (which === 'bed') ? 'bed' : 'hot';
  const pre = pidEls[k]?.dbg;
  if (!pre || !line) return;
  pre.textContent += (pre.textContent ? '\n' : '') + line;
  pre.scrollTop = pre.scrollHeight;
}

function pidDebugEnd(which, ok) {
  // Optional: stamp a final line
  pidDebugLine(which, ok ? '‚Äî autotune finished ‚Äî' : '‚Äî autotune failed ‚Äî');
}


async function populateRtcDevices() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const vids = devices.filter(d => d.kind === 'videoinput');
    rtcDevices.innerHTML = '';
    vids.forEach(v => {
      const o = document.createElement('option');
      o.value = v.deviceId; o.textContent = v.label || `Camera ${rtcDevices.length+1}`;
      rtcDevices.appendChild(o);
    });
  } catch {}
}


function renderM122Fields(ax) {
  const put = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = (v ?? '‚Äî'); };
  for (const a of ['X','Y','Z','E']) {
    const d = ax[a] || {};
    put(`tmc_${a}_drv`, d.driver ?? '‚Äî');
    put(`tmc_${a}_rms`, d.rms ?? '‚Äî');
    put(`tmc_${a}_ms`,  d.msteps ?? '‚Äî');
    put(`tmc_${a}_sc`,  d.stealth ?? '‚Äî');
    put(`tmc_${a}_sp`,  d.spread ?? '‚Äî');
    put(`tmc_${a}_ot`,  d.otpw ?? '‚Äî');
    put(`tmc_${a}_er`,  d.error ?? '‚Äî');
  }
}

camModeMjpeg.addEventListener('change', () => { if (camModeMjpeg.checked) setCamMode('mjpeg'); });
camModeWebrtc.addEventListener('change', () => { if (camModeWebrtc.checked) setCamMode('webrtc'); });
setCamMode('mjpeg');
if (navigator.mediaDevices?.enumerateDevices) { populateRtcDevices(); }

snapBtn.addEventListener('click', () => {
  try {
    const blobUrl = camCanvas.toDataURL('image/png');
    snapDownload.href = blobUrl;
    const dt = new Date().toISOString().replace(/[:.]/g,'-');
    snapDownload.download = `snapshot-${dt}.png`;
    snapDownload.style.display = '';
    snapDownload.click();
    camHint.textContent = 'Snapshot saved.';
  } catch {
    camHint.textContent = 'Snapshot failed (CORS?).';
  }
});

tlStart.addEventListener('click', () => {
  // Canvas as the single source; we already copy MJPEG/RTC into it at ~10fps.
  const fps = Math.min(30, Math.max(1, parseInt(tlFps.value, 10) || 2));
  const stream = camCanvas.captureStream(fps);
  _tlChunks = [];
  try {
    _tlRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
  } catch {
    _tlRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
  }
  _tlRecorder.ondataavailable = e => { if (e.data && e.data.size) _tlChunks.push(e.data); };
  _tlRecorder.onstop = () => {
    const blob = new Blob(_tlChunks, { type: _tlRecorder.mimeType || 'video/webm' });
    const url = URL.createObjectURL(blob);
    tlDownload.href = url;
    tlDownload.style.display = '';
    tlDownload.click();
    tlStatus.textContent = `Saved ${Math.round(blob.size/1024)} KB`;
  };
  _tlRecorder.start(); // start recording frames coming from canvas
  tlStatus.textContent = `Recording‚Ä¶ ${fps} fps`;
  tlDownload.style.display = 'none';
  updateCamUi();
});

tlStop.addEventListener('click', () => {
  if (_tlRecorder && _tlRecorder.state === 'recording') {
    _tlRecorder.stop();
    tlStatus.textContent = 'Finalizing‚Ä¶';
  }
  updateCamUi();
});

rtcStart.addEventListener('click', async () => {
  stopMjpeg();
  try {
    await navigator.mediaDevices.getUserMedia({ video: true }); // prompt
    await populateRtcDevices();
    const deviceId = rtcDevices.value || undefined;
    _rtcStream = await navigator.mediaDevices.getUserMedia({
      video: deviceId ? { deviceId: { exact: deviceId } } : true,
      audio: false
    });
    rtcVideo.srcObject = _rtcStream;
    rtcVideo.style.display = '';
    camHint.textContent = 'Camera live.';
    drawToCanvasFrom(rtcVideo);
  } catch (e) {
    camHint.textContent = 'Camera permission or device error.';
    _rtcStream = null;
  }
  updateCamUi();
});

rtcStop.addEventListener('click', stopRtc);

// --- MJPEG multi-camera handlers ---
mjpegAdd.addEventListener('click', () => {
  const url = mjpegUrl.value.trim();
  if (!url) return;
  // Avoid duplicates
  let exists = false;
  for (const opt of mjpegList.options) {
    if (opt.value === url) { exists = true; break; }
  }
  if (!exists) {
    const o = document.createElement('option');
    o.value = url;
    o.textContent = url;
    mjpegList.appendChild(o);
    // Reveal the list when an entry is added
    mjpegList.style.display = '';
  }
});

mjpegList.addEventListener('change', () => {
  // When selecting a saved MJPEG camera, update the input field
  mjpegUrl.value = mjpegList.value || mjpegUrl.value;
});

// --- Octolapse start/stop handlers ---
octoStart.addEventListener('click', () => {
  // Require a live camera before recording
  const fpsVal = parseInt(tlFps.value, 10) || 10;
  const fps = Math.min(30, Math.max(1, fpsVal));
  const stream = camCanvas.captureStream(fps);
  _octoChunks = [];
  try {
    _octoRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
  } catch {
    _octoRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
  }
  _octoRecorder.ondataavailable = e => { if (e.data && e.data.size) _octoChunks.push(e.data); };
  _octoRecorder.onstop = () => {
    const blob = new Blob(_octoChunks, { type: _octoRecorder.mimeType || 'video/webm' });
    const url = URL.createObjectURL(blob);
    octoDownload.href = url;
    octoDownload.style.display = '';
    octoDownload.click();
    // Reuse the timelapse status indicator for feedback
    tlStatus.textContent = `Octolapse saved ${Math.round(blob.size/1024)} KB`;
  };
  _octoRecorder.start();
  // Immediately pause; we resume briefly on layer change
  _octoRecorder.pause();
  octoActive = true;
  octoLastLayer = -1;
  octoDownload.style.display = 'none';
  camHint.textContent = 'Octolapse active.';
  updateCamUi();
});

octoStop.addEventListener('click', () => {
  if (_octoRecorder && (_octoRecorder.state === 'recording' || _octoRecorder.state === 'paused')) {
    _octoRecorder.stop();
  }
  octoActive = false;
  updateCamUi();
});

/* ====== Telegram integration ====== */
// Load Telegram settings into the UI
function loadTelegramSettings() {
  if (!tgToken) return;
  tgToken.value     = localStorage.getItem('tgToken') || '';
  tgChatId.value    = localStorage.getItem('tgChatId') || '';
  tgStartChk.checked  = localStorage.getItem('tgNotifyStart') === '1';
  tgDoneChk.checked   = localStorage.getItem('tgNotifyDone') === '1';
  tgCancelChk.checked = localStorage.getItem('tgNotifyCancel') === '1';
  tgTestMsg.value   = localStorage.getItem('tgTestMsg') || 'üîî Test message from 3D Printer Utils';
}

// Persist Telegram settings to localStorage
function saveTelegramSettings() {
  if (!tgToken) return;
  localStorage.setItem('tgToken', tgToken.value.trim());
  localStorage.setItem('tgChatId', tgChatId.value.trim());
  localStorage.setItem('tgNotifyStart', tgStartChk.checked ? '1' : '');
  localStorage.setItem('tgNotifyDone',  tgDoneChk.checked  ? '1' : '');
  localStorage.setItem('tgNotifyCancel', tgCancelChk.checked ? '1' : '');
  localStorage.setItem('tgTestMsg', tgTestMsg.value.trim());
}

// Send a generic Telegram message using stored settings
async function sendTelegramMessage(text) {
  const token = localStorage.getItem('tgToken') || '';
  const chat  = localStorage.getItem('tgChatId') || '';
  if (!token || !chat) return false;
  const url = `https://api.telegram.org/bot${encodeURIComponent(token)}/sendMessage`;
  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id: chat, text }),
    });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    return true;
  } catch (err) {
    logMsg?.('‚ö†Ô∏è Telegram error: ' + (err?.message || err));
    return false;
  }
}

// Send a Telegram event message based on settings
function sendTelegramEvent(eventType, fileName = '') {
  const notifyStart  = localStorage.getItem('tgNotifyStart') === '1';
  const notifyDone   = localStorage.getItem('tgNotifyDone')  === '1';
  const notifyCancel = localStorage.getItem('tgNotifyCancel') === '1';
  if (eventType === 'start' && notifyStart) {
    sendTelegramMessage(`üñ®Ô∏è Print started: ${fileName}`);
  } else if (eventType === 'done' && notifyDone) {
    sendTelegramMessage(`‚úÖ Print completed: ${fileName}`);
  } else if (eventType === 'cancel' && notifyCancel) {
    sendTelegramMessage(`‚ùå Print cancelled: ${fileName}`);
  }
}

// Initialize Telegram settings on load
loadTelegramSettings();

// Save button handler
tgSave?.addEventListener('click', () => {
  saveTelegramSettings();
  if (tgStatus) tgStatus.textContent = 'Settings saved.';
});

// Test message handler
tgTest?.addEventListener('click', async () => {
  if (tgStatus) tgStatus.textContent = 'Sending test‚Ä¶';
  const msg = (tgTestMsg?.value || '').trim() || 'üîî Test message from 3D Printer Utils';
  const ok = await sendTelegramMessage(msg);
  if (tgStatus) tgStatus.textContent = ok ? 'Test message sent.' : 'Failed to send test message.';
});


document.getElementById('parseM122Btn')?.addEventListener('click', async () => {
  try {
    stopTempPolling?.();
    const raw = await sendCmd('M122');   // real or virtual returns the full block
    const tmc = parseM122(raw || '');
    renderM122Fields(tmc);
  } catch (err) {
    // Optional offline fallback (remove if you truly never want prompts):
    // const raw = prompt('No M122 received.\nPaste M122 output to parse:') || '';
    // const tmc = parseM122(raw);
    // renderM122Fields(tmc);
  }
});

function onLeaveWebcamTab() {
  stopMjpeg();
  stopRtc();
  if (_tlRecorder && _tlRecorder.state === 'recording') _tlRecorder.stop();
  // Stop Octolapse recording if active
  if (_octoRecorder && (_octoRecorder.state === 'recording' || _octoRecorder.state === 'paused')) {
    _octoRecorder.stop();
  }
  octoActive = false;
}

function setCamMode(mode) {
  _camMode = mode;
  if (mode === 'mjpeg') {
    mjpegControls.style.display = '';
    webrtcControls.style.display = 'none';
  } else {
    mjpegControls.style.display = 'none';
    webrtcControls.style.display = '';
  }
  updateCamUi();
}

function stopDrawing() {
  if (_drawTimer) { clearInterval(_drawTimer); _drawTimer = null; }
}

function stopMjpeg() {
  stopDrawing();
  mjpegImg.src = '';
  mjpegImg.style.display = 'none';
  rtcVideo.style.display = rtcVideo.style.display; // no-op
  updateCamUi();
  camHint.textContent = 'MJPEG stopped.';
}

function stopRtc() {
  stopDrawing();
  if (_rtcStream) {
    _rtcStream.getTracks().forEach(t => t.stop());
    _rtcStream = null;
  }
  rtcVideo.srcObject = null;
  rtcVideo.style.display = 'none';
  camHint.textContent = 'Camera stopped.';
  updateCamUi();
}

function updateCamUi() {
  const live = (_camMode === 'mjpeg' && mjpegImg.src) || (_camMode === 'webrtc' && _rtcStream);
  snapBtn.disabled = !live;
  // Timelapse controls
  tlStart.disabled = !live || (_tlRecorder && _tlRecorder.state === 'recording');
  tlStop.disabled  = !live || !(_tlRecorder && _tlRecorder.state === 'recording');
  // MJPEG / WebRTC mode toggles
  mjpegStart.disabled = _camMode !== 'mjpeg';
  mjpegStop.disabled  = _camMode !== 'mjpeg' || !mjpegImg.src;
  rtcStart.disabled   = _camMode !== 'webrtc';
  rtcStop.disabled    = _camMode !== 'webrtc' || !_rtcStream;
  // Octolapse controls: only enabled when a camera feed is live
  const octoRunning = _octoRecorder && (_octoRecorder.state === 'recording' || _octoRecorder.state === 'paused');
  octoStart.disabled = !live || octoRunning;
  octoStop.disabled  = !live || !octoRunning;
}

function drawToCanvasFrom(el) {
  // Draw at ~10fps for preview; TL has its own cadence via MediaRecorder
  stopDrawing();
  const ctx = camCanvas.getContext('2d', { willReadFrequently: true });
  _drawTimer = setInterval(() => {
    const scale = Math.max(0.1, parseFloat(tlScale.value) || 1);
    const w = Math.floor((el.videoWidth || el.naturalWidth || el.width || 1280) * scale);
    const h = Math.floor((el.videoHeight || el.naturalHeight || el.height || 720) * scale);
    if (w && h) {
      if (camCanvas.width !== w || camCanvas.height !== h) {
        camCanvas.width = w; camCanvas.height = h;
      }
      try { ctx.drawImage(el, 0, 0, w, h); } catch {}
    }
  }, 100); // ~10fps
}

// Trigger Octolapse frame capture on layer change
function handleOctoLayerChange(currLayer) {
  if (!octoActive) return;
  if (typeof currLayer !== 'number') return;
  // Only capture when advancing to a new layer
  if (currLayer <= octoLastLayer) return;
  octoLastLayer = currLayer;
  // If the recorder is paused, resume briefly to record one frame
  if (_octoRecorder && _octoRecorder.state === 'paused') {
    _octoRecorder.resume();
    setTimeout(() => {
      if (_octoRecorder && _octoRecorder.state === 'recording') {
        _octoRecorder.pause();
      }
    }, 150);
  }
}


// Robust block reader: works in virtual or real serial, with diagnostics.
// Drop-in replacement: do NOT start capture here; rely on sendCmd's own capture
async function readFullBlock(cmd, timeoutMs = 7000) {
  try { stopTempPolling?.(); } catch {}
  // clean up any stale capture, just in case
  if (typeof oneShotCapture !== 'undefined' && oneShotCapture) {
    try { oneShotCapture.resolve(oneShotCapture.buf?.join('\n') || ''); } catch {}
    oneShotCapture = null;
  }
  let result;
  try {
    const direct = sendCmd(cmd); // string or promise
    result = await Promise.race([
      Promise.resolve(direct),
      new Promise(res => setTimeout(() => res(''), timeoutMs)),
    ]);
  } finally {
    try { startTempPolling?.(); } catch {}
  }
  return String(result || '');
}



function renderM115Table(containerSelector, parsed) {
  const el = document.querySelector(containerSelector);
  if (!el) return;
  const tbody = el.querySelector('tbody');
  if (!tbody) return;

  const { info = {}, caps = {}, area = null } = parsed || {};
  const rows = [];

  // Primary info
  const order = [
    ['FIRMWARE_NAME','Firmware'],
    ['SOURCE_CODE_URL','Source code URL'],
    ['PROTOCOL_VERSION','Protocol version'],
    ['MACHINE_TYPE','Machine type'],
    ['EXTRUDER_COUNT','Extruder count'],
    ['UUID','UUID'],
  ];
  order.forEach(([key, label]) => {
    if (info[key] != null) rows.push([label, escapeHtml(String(info[key]))]);
  });

  // Add any extra keys we didn't list above
  Object.keys(info).sort().forEach(k => {
    if (order.find(x => x[0] === k)) return; // already added
    rows.push([k.replace(/_/g,' '), escapeHtml(String(info[k]))]);
  });

  // Separator
  if (Object.keys(caps).length) rows.push(['', '', true]);

  // Capabilities (sorted)
  if (Object.keys(caps).length) {
    rows.push(['Capabilities', '']);
    Object.keys(caps).sort().forEach(name => {
      rows.push([`‚Ä¢ ${name}`, caps[name] ? 'Yes' : 'No']);
    });
  }

  // Separator
  if (area) rows.push(['', '', true]);

  // Area (pretty)
  if (area) {
    const full = area.full || {};
    const work = area.work || {};
    const fmin = full.min || {}, fmax = full.max || {};
    const wmin = work.min || {}, wmax = work.max || {};
    rows.push(['Area (full)', `min x:${fmin.x}, y:${fmin.y}, z:${fmin.z} &nbsp; | &nbsp; max x:${fmax.x}, y:${fmax.y}, z:${fmax.z}`]);
    rows.push(['Area (work)', `min x:${wmin.x}, y:${wmin.y}, z:${wmin.z} &nbsp; | &nbsp; max x:${wmax.x}, y:${wmax.y}, z:${wmax.z}`]);
  }

  putTableRows(tbody, rows);
}

function renderM503Table(containerSelector, cfg) {
  const el = document.querySelector(containerSelector);
  if (!el) return;
  const tbody = el.querySelector('tbody');
  if (!tbody) return;

  const rows = [];
  const yesno = v => v == null ? '‚Äî' : (v ? 'On' : 'Off');

  // General
  rows.push(['Units', cfg.units || '‚Äî']);
  rows.push(['Filament settings', cfg.filament?.enabled == null ? '‚Äî' : (cfg.filament.enabled ? 'Enabled' : 'Disabled')]);
  rows.push(['Filament (M200)', cfg.filament?.M200 ? `S=${cfg.filament.M200.S} D=${cfg.filament.M200.D}` : '‚Äî']);
  rows.push(['Home offset (M206)', cfg.homeOffset ? `X=${cfg.homeOffset.X} Y=${cfg.homeOffset.Y} Z=${cfg.homeOffset.Z}` : '‚Äî']);
  rows.push(['Power-loss recovery (M413)', yesno(cfg.powerLossRecovery)]);
  rows.push(['Runout sensor (M412)', yesno(cfg.runout)]);

  rows.push(['', '', true]);

  // Motion
  rows.push(['Steps/mm (M92)', cfg.stepsPerUnit ? `X=${cfg.stepsPerUnit.X} Y=${cfg.stepsPerUnit.Y} Z=${cfg.stepsPerUnit.Z} E=${cfg.stepsPerUnit.E}` : '‚Äî']);
  rows.push(['Max feedrate (M203)', cfg.maxFeedrate ? `X=${cfg.maxFeedrate.X} Y=${cfg.maxFeedrate.Y} Z=${cfg.maxFeedrate.Z} E=${cfg.maxFeedrate.E}` : '‚Äî']);
  rows.push(['Max acceleration (M201)', cfg.maxAccel ? `X=${cfg.maxAccel.X} Y=${cfg.maxAccel.Y} Z=${cfg.maxAccel.Z} E=${cfg.maxAccel.E}` : '‚Äî']);
  rows.push(['Acceleration (M204)', cfg.accel ? `P=${cfg.accel.P} R=${cfg.accel.R} T=${cfg.accel.T}` : '‚Äî']);
  rows.push(['Advanced (M205)', cfg.advanced ? `B=${cfg.advanced.B} S=${cfg.advanced.S} T=${cfg.advanced.T} X=${cfg.advanced.X} Y=${cfg.advanced.Y} Z=${cfg.advanced.Z} E=${cfg.advanced.E}` : '‚Äî']);
  rows.push(['Linear advance (M900)', (cfg.linearAdvance ?? '‚Äî')]);

  rows.push(['', '', true]);

  // Temperatures / PID / Presets
  rows.push(['PID hotend (M301)', cfg.pid?.hotend ? `P=${cfg.pid.hotend.P} I=${cfg.pid.hotend.I} D=${cfg.pid.hotend.D}` : '‚Äî']);
  rows.push(['PID bed (M304)', cfg.pid?.bed ? `P=${cfg.pid.bed.P} I=${cfg.pid.bed.I} D=${cfg.pid.bed.D}` : '‚Äî']);
  rows.push(['Presets (M145)', (cfg.presets && cfg.presets.length)
    ? cfg.presets.map(p => `S${p.S}: H${p.H}/B${p.B}/F${p.F}`).join(', ')
    : '‚Äî']);
  rows.push(['Probe heaters off (C001)', cfg.probeHeatersOff
    ? `S=${cfg.probeHeatersOff.S ? 'On' : 'Off'} H=${cfg.probeHeatersOff.H} B=${cfg.probeHeatersOff.B} W=${cfg.probeHeatersOff.W}`
    : '‚Äî']);

  rows.push(['', '', true]);

  // Retract / Recover / Auto-retract / Z-probe
  rows.push(['Retract (M207)', cfg.retract ? `S=${cfg.retract.S} W=${cfg.retract.W} F=${cfg.retract.F} Z=${cfg.retract.Z}` : '‚Äî']);
  rows.push(['Recover (M208)', cfg.recover ? `S=${cfg.recover.S} W=${cfg.recover.W} F=${cfg.recover.F}` : '‚Äî']);
  rows.push(['Auto-retract (M209)', yesno(cfg.autoRetract)]);
  rows.push(['Z-probe offset (M851)', cfg.zProbeOffset ? `X=${cfg.zProbeOffset.X} Y=${cfg.zProbeOffset.Y} Z=${cfg.zProbeOffset.Z}` : '‚Äî']);

  rows.push(['', '', true]);

  // ABL
  const ablStr = cfg.abl ? `Enabled=${cfg.abl.enabled ? 'Yes' : 'No'}${cfg.abl.fade != null ? `, Fade Z=${cfg.abl.fade}` : ''}` : '‚Äî';
  rows.push(['Auto Bed Leveling (M420)', ablStr]);

  // Mesh (embed a colored table)
  if (cfg.mesh && cfg.mesh.nx && cfg.mesh.ny) {
    const { nx, ny, values } = cfg.mesh;
    const flat = values.flat().filter(v => typeof v === 'number');
    const min = Math.min(...flat), max = Math.max(...flat);
    const range = max - min || 1;

    const td = (z) => {
      let bg = '#eee';
      if (typeof z === 'number') {
        const t = (z - min) / range;
        let r,g,b;
        if (t < 0.5) { const k = t/0.5; r=0; g=Math.round(255*k); b=Math.round(255*(1-k)); }
        else { const k=(t-0.5)/0.5; r=Math.round(255*k); g=Math.round(255*(1-k)); b=0; }
        bg = `rgb(${r},${g},${b})`;
      }
      return `<td style="padding:6px;text-align:center;background:${bg};border:1px solid #ddd">${(z==null)?'':Number(z).toFixed(5)}</td>`;
    };

    const stats = `<div><strong>Mesh:</strong> ${nx}√ó${ny}
      &nbsp;|&nbsp;<strong>Min:</strong> ${min.toFixed(5)}
      &nbsp;|&nbsp;<strong>Max:</strong> ${max.toFixed(5)}
      &nbsp;|&nbsp;<strong>Avg:</strong> ${(flat.reduce((a,b)=>a+b,0)/flat.length).toFixed(5)}
      &nbsp;|&nbsp;<strong>Range:</strong> ${(max-min).toFixed(5)}</div>`;

    const table = `<div style="margin-top:6px">${stats}</div>
      <table style="border-collapse:collapse;margin-top:6px">
        <tbody>
          ${values.map(row => `<tr>${row.map(td).join('')}</tr>`).join('')}
        </tbody>
      </table>`;

    rows.push(['G29 Mesh', table]);
  } else {
    rows.push(['G29 Mesh', '<em>No mesh data</em>']);
  }

  putTableRows(tbody, rows);
}


function escapeHtml(s) {
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

function putTableRows(tbody, rows) {
  tbody.innerHTML = rows.map(([k, v, isSeparator]) => {
    if (isSeparator) {
      return `<tr><td colspan="2" style="padding:8px 0"><hr/></td></tr>`;
    }
    return `<tr>
      <th style="border:1px solid #ddd;padding:6px;text-align:left;background:#fafafa">${escapeHtml(k)}</th>
      <td style="border:1px solid #ddd;padding:6px;text-align:left">${v}</td>
    </tr>`;
  }).join('');
}

function parseM122(text) {
  const axes = { X:{}, Y:{}, Z:{}, E:{} };
  const boolify = v => /^(enabled|true|yes|1)$/i.test(v) ? 'enabled'
                    : /^(disabled|false|no|0)$/i.test(v) ? 'disabled' : String(v);

  const lines = String(text || '')
    .split(/\r?\n/)
    .map(s => s.replace(/^echo:\s*/i, '').trim())
    .filter(s => s && !/^>>\s*M122\b/i.test(s) && !/^ok\b/i.test(s));

  for (const ln of lines) {
    // Axis-prefixed key-value style lines
    // Examples: "X driver: TMC2209", "Y RMS current: 850", "E microsteps: 16",
    //           "Z stealthChop: enabled", "X spreadCycle: disabled", "E otpw: false", "Y error: false"
    let m = ln.match(/^([XYZE])\s+driver:\s*(.+)$/i);
    if (m) { axes[m[1].toUpperCase()].driver = m[2].trim(); continue; }

    m = ln.match(/^([XYZE]).*?\bRMS\s*current:\s*([\d.]+)/i);
    if (m) { axes[m[1].toUpperCase()].rms = +m[2]; continue; }

    m = ln.match(/^([XYZE]).*?\bmicrosteps?:\s*([\d.]+)/i);
    if (m) { axes[m[1].toUpperCase()].msteps = +m[2]; continue; }

    m = ln.match(/^([XYZE]).*?\bstealthchop:\s*(\S+)/i);
    if (m) { axes[m[1].toUpperCase()].stealth = boolify(m[2]); continue; }

    m = ln.match(/^([XYZE]).*?\bspreadcycle:\s*(\S+)/i);
    if (m) { axes[m[1].toUpperCase()].spread = boolify(m[2]); continue; }

    m = ln.match(/^([XYZE]).*?\botpw:\s*(\S+)/i);
    if (m) { axes[m[1].toUpperCase()].otpw = boolify(m[2]); continue; }

    m = ln.match(/^([XYZE]).*?\berror:\s*(\S+)/i);
    if (m) { axes[m[1].toUpperCase()].error = boolify(m[2]); continue; }

    // If you later want more, add patterns here (e.g., CS actual, SG, TSTEP).
  }
  return axes;
}

function _fillMissingM503Fields(cfg, cleanLines) {
  const num = s => (s == null ? null : Number(s));

  // M200 S<mode> D<dia>
  if (!cfg.filament?.M200) {
    const m = cleanLines.find(l => /^M200\b/i.test(l));
    if (m) {
      const g = /M200(?:\s+S(?<S>-?\d+(?:\.\d+)?))?(?:\s+D(?<D>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.filament = cfg.filament || {};
      cfg.filament.M200 = { S: num(g.S), D: num(g.D) };
    }
  }

  // M206 X Y Z
  if (!cfg.homeOffset) {
    const m = cleanLines.find(l => /^M206\b/i.test(l));
    if (m) {
      const g = /M206(?:\s+X(?<X>-?\d+(?:\.\d+)?))?(?:\s+Y(?<Y>-?\d+(?:\.\d+)?))?(?:\s+Z(?<Z>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.homeOffset = { X: num(g.X), Y: num(g.Y), Z: num(g.Z) };
    }
  }

  // M145 S H B F   (can appear multiple times)
  if (!cfg.presets || !cfg.presets.length) {
    cfg.presets = [];
    cleanLines.filter(l => /^M145\b/i.test(l)).forEach(l => {
      const g = /M145(?:\s+S(?<S>\d+))?(?:\s+H(?<H>-?\d+(?:\.\d+)?))?(?:\s+B(?<B>-?\d+(?:\.\d+)?))?(?:\s+F(?<F>-?\d+(?:\.\d+)?))?/i.exec(l)?.groups || {};
      if (g.S != null) cfg.presets.push({ S: Number(g.S), H: num(g.H), B: num(g.B), F: num(g.F) });
    });
  }

  // M301 / M304 PID
  if (!cfg.pid) cfg.pid = {};
  if (!cfg.pid.hotend) {
    const m = cleanLines.find(l => /^M301\b/i.test(l));
    if (m) {
      const g = /M301(?:\s+P(?<P>-?\d+(?:\.\d+)?))?(?:\s+I(?<I>-?\d+(?:\.\d+)?))?(?:\s+D(?<D>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.pid.hotend = { P: num(g.P), I: num(g.I), D: num(g.D) };
    }
  }
  if (!cfg.pid.bed) {
    const m = cleanLines.find(l => /^M304\b/i.test(l));
    if (m) {
      const g = /M304(?:\s+P(?<P>-?\d+(?:\.\d+)?))?(?:\s+I(?<I>-?\d+(?:\.\d+)?))?(?:\s+D(?<D>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.pid.bed = { P: num(g.P), I: num(g.I), D: num(g.D) };
    }
  }

  // M413 S
  if (cfg.powerLossRecovery == null) {
    const m = cleanLines.find(l => /^M413\b/i.test(l));
    if (m) cfg.powerLossRecovery = /S1\b/.test(m);
  }

  // M207 S W F Z
  if (!cfg.retract) {
    const m = cleanLines.find(l => /^M207\b/i.test(l));
    if (m) {
      const g = /M207(?:\s+S(?<S>-?\d+(?:\.\d+)?))?(?:\s+W(?<W>-?\d+(?:\.\d+)?))?(?:\s+F(?<F>-?\d+(?:\.\d+)?))?(?:\s+Z(?<Z>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.retract = { S: num(g.S), W: num(g.W), F: num(g.F), Z: num(g.Z) };
    }
  }

  // M208 S W F
  if (!cfg.recover) {
    const m = cleanLines.find(l => /^M208\b/i.test(l));
    if (m) {
      const g = /M208(?:\s+S(?<S>-?\d+(?:\.\d+)?))?(?:\s+W(?<W>-?\d+(?:\.\d+)?))?(?:\s+F(?<F>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.recover = { S: num(g.S), W: num(g.W), F: num(g.F) };
    }
  }

  // M209 S
  if (cfg.autoRetract == null) {
    const m = cleanLines.find(l => /^M209\b/i.test(l));
    if (m) cfg.autoRetract = /S1\b/.test(m);
  }

  // M851 X Y Z (X/Y may be integers in your dump)
  if (!cfg.zProbeOffset) {
    const m = cleanLines.find(l => /^M851\b/i.test(l));
    if (m) {
      const g = /M851(?:\s+X(?<X>-?\d+(?:\.\d+)?))?(?:\s+Y(?<Y>-?\d+(?:\.\d+)?))?(?:\s+Z(?<Z>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.zProbeOffset = { X: num(g.X), Y: num(g.Y), Z: num(g.Z) };
    }
  }

  // M900 K
  if (cfg.linearAdvance == null) {
    const m = cleanLines.find(l => /^M900\b/i.test(l));
    if (m) {
      const g = /M900(?:\s+K(?<K>-?\d+(?:\.\d+)?))?/i.exec(m)?.groups || {};
      cfg.linearAdvance = num(g.K);
    }
  }

  // M412 S
  if (cfg.runout == null) {
    const m = cleanLines.find(l => /^M412\b/i.test(l));
    if (m) cfg.runout = /S1\b/.test(m);
  }

  // C001 S H B W  (CR-6 helper)
  if (!cfg.probeHeatersOff) {
    const m = cleanLines.find(l => /^C001\b/i.test(l));
    if (m) {
      const g = /C001(?:\s+S(?<S>[01]))?(?:\s+H(?<H>-?\d+(?:\.\d+)?))?(?:\s+B(?<B>-?\d+(?:\.\d+)?))?(?:\s+W(?<W>-?\d+))?/i.exec(m)?.groups || {};
      cfg.probeHeatersOff = { S: g.S === '1', H: num(g.H), B: num(g.B), W: g.W != null ? Number(g.W) : null };
    }
  }
}

// ---------- PARSER FOR M503 ----------
function parseM503Response(raw) {
  const lines = raw.replace(/\r/g, '').split('\n').map(s => s.trim()).filter(Boolean);

  const cfg = {
    filament: {},
    pid: {},
    abl: {},
    presets: []
  };

  const num = s => (s == null ? null : Number(s));
  const grab = (re, line) => (re.exec(line) || {}).groups || null;

  const clean = lines.map(l => l.replace(/^echo:\s*/, '').trim());

  for (const line of clean) {
    if (/^G21\b/.test(line)) cfg.units = 'mm';
    if (/^G20\b/.test(line)) cfg.units = 'in';

    if (/^; Filament settings:\s*(Enabled|Disabled)/i.test(line))
      cfg.filament.enabled = /Enabled/i.test(line);

    if (/^M92\b/.test(line)) {
      const g = grab(/M92\s+X(?<X>\S+)\s+Y(?<Y>\S+)\s+Z(?<Z>\S+)\s+E(?<E>\S+)/, line);
      if (g) cfg.stepsPerUnit = { X: num(g.X), Y: num(g.Y), Z: num(g.Z), E: num(g.E) };
    }

    if (/^M203\b/.test(line)) {
      const g = grab(/M203\s+X(?<X>\S+)\s+Y(?<Y>\S+)\s+Z(?<Z>\S+)\s+E(?<E>\S+)/, line);
      if (g) cfg.maxFeedrate = { X: num(g.X), Y: num(g.Y), Z: num(g.Z), E: num(g.E) };
    }

    if (/^M201\b/.test(line)) {
      const g = grab(/M201\s+X(?<X>\S+)\s+Y(?<Y>\S+)\s+Z(?<Z>\S+)\s+E(?<E>\S+)/, line);
      if (g) cfg.maxAccel = { X: num(g.X), Y: num(g.Y), Z: num(g.Z), E: num(g.E) };
    }

    if (/^M204\b/.test(line)) {
      const g = grab(/M204\s+P(?<P>\S+)\s+R(?<R>\S+)\s+T(?<T>\S+)/, line);
      if (g) cfg.accel = { P: num(g.P), R: num(g.R), T: num(g.T) };
    }

    if (/^M205\b/.test(line)) {
      const g = grab(/M205.*X(?<X>\S+).*Y(?<Y>\S+).*Z(?<Z>\S+).*E(?<E>\S+)/, line);
      if (g) cfg.advanced = { X: num(g.X), Y: num(g.Y), Z: num(g.Z), E: num(g.E) };
    }

    if (/^M420\b/.test(line)) {
      const g = grab(/M420\s+S(?<S>[01])(?:\s+Z(?<Z>\S+))?/, line);
      if (g) { cfg.abl.enabled = g.S === '1'; cfg.abl.fade = num(g.Z); }
    }

    if (/^G29\s+W\b/.test(line)) {
      const g = grab(/I(?<I>\d+)\s+J(?<J>\d+)\s+Z(?<Z>\S+)/, line);
      if (g) {
        const I = Number(g.I), J = Number(g.J), Z = num(g.Z);
        if (!cfg.mesh) cfg.mesh = { nx: 0, ny: 0, values: [] };
        cfg.mesh.nx = Math.max(cfg.mesh.nx, I + 1);
        cfg.mesh.ny = Math.max(cfg.mesh.ny, J + 1);
        cfg.mesh.values[J] = cfg.mesh.values[J] || [];
        cfg.mesh.values[J][I] = Z;
      }
    }
  }
_fillMissingM503Fields(cfg, clean);
  return cfg;
}


function putRows(tbodySel, rows) {
  const tbody = document.querySelector(tbodySel);
  if (!tbody) return;
  tbody.innerHTML = rows
    .map(([k, v]) => `<tr><th style="text-align:left">${k}</th><td style="text-align:left">${v ?? ''}</td></tr>`)
    .join('');
}

function renderM503Fields(cfg) {
  // General
  putRows('#m503General tbody', [
    ['Units', cfg.units || '‚Äî'],
    ['Filament Settings', cfg.filament.enabled == null ? '‚Äî' : (cfg.filament.enabled ? 'Enabled' : 'Disabled')],
    ['Filament (M200)', cfg.filament.M200 ? `S=${cfg.filament.M200.S} D=${cfg.filament.M200.D}` : '‚Äî'],
    ['Home Offset (M206)', cfg.homeOffset ? `X=${cfg.homeOffset.X} Y=${cfg.homeOffset.Y} Z=${cfg.homeOffset.Z}` : '‚Äî'],
    ['Power-loss Recovery (M413)', cfg.powerLossRecovery == null ? '‚Äî' : (cfg.powerLossRecovery ? 'On' : 'Off')],
    ['Runout Sensor (M412)', cfg.runout == null ? '‚Äî' : (cfg.runout ? 'On' : 'Off')],
  ]);

  // Motion
  putRows('#m503Motion tbody', [
    ['Steps/mm (M92)', cfg.stepsPerUnit ? `X=${cfg.stepsPerUnit.X} Y=${cfg.stepsPerUnit.Y} Z=${cfg.stepsPerUnit.Z} E=${cfg.stepsPerUnit.E}` : '‚Äî'],
    ['Max Feedrate (M203)', cfg.maxFeedrate ? `X=${cfg.maxFeedrate.X} Y=${cfg.maxFeedrate.Y} Z=${cfg.maxFeedrate.Z} E=${cfg.maxFeedrate.E}` : '‚Äî'],
    ['Max Accel (M201)', cfg.maxAccel ? `X=${cfg.maxAccel.X} Y=${cfg.maxAccel.Y} Z=${cfg.maxAccel.Z} E=${cfg.maxAccel.E}` : '‚Äî'],
    ['Accel (M204)', cfg.accel ? `P=${cfg.accel.P} R=${cfg.accel.R} T=${cfg.accel.T}` : '‚Äî'],
    ['Advanced (M205)', cfg.advanced ? `B=${cfg.advanced.B} S=${cfg.advanced.S} T=${cfg.advanced.T} X=${cfg.advanced.X} Y=${cfg.advanced.Y} Z=${cfg.advanced.Z} E=${cfg.advanced.E}` : '‚Äî'],
    ['Linear Advance (M900)', cfg.linearAdvance ?? '‚Äî'],
  ]);

  // Temperatures / PID / Presets
  putRows('#m503Temps tbody', [
    ['PID Hotend (M301)', cfg.pid.hotend ? `P=${cfg.pid.hotend.P} I=${cfg.pid.hotend.I} D=${cfg.pid.hotend.D}` : '‚Äî'],
    ['PID Bed (M304)', cfg.pid.bed ? `P=${cfg.pid.bed.P} I=${cfg.pid.bed.I} D=${cfg.pid.bed.D}` : '‚Äî'],
    ['Presets (M145)', cfg.presets.length ? cfg.presets.map(p => `S${p.S}: H${p.H}/B${p.B}/F${p.F}`).join(', ') : '‚Äî'],
    ['Probe Heaters Off (C001)', cfg.probeHeatersOff ? `S=${cfg.probeHeatersOff.S ? 'On' : 'Off'} H=${cfg.probeHeatersOff.H} B=${cfg.probeHeatersOff.B} W=${cfg.probeHeatersOff.W}` : '‚Äî'],
  ]);

  // Retract
  putRows('#m503Retract tbody', [
    ['Retract (M207)', cfg.retract ? `S=${cfg.retract.S} W=${cfg.retract.W} F=${cfg.retract.F} Z=${cfg.retract.Z}` : '‚Äî'],
    ['Recover (M208)', cfg.recover ? `S=${cfg.recover.S} W=${cfg.recover.W} F=${cfg.recover.F}` : '‚Äî'],
    ['Auto-Retract (M209)', cfg.autoRetract == null ? '‚Äî' : (cfg.autoRetract ? 'On' : 'Off')],
    ['Z Probe Offset (M851)', cfg.zProbeOffset ? `X=${cfg.zProbeOffset.X} Y=${cfg.zProbeOffset.Y} Z=${cfg.zProbeOffset.Z}` : '‚Äî'],
  ]);

  // ABL + Mesh
  const ablStr = `Enabled=${cfg.abl.enabled ? 'Yes' : 'No'}${cfg.abl.fade != null ? `, Fade Z=${cfg.abl.fade}` : ''}`;
  putRows('#m503ABL tbody', [['ABL (M420)', ablStr]]);

  renderMesh('#m503Mesh', cfg.mesh);
}

function renderMesh(containerSel, mesh) {
  const container = document.querySelector(containerSel);
  if (!container) return;
  if (!mesh) { container.innerHTML = '<em>No mesh</em>'; return; }

  // Stats
  const vals = mesh.values.flat().filter(v => typeof v === 'number');
  const min = Math.min(...vals), max = Math.max(...vals);
  const avg = vals.reduce((a,b)=>a+b,0) / vals.length;
  const range = max - min;

  // Simple color mapping (green ~ median, blue = low, red = high)
  const tdFor = (z) => {
    let bg = '#eee';
    if (typeof z === 'number') {
      const t = range > 1e-9 ? (z - min) / range : 0.5;
      // interpolate blue(0) -> green(0.5) -> red(1)
      let r,g,b;
      if (t < 0.5) { // blue to green
        const k = t/0.5; r = 0; g = Math.round(255*k); b = Math.round(255*(1-k));
      } else { // green to red
        const k = (t-0.5)/0.5; r = Math.round(255*k); g = Math.round(255*(1-k)); b = 0;
      }
      bg = `rgb(${r},${g},${b})`;
    }
    const text = (z==null) ? '' : z.toFixed(5);
    return `<td style="padding:6px; text-align:center; background:${bg}; color:#000;">${text}</td>`;
  };

  const header = `<div style="margin:6px 0;">
    <strong>Mesh:</strong> ${mesh.nx}√ó${mesh.ny}
    &nbsp;|&nbsp; <strong>Min:</strong> ${min.toFixed(5)}
    &nbsp;|&nbsp; <strong>Max:</strong> ${max.toFixed(5)}
    &nbsp;|&nbsp; <strong>Avg:</strong> ${avg.toFixed(5)}
    &nbsp;|&nbsp; <strong>Range:</strong> ${range.toFixed(5)}
  </div>`;

  const rows = mesh.values.map(row => `<tr>${row.map(tdFor).join('')}</tr>`).join('');
  container.innerHTML = header + `<table style="border-collapse:collapse;"><tbody>${rows}</tbody></table>`;
}

function renderM115Fields(parsed) {
  const { info, caps, area } = parsed;
  const tbody = document.querySelector('#m115Table tbody');
  if (!tbody) return;

  const rows = [];

  // Top-level info (show common keys nicely)
  const mapKeys = [
    ['FIRMWARE_NAME', 'Firmware'],
    ['SOURCE_CODE_URL', 'Source'],
    ['PROTOCOL_VERSION', 'Protocol'],
    ['MACHINE_TYPE', 'Machine'],
    ['EXTRUDER_COUNT', 'Extruders'],
    ['UUID', 'UUID'],
  ];

  for (const [k, label] of mapKeys) {
    if (info[k]) rows.push([label, info[k]]);
  }

  // Caps (only show ones present)
  const capEntries = Object.keys(caps).sort().map(name => [name, caps[name] ? 'Yes' : 'No']);
  if (capEntries.length) {
    rows.push(['‚Äî', '‚Äî']);
    rows.push(['Capabilities', '']);
    for (const [k, v] of capEntries) rows.push(['‚Ä¢ ' + k, v]);
  }

  // Area (pretty print if available)
  if (area) {
    rows.push(['‚Äî', '‚Äî']);
    rows.push(['Area (full)', `min x:${area.full?.min?.x}, y:${area.full?.min?.y}, z:${area.full?.min?.z} | max x:${area.full?.max?.x}, y:${area.full?.max?.y}, z:${area.full?.max?.z}`]);
    rows.push(['Area (work)', `min x:${area.work?.min?.x}, y:${area.work?.min?.y}, z:${area.work?.min?.z} | max x:${area.work?.max?.x}, y:${area.work?.max?.y}, z:${area.work?.max?.z}`]);
  }

  // Render
  tbody.innerHTML = rows.map(([k, v]) => `<tr><th style="text-align:left">${k}</th><td style="text-align:left">${v ?? ''}</td></tr>`).join('');
}


function parseM115(text) {
  const cfg = {};
  String(text || '')
    .split(/\r?\n/)
    .map(s => s.replace(/^echo:\s*/i, '').trim())
    .filter(s => s && !/^ok\b/i.test(s))
    .forEach(line => {
      if (/^FIRMWARE_NAME:/i.test(line))   cfg.name      = line.split(':')[1]?.trim();
      else if (/^FIRMWARE_URL:/i.test(line)) cfg.url     = line.split(':')[1]?.trim();
      else if (/^PROTOCOL_VERSION:/i.test(line)) cfg.protocol = line.split(':')[1]?.trim();
      else if (/^MACHINE_TYPE:/i.test(line)) cfg.machine = line.split(':')[1]?.trim();
      else if (/^EXTRUDER_COUNT:/i.test(line)) cfg.extruders = line.split(':')[1]?.trim();
      else if (/^UUID:/i.test(line))       cfg.uuid      = line.split(':')[1]?.trim();
    });
  return cfg;
}

function parseM115Response(raw) {
  const info = {};
  const caps = {};
  let area = null;

  const lines = raw
    .replace(/\r/g, '')
    .split('\n')
    .map(s => s.trim())
    .filter(Boolean);

  const mainLine = lines.find(l => /FIRMWARE_NAME:/.test(l));
  if (mainLine) {
    const re = /([A-Z_]+):(.*?)(?=\s[A-Z_]+:|$)/g;
    let m;
    while ((m = re.exec(mainLine)) !== null) {
      info[m[1]] = m[2].trim();
    }
  }

  for (const line of lines) {
    const capMatch = /^Cap:([A-Z_]+):([01])$/.exec(line);
    if (capMatch) caps[capMatch[1]] = capMatch[2] === '1';
  }

  const areaLine = lines.find(l => /^area:\{/.test(l));
  if (areaLine) {
    try {
      const jsonish = areaLine
        .replace(/^area:/, '')
        .replace(/([a-zA-Z_]+)\s*:/g, '"$1":');
      area = JSON.parse(jsonish);
    } catch (e) { console.warn('Failed to parse area:', e); }
  }

  return { info, caps, area };
}

function createPreviewWorker() {
  if (previewWorker) return previewWorker;

  const workerSrc = `
  self.onmessage = (e) => {
    const { id, text } = e.data;
    try {
      // Parse lines (lightweight): strip comments, collect G1/G0 with XYZE and layer by Z
      const lines = text.split(/\\r?\\n/);
      let eAbs = true; // M82/M83
      let curZ = 0, lastZ = 0;
      let lastX = 0, lastY = 0, lastE = 0;
      let currentLayer = 0;

      const layers = []; // each: { z: number, segs: [ [x1,y1,x2,y2,extruding(bool)] ] }
      function ensureLayer(z) {
        if (!layers.length || layers[layers.length-1].z !== z) {
          layers.push({ z, segs: [] });
        }
        return layers[layers.length-1];
      }

      for (let raw of lines) {
        let line = raw.replace(/;.*$/, '').trim();
        if (!line) continue;

        if (/^M82\\b/i.test(line)) { eAbs = true;  continue; }
        if (/^M83\\b/i.test(line)) { eAbs = false; continue; }

        // Z changes define layers
        const zTok = line.match(/\\bZ(-?\\d+(?:\\.\\d+)?)/i);
        if (zTok) { curZ = parseFloat(zTok[1]); }

        if (/^G0?1\\b/i.test(line)) {
          const xTok = line.match(/\\bX(-?\\d+(?:\\.\\d+)?)/i);
          const yTok = line.match(/\\bY(-?\\d+(?:\\.\\d+)?)/i);
          const eTok = line.match(/\\bE(-?\\d+(?:\\.\\d+)?)/i);

          const x = xTok ? parseFloat(xTok[1]) : lastX;
          const y = yTok ? parseFloat(yTok[1]) : lastY;

          let eDelta = 0;
          if (eTok) {
            const eVal = parseFloat(eTok[1]);
            eDelta = eAbs ? (eVal - lastE) : eVal;
            if (eAbs) lastE = eVal;
          }

          if (x !== lastX || y !== lastY) {
            // new layer when Z changed (simple heuristic)
            if (curZ !== lastZ) {
              ensureLayer(curZ);
              lastZ = curZ;
            }
            const layer = ensureLayer(curZ);
            layer.segs.push([lastX, lastY, x, y, eDelta > 0 ? 1 : 0]);
            lastX = x; lastY = y;
          }
        }
      }

      // Compact transfer
      self.postMessage({ id, ok: true, layers }, { transfer: [] });
    } catch (err) {
      self.postMessage({ id, ok: false, error: String(err?.message || err) });
    }
  };`;

  const blob = new Blob([workerSrc], { type: 'application/javascript' });
  previewWorkerUrl = URL.createObjectURL(blob);
  previewWorker = new Worker(previewWorkerUrl);
  return previewWorker;
}

function parseM503(text) {
  const out = {};

  // Normalize lines: strip comments like echo:, trim
  const lines = String(text || '')
    .replace(/^echo:\s*/gmi, '')
    .split(/\r?\n/).map(s => s.trim()).filter(Boolean);

  const grab = (re, parseFn = (m)=>m) => {
    for (const ln of lines) {
      const m = ln.match(re);
      if (m) return parseFn(m);
    }
    return null;
  };

  // M92: Steps/mm
  // e.g. "M92 X80.00 Y80.00 Z400.00 E420.00"
  out.M92 = grab(/\bM92\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([EXYZA])\s*([-+]?\d*\.?\d+)/gi, (_, ax, v) => (obj[ax.toUpperCase()] = +v));
    return obj;
  });

  // M203: Max feedrate mm/s
  out.M203 = grab(/\bM203\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([EXYZA])\s*([-+]?\d*\.?\d+)/gi, (_, ax, v) => (obj[ax.toUpperCase()] = +v));
    return obj;
  });

  // M201: Acceleration mm/s¬≤
  out.M201 = grab(/\bM201\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([EXYZA])\s*([-+]?\d*\.?\d+)/gi, (_, ax, v) => (obj[ax.toUpperCase()] = +v));
    return obj;
  });

  // M204: Accel presets (P/R/T)
  // e.g. "M204 P500.00 R1000.00 T500.00" OR Marlin variants A/T
  out.M204 = grab(/\bM204\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([PRTA])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = +v));
    return obj;
  });

  // M205: Jerk/junction settings (X/Y/Z/E, J, S, T etc.)
  out.M205 = grab(/\bM205\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([A-Z])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = +v));
    return obj;
  });

  // M851: Z probe offset
  out.M851 = grab(/\bM851\s+Z\s*([-+]?\d*\.?\d+)/i, m => ({ Z: +m[1] }));

  // M301: Hotend PID "M301 P22.20 I1.08 D114.00"
  out.M301 = grab(/\bM301\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([PID])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = +v));
    return obj;
  });

  // M304: Bed PID
  out.M304 = grab(/\bM304\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([PID])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = +v));
    return obj;
  });

  // M420: Bed leveling state
  // e.g. "M420 S1 Z0.00" (S=on/off, Z=fade)
  out.M420 = grab(/\bM420\s+(.*)/i, m => {
    const obj = {};
    m[1].replace(/([A-Z])\s*([-+]?\d*\.?\d+)/gi, (_, k, v) => (obj[k.toUpperCase()] = isNaN(v) ? v : +v));
    return obj;
  });

  // M404: Filament diameter
  out.M404 = grab(/\bM404\s+(?:DN?\s*)?([-+]?\d*\.?\d+)/i, m => ({ D: +m[1] }));

  return out;
}

function fmtKV(obj, order) {
  if (!obj) return '‚Äî';
  const keys = order && order.length ? order : Object.keys(obj);
  return keys.filter(k => obj[k] != null)
             .map(k => `${k}:${obj[k]}`)
             .join(' ¬∑ ') || '‚Äî';
}

const isVirtual = () => virtualToggle?.checked === true;

function renderM503Fields(cfg) {
  const set = (id, text) => { const el = document.getElementById(id); if (el) el.textContent = text || '‚Äî'; };

  set('f_M92',  fmtKV(cfg.M92,  ['X','Y','Z','E']));
  set('f_M203', fmtKV(cfg.M203, ['X','Y','Z','E']));
  set('f_M201', fmtKV(cfg.M201, ['X','Y','Z','E']));
  set('f_M204', fmtKV(cfg.M204, ['P','R','T','A']));
  set('f_M205', fmtKV(cfg.M205));
  set('f_M851', cfg.M851 && typeof cfg.M851.Z === 'number' ? `Z:${cfg.M851.Z}` : '‚Äî');
  set('f_M301', fmtKV(cfg.M301, ['P','I','D']));
  set('f_M304', fmtKV(cfg.M304, ['P','I','D']));
  set('f_M420', fmtKV(cfg.M420, ['S','Z']));
  set('f_M404', cfg.M404 && cfg.M404.D ? `D:${cfg.M404.D}` : '‚Äî');
}


// Wire buttons

document.getElementById('exportCfgBtn')?.addEventListener('click', () => {
  const cfg = window._lastParsedCfg || {};
  const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: 'application/json' });
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'm503_parsed.json'; a.click();
  URL.revokeObjectURL(url);
});

// Optional: auto-parse on paste/changes to the textarea
configBox?.addEventListener('input', () => {
  // lightweight debounce
  clearTimeout(configBox._deb);
  configBox._deb = setTimeout(() => {
    const cfg = parseM503(configBox.value || '');
    renderM503Fields(cfg);
    window._lastParsedCfg = cfg;
  }, 250);
});


// ===== Maintenance Logbook =====
const LS_MAINT = 'maintLog';
let maint = [];               // [{id, dateISO, note, createdTs}]
let maintEditingId = null;

// DOM refs (Maintenance)
const maintForm     = document.getElementById('maintForm');
const maintDate     = document.getElementById('maintDate');
const maintNote     = document.getElementById('maintNote');
const maintSaveBtn  = document.getElementById('maintSave');
const maintResetBtn = document.getElementById('maintReset');
const maintTable    = document.getElementById('maintTable');
const maintSummary  = document.getElementById('maintSummary');
const maintExport   = document.getElementById('maintExport');
const maintClearAll = document.getElementById('maintClearAll');



function loadMaint() {
  try { maint = JSON.parse(localStorage.getItem(LS_MAINT) || '[]'); }
  catch { maint = []; }
}
function saveMaint() {
  localStorage.setItem(LS_MAINT, JSON.stringify(maint));
}
function genMaintId() {
  return 'M' + Date.now().toString(36) + Math.random().toString(36).slice(2,5).toUpperCase();
}
function clearMaintForm() {
  maintEditingId = null;
  maintDate.value = new Date().toISOString().slice(0,10); // today
  maintNote.value = '';
  maintSaveBtn.textContent = 'Save';
}
function renderMaint() {
  // newest first
  const rows = [...maint].sort((a,b) => (b.dateISO||'').localeCompare(a.dateISO) || b.createdTs - a.createdTs)
    .map(m => {
      const d = m.dateISO || '‚Äî';
      const n = (m.note || '').replace(/</g,'&lt;');
      return `<tr>
        <td>${d}</td>
        <td style="text-align:left">${n}</td>
        <td>
          <button type="button" data-edit="${m.id}">Edit</button>
          <button type="button" data-del="${m.id}">Delete</button>
        </td>
      </tr>`;
    }).join('');
  maintTable.innerHTML = rows || `<tr><td colspan="3" class="muted">No maintenance recorded yet.</td></tr>`;
  maintSummary.textContent = `${maint.length} entr${maint.length===1?'y':'ies'}`;
}

function upsertMaintFromForm() {
  const dateISO = maintDate.value || new Date().toISOString().slice(0,10);
  const note = maintNote.value.trim();
  if (!note) { alert('Please enter a note.'); return; }

  if (maintEditingId) {
    const i = maint.findIndex(m => m.id === maintEditingId);
    if (i !== -1) {
      maint[i].dateISO = dateISO;
      maint[i].note = note;
    }
  } else {
    maint.push({
      id: genMaintId(),
      dateISO,
      note,
      createdTs: Date.now()
    });
  }
  saveMaint();
  clearMaintForm();
  renderMaint();
}

function editMaint(id) {
  const m = maint.find(x => x.id === id);
  if (!m) return;
  maintEditingId = id;
  maintDate.value = m.dateISO || new Date().toISOString().slice(0,10);
  maintNote.value = m.note || '';
  maintSaveBtn.textContent = 'Update';
}

function deleteMaint(id) {
  const i = maint.findIndex(x => x.id === id);
  if (i === -1) return;
  if (!confirm('Delete this entry?')) return;
  maint.splice(i, 1);
  saveMaint();
  renderMaint();
}

// Event wiring
maintForm?.addEventListener('submit', (e) => { e.preventDefault(); upsertMaintFromForm(); });
maintResetBtn?.addEventListener('click', clearMaintForm);

maintTable?.addEventListener('click', (e) => {
  const t = e.target;
  if (t.matches('button[data-edit]')) editMaint(t.getAttribute('data-edit'));
  if (t.matches('button[data-del]'))  deleteMaint(t.getAttribute('data-del'));
});

mjpegStart.addEventListener('click', () => {
  const url = (mjpegUrl.value || '').trim();
  if (!url) { camHint.textContent = 'Enter an MJPEG URL.'; return; }
  stopRtc();
  mjpegImg.style.display = '';
  mjpegImg.crossOrigin = 'anonymous'; // needs CORS from server for canvas/record
  mjpegImg.src = url;
  mjpegImg.onload = () => {
    camHint.textContent = 'MJPEG live.';
    drawToCanvasFrom(mjpegImg);
    updateCamUi();
  };
  mjpegImg.onerror = () => {
    camHint.textContent = 'Failed to load MJPEG stream.';
    stopMjpeg();
  };
  updateCamUi();
});

mjpegStop.addEventListener('click', stopMjpeg);


maintExport?.addEventListener('click', () => {
  const blob = new Blob([JSON.stringify(maint, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'maintenance-log.json'; a.click();
  URL.revokeObjectURL(url);
});

maintClearAll?.addEventListener('click', () => {
  if (!maint.length) return;
  if (!confirm('Clear ALL maintenance entries?')) return;
  maint = [];
  saveMaint();
  renderMaint();
});

// Initialize logbook once on load
(function maintInit(){
  if (!maintForm) return; // in case markup not present
  loadMaint();
  clearMaintForm();
  renderMaint();

  // --- Auto-probe toggle + last mesh age hint ---
  const autoProbeEl = document.getElementById('autoProbeAging');
  const ageHintEl   = document.getElementById('meshAgeHint');
  if (autoProbeEl) {
    const saved = localStorage.getItem('autoProbeAging');
    autoProbeEl.checked = saved === '1';
    autoProbeEl.addEventListener('change', () => {
      localStorage.setItem('autoProbeAging', autoProbeEl.checked ? '1' : '0');
    });
  }
  if (ageHintEl) {
    const ts = parseInt(localStorage.getItem('levelsLastAt')||'0',10);
    if (ts) {
      const days = Math.floor((Date.now() - ts) / (1000*60*60*24));
      ageHintEl.textContent = `Last mesh: ${days} day${days===1?'':'s'} ago`;
    } else {
      ageHintEl.textContent = 'Last mesh: ‚Äî';
    }
  }
})();



//Filament
const DEFAULT_DENSITY = {
  'PLA': 1.24, 'PETG': 1.27, 'ABS': 1.04, 'TPU': 1.21, 'Nylon': 1.15,
  'PC': 1.20, 'PVA': 1.23
};
const LS_SPOOLS = 'spools';
const LS_ACTIVE = 'activeSpoolId';

//Regex
const NOISY_REGEX = /^(?:echo:busy:\s*processing|\/\/action:.*|setnewscreen(?:\s*\([^)]*\))?:?.*|invoking handler for screen.*)/i;
const POS_REGEX   = /X:?\s*([+-]?\d*\.?\d+)\s+Y:?\s*([+-]?\d*\.?\d+)\s+Z:?\s*([+-]?\d*\.?\d+)/i;

//const TEMP_T = /T\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;
//const TEMP_B = /B\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;

const TEMP_T = /\bT\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;
const TEMP_B = /\bB\d?:\s*([-+]?\d*\.?\d+)(?:\s*\/\s*([-+]?\d*\.?\d+))?/i;

const TELEMETRY_REGEX =
  /(?:\bT\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\bB\d?:\s*[-+]?\d*\.?\d+(?:\s*\/\s*[-+]?\d*\.?\d+)?)|(?:\b@:\s*\d+)|(?:\bB@:\s*\d+)/i;

//Ambient-detection tuning
const AMBIENT_WINDOW_SEC   = 300;   // track last 5 minutes
const AMBIENT_MIN_SEC      = 240;   // require at least 4 minutes observed
const AMBIENT_MAX_SPREAD   = 0.8;   // max range (¬∞C) over window (¬±0.4¬∞C)
const AMBIENT_MAX_SLOPE    = 0.01;  // ¬∞C per second (~0.6¬∞C/min) max drift

//Buffers
const _ambientBuf = { hot: [], bed: [] }; // arrays of [tsSec, temp]

//Virtual data
const mockMesh = [
  "Bed Topography Report:",
  "    0      1      2      3",
  "0  +0.025  +0.013  -0.002  -0.020",
  "1  +0.018  +0.005  -0.010  -0.022",
  "2  +0.030  +0.015  +0.003  -0.015",
  "3  +0.035  +0.020  +0.010  -0.012",
  "ok"
];

//Virtual printer state object
const vState = {
  hot: 25, hotTarget: null,
  bed: 25, bedTarget: null,
  x: 0, y: 0, z: 0
};

/* =========================================================
   3) STATE (all let)
========================================================= */






/* =========================================================
   4) TABS BOOTSTRAP (runs once)
========================================================= */
(function initTabs(){
  document.querySelectorAll('#tabButtons button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const target = btn.getAttribute('data-tab');
      sessionStorage.setItem('currentTab', target);
      document.querySelectorAll('.tabContent').forEach(tab => {
        tab.classList.toggle('active', tab.id === target);
      });
    });
  });
  const savedTab = sessionStorage.getItem('currentTab');
  if (savedTab && document.getElementById(savedTab)) {
    document.querySelectorAll('#tabButtons button').forEach(b => b.classList.remove('active'));
    document.querySelector(`#tabButtons button[data-tab="${savedTab}"]`)?.classList.add('active');
    document.querySelectorAll('.tabContent').forEach(tab => {
      tab.classList.toggle('active', tab.id === savedTab);
    });
  }
})();

/* =========================================================
   5) HELPERS (pure UI / formatting / state)
========================================================= */

const pidCommitIfReady = () => {
  if (!pidCap.pending || pidCap.committed) return;
  const { kind, kp, ki, kd } = pidCap;
  if ((kind === 'bed' || kind === 'hotend')
      && Number.isFinite(kp) && Number.isFinite(ki) && Number.isFinite(kd)) {

    // Finish UI + clear active
    pidUiFinish?.(kind, true, { Kp: kp, Ki: ki, Kd: kd });
    setPidActive?.(kind, false);

    // Write NEW -> <div>, PREV -> <p> (and persist prev)
    setPidResult?.(kind, kp, ki, kd);

    // (Optional) derive Ku/Tu now that we have Kp/Ki/Kd:
    const rule =
      (pidCap?.meta?.rule && pidCap.meta.rule.toLowerCase().includes('classic'))      ? 'classic' :
      (pidCap?.meta?.rule && pidCap.meta.rule.toLowerCase().includes('no overshoot')) ? 'no-overshoot' :
      undefined;

    const back = inferKuTuFromPid(kp, ki, kd, rule);
    if (back) {
      const line = `Ku‚âà${back.Ku.toFixed(4)}, Tu‚âà${back.Tu.toFixed(4)} ` +
                   `(Tu from Ki:${back.TuA.toFixed(4)}, from Kd:${back.TuB.toFixed(4)})` +
                   (back.rule ? ` [${back.rule}]` : '');
      // Safely append to the correct debug box
      (typeof pidDebugLine === 'function')
        ? pidDebugLine(kind, line)
        : (() => {
            const pre = document.getElementById(kind === 'bed' ? 'pidBedDbg' : 'pidHotDbg');
            if (pre) { pre.textContent += (pre.textContent ? '\n' : '') + line; }
          })();
    }

    // Close latch
    pidCap.committed = true;
    pidCap.pending = false;
    pidCap.kind = null;
    try { pidTargetTemp = null; } catch {}
  }
};
function clearLevelingData() {
  let cleared = false;

  // individual keys
  if (localStorage.getItem('levels') !== null) {
    localStorage.removeItem('levels');
    cleared = true;
  }
  if (localStorage.getItem('levelsLastAt') !== null) {
    localStorage.removeItem('levelsLastAt');
    cleared = true;
  }

  // JSON blob case
  const candidateKeys = ['settings', 'printerState', 'config'];
  for (const key of candidateKeys) {
    const raw = localStorage.getItem(key);
    if (!raw) continue;
    try {
      const obj = JSON.parse(raw);
      if ('levels' in obj || 'levelsLastAt' in obj) {
        delete obj.levels;
        delete obj.levelsLastAt;
        localStorage.setItem(key, JSON.stringify(obj));
        cleared = true;
      }
    } catch {}
  }

  return cleared;
}

function readSettings() {
  try { return JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}'); }
  catch { return {}; }
}
function writeSettings(obj) {
  try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj)); } catch {}
}

function getPidKeys(which) {
  const w = (which === 'bed') ? 'bed' : 'hotend';
  return {
    curr: `pidCurr:${w}`,   // JSON string: {Kp,Ki,Kd,ts}
    prev: `pidPrev:${w}`,   // JSON string: {Kp,Ki,Kd,ts}
    elCurr: w === 'bed' ? 'pidBedResult' : 'pidHotResult',
    elPrev: w === 'bed' ? 'pidBedPrev'   : 'pidHotPrev'
  };
}
/* ================= G-code Previewer ================= */
(function(){
  const els = {
    file: document.getElementById('gcodeFile'),
    canvas: document.getElementById('gcodeCanvas'),
    scrub: document.getElementById('layerScrub'),
    info: document.getElementById('layerInfo'),
    travel: document.getElementById('showTravel'),
    zoomFit: document.getElementById('zoomFit'),
    zoom1: document.getElementById('zoom1'),
    resetPan: document.getElementById('resetPan'),
    wrap: document.getElementById('gcodePreview')
  };

  (function(){
  let reqId = 0;

window.pidCurr = window.pidCurr || { bed: null, hotend: null };

  // Call from streamGcode instead of the sync load
  window.GCodePreview = window.GCodePreview || {};

  window.GCodePreview.loadFromTextAsync = function(text) {
    return new Promise((resolve, reject) => {
      try {
        if (!('Worker' in window)) {
          // fallback: use your existing sync method
          window.GCodePreview.loadFromText?.(text);
          return resolve();
        }
        const w = createPreviewWorker();
        const id = ++reqId;

        const onmessage = (e) => {
          const { id: got, ok, layers, error } = e.data || {};
          if (got !== id) return;
          w.removeEventListener('message', onmessage);

          if (!ok) { reject(new Error(error || 'Preview worker failed')); return; }

          // Store/replace parsed model on preview object
          window.GCodePreviewModel = { layers, version: Date.now() };

          // Draw in chunks (avoid long blocking)
          chunkedRenderPreview(layers).then(resolve, reject);
        };

        w.addEventListener('message', onmessage);
        w.postMessage({ id, text });
      } catch (err) {
        reject(err);
      }
    });
  };

  async function chunkedRenderPreview(layers) {
    const canvas = document.getElementById('gcodeCanvas');
    const ctx = canvas?.getContext?.('2d');
    if (!ctx) return;

    // Clear + prepare
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // you may want to recompute bounds & scale here; stubbed as 1:1 for brevity
    const toPx = (v) => v; // replace with your scaling

    let layerIndex = 0;
    const LAYERS_PER_FRAME = 4; // tune to your liking
    return new Promise((resolve) => {
      function step() {
        let count = 0;
        while (layerIndex < layers.length && count < LAYERS_PER_FRAME) {
          const layer = layers[layerIndex++];
          for (const seg of layer.segs) {
            const [x1, y1, x2, y2, extr] = seg;
            ctx.beginPath();
            ctx.moveTo(toPx(x1), toPx(y1));
            ctx.lineTo(toPx(x2), toPx(y2));
            ctx.globalAlpha = extr ? 1.0 : 0.25;
            ctx.lineWidth = extr ? 1.5 : 1.0;
            ctx.stroke();
          }
          count++;
        }
        if (layerIndex < layers.length) {
          requestAnimationFrame(step);
        } else {
          // finished
          ctx.globalAlpha = 1.0;
          resolve();
        }
      }
      requestAnimationFrame(step);
    });
  }
})();

  const ctx = els.canvas.getContext('2d', { alpha: false });

  // ----- Model -----
  let layers = [];            // [{z, lines:[{x1,y1,x2,y2, extruding, lineNo}]}]
  let zList = [];             // sorted z values
  let bbox = {minX:0, minY:0, maxX:1, maxY:1};
  let scale = 1, offsetX = 0, offsetY = 0; // world->screen
  let pan = {x:0, y:0}, zoom = 1;

  // ----- Utilities -----
  const EPS_Z = 0.0009;
  function nearlyEqual(a,b,eps){ return Math.abs(a-b) <= eps; }
  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

  // Color tokens from CSS
  function token(name, fallback){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback;
  }

let previewBusy = typeof window.previewBusy !== 'undefined' ? window.previewBusy : null;

// Async preview builder with busy indicator
async function buildPreviewAsync(text) {
  // Ensure we have the element
  if (!previewBusy) previewBusy = document.getElementById('previewBusy');

  try {
    if (previewBusy) previewBusy.style.display = '';   // show
    if (window.GCodePreview?.loadFromTextAsync) {
      await window.GCodePreview.loadFromTextAsync(text);
    } else {
      window.GCodePreview?.loadFromText?.(text);
    }
  } finally {
    if (previewBusy) previewBusy.style.display = 'none'; // hide
  }
}

  // ----- Parser -----
  function parseGCode(text){
    layers = []; zList = [];
    bbox = {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity};

    let x=0, y=0, z=0, e=0, f=0;
    let absPos = true;   // G90/G91
    let absE = true;     // M82/M83
    let lastE = 0;

    let currentLayer = null;
    let layerByIndex = {}; // capture ;LAYER: comments

    const lines = text.split(/\r?\n/);
    for (let i=0; i<lines.length; i++){
      let raw = lines[i];
      // strip comments (; ... or ( ... ) ) basic
      let line = raw.replace(/\(.*?\)/g,'').split(';')[0].trim();
      if (!line) {
        // Capture Cura-like layer markers for better accuracy
        const layerMatch = raw.match(/;\s*LAYER\s*:\s*(\d+)/i) || raw.match(/;\s*layer\s*(\d+)/i);
        if (layerMatch) layerByIndex[Number(layerMatch[1])] = z;
        continue;
      }

      const cmd = line.split(/\s+/)[0].toUpperCase();

      if (cmd === 'G90') { absPos = true; continue; }
      if (cmd === 'G91') { absPos = false; continue; }
      if (cmd === 'M82') { absE = true;  continue; }
      if (cmd === 'M83') { absE = false; continue; }

      if (cmd === 'G92') {
        // Set position: parse axes present
        const p = parseParams(line);
        if (p.X!=null) x = p.X;
        if (p.Y!=null) y = p.Y;
        if (p.Z!=null) z = p.Z;
        if (p.E!=null) { e = p.E; lastE = e; }
        continue;
      }

      if (cmd === 'G0' || cmd === 'G1') {
        const p = parseParams(line);
        let nx = (p.X!=null) ? (absPos ? p.X : x + p.X) : x;
        let ny = (p.Y!=null) ? (absPos ? p.Y : y + p.Y) : y;
        let nz = (p.Z!=null) ? (absPos ? p.Z : z + p.Z) : z;
        let ne = (p.E!=null) ? (absE ? p.E : e + p.E) : e;
        if (p.F!=null) f = p.F;

        // new layer if Z changed noticeably
        if (!currentLayer || !nearlyEqual(nz, currentLayer.z, EPS_Z)) {
          currentLayer = getOrCreateLayer(nz);
        }

        const extruding = (ne > lastE + 1e-9);
        if ((nx!==x || ny!==y || nz!==z) && (extruding || p.X!=null || p.Y!=null)) {
          // store only XY segments (2D top view). Ignore pure Z hops.
          if (!nearlyEqual(nz, currentLayer.z, EPS_Z)) {
            currentLayer = getOrCreateLayer(nz);
          }
          if (nx!==x || ny!==y) {
            currentLayer.lines.push({ x1:x, y1:y, x2:nx, y2:ny, extruding, lineNo: i+1 });
            // expand bbox
            bbox.minX = Math.min(bbox.minX, x, nx);
            bbox.minY = Math.min(bbox.minY, y, ny);
            bbox.maxX = Math.max(bbox.maxX, x, nx);
            bbox.maxY = Math.max(bbox.maxY, y, ny);
          }
        }
        x = nx; y = ny; z = nz; lastE = e = ne;
        continue;
      }

      // ignore other codes for 2D preview
    }

    // sort layers by z
    layers.sort((a,b)=>a.z-b.z);
    zList = layers.map(l=>l.z);

    // If any ;LAYER markers existed, we could remap (optional, kept simple here)

    // guard bbox
    if (!isFinite(bbox.minX)) bbox = {minX:0, minY:0, maxX:1, maxY:1};
    return { layers, bbox };
  }

  function parseParams(line){
    const p = {};
    line.replace(/[A-Za-z][-+]?\d*\.?\d+(e[-+]?\d+)?/gi, tok=>{
      const letter = tok[0].toUpperCase();
      const num = parseFloat(tok.slice(1));
      p[letter] = num;
    });
    return p;
  }

  function getOrCreateLayer(z){
    // merge z into existing within EPS_Z
    for (const L of layers) if (nearlyEqual(L.z, z, EPS_Z)) return L;
    const L = { z, lines: [] };
    layers.push(L);
    return L;
  }

  // ----- View / Transform -----
  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = els.canvas.getBoundingClientRect();
    els.canvas.width = Math.floor(r.width * dpr);
    els.canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    fitView();
  }

  function fitView(){
    const pad = 10;
    const w = els.canvas.clientWidth - pad*2;
    const h = els.canvas.clientHeight - pad*2;
    const bw = Math.max(1e-6, bbox.maxX - bbox.minX);
    const bh = Math.max(1e-6, bbox.maxY - bbox.minY);
    const sx = w / bw;
    const sy = h / bh;
    scale = Math.min(sx, sy);
    offsetX = -bbox.minX + (w/scale - bw)/2;
    offsetY = -bbox.minY + (h/scale - bh)/2;
    zoom = 1; pan = {x:0, y:0};
    render();
  }

  function worldToScreen(x,y){
    // Flip Y so +Y is up visually (optional). Here we keep slicer coords (origin lower-left).
    const sx = (x + offsetX + pan.x) * scale * zoom + 10;
    const sy = (y + offsetY + pan.y) * scale * zoom + 10;
    return [sx, els.canvas.clientHeight - sy]; // invert for canvas pixels
  }

  // ----- Render -----
  let currentLayerIdx = 0;
  function render(){
    const bg = token('--panel','#fff');
    const grid = token('--border','#ccd');
    const text = token('--text','#111');
    const prevCol = `rgba(128,128,128,0.35)`;
    const currCol = token('--accent','#4f46e5');
    const travelCol = `rgba(120,120,120,0.55)`;

    ctx.clearRect(0,0,els.canvas.clientWidth,els.canvas.clientHeight);

    // Very light grid
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = grid;
    ctx.lineWidth = 1;
    // simple frame
    ctx.strokeRect(0.5,0.5,els.canvas.clientWidth-1,els.canvas.clientHeight-1);
    ctx.restore();

    if (!layers.length) return;

    // Draw previous layers faint
    for (let i=0; i<currentLayerIdx; i++){
      drawLayer(layers[i], prevCol, travelCol, els.travel.checked, 1);
    }
    // Draw current layer full
    drawLayer(layers[currentLayerIdx], currCol, travelCol, els.travel.checked, 2);
    // HUD text
    ctx.fillStyle = text;
    ctx.font = '12px system-ui, sans-serif';
    const z = layers[currentLayerIdx]?.z ?? 0;
    ctx.fillText(`Layer ${currentLayerIdx+1}/${layers.length}  ‚Ä¢  Z=${z.toFixed(3)} mm`, 12, 18);
  }

  function drawLayer(L, extrudeColor, travelColor, showTravel, widthBase){
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    for (const seg of L.lines){
      const [x1,y1] = worldToScreen(seg.x1, seg.y1);
      const [x2,y2] = worldToScreen(seg.x2, seg.y2);
      const isTravel = !seg.extruding;
      if (isTravel && !showTravel) continue;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      if (isTravel){
        ctx.strokeStyle = travelColor;
        ctx.setLineDash([6,6]);
        ctx.lineWidth = widthBase;
      } else {
        ctx.strokeStyle = extrudeColor;
        ctx.setLineDash([]);
        ctx.lineWidth = widthBase + 0.5;
      }
      ctx.stroke();
    }
  }

  // ----- Scrubber / Controls -----
  function syncScrubber(){
    els.scrub.max = Math.max(0, layers.length-1);
    currentLayerIdx = clamp(currentLayerIdx, 0, layers.length-1);
    els.scrub.value = currentLayerIdx;
    const z = layers[currentLayerIdx]?.z ?? 0;
    els.info.textContent = layers.length
      ? `#${currentLayerIdx+1}/${layers.length} (Z=${z.toFixed(3)}mm)`
      : '‚Äî';
  }

  els.scrub.addEventListener('input', () => {
    currentLayerIdx = Number(els.scrub.value|0);
    syncScrubber(); render();
  });

  els.travel.addEventListener('change', render);
  els.zoomFit.addEventListener('click', fitView);
  els.zoom1.addEventListener('click', ()=>{ zoom = 1; render(); });
  els.resetPan.addEventListener('click', ()=>{ pan = {x:0,y:0}; render(); });

  // Pan & Zoom (mouse)
  let panning = false, last = {x:0,y:0};
  els.canvas.addEventListener('pointerdown', e=>{
    panning = true; last = {x:e.clientX, y:e.clientY}; els.canvas.setPointerCapture(e.pointerId);
  });
  els.canvas.addEventListener('pointermove', e=>{
    if (!panning) return;
    const dx = (e.clientX - last.x) / (scale * zoom);
    const dy = (e.clientY - last.y) / (scale * zoom);
    pan.x += dx;
    pan.y -= dy; // invert due to screen Y invert
    last = {x:e.clientX, y:e.clientY};
    render();
  });
  window.addEventListener('pointerup', ()=>{ panning = false; });
  els.canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const factor = Math.exp((e.deltaY>0?-1:1)*0.08);
    zoom = clamp(zoom*factor, 0.1, 20);
    render();
  }, { passive:false });

  // ----- Loading -----
  els.file.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0];
    if (!file) return;
    const text = await file.text();
    loadFromText(text);
  });

  function loadFromText(text){
    parseGCode(text);
    resizeCanvas(); // sets fitView via render
    currentLayerIdx = 0;
    syncScrubber(); render();
  }

  // Resize handling
  const ro = new ResizeObserver(()=>resizeCanvas());
  ro.observe(els.canvas);

  // ----- Live highlight API -----
  function updateCurrentZ(z){
    if (!layers.length) return;
    // find nearest layer by Z
    let idx = 0, best = Infinity;
    for (let i=0;i<layers.length;i++){
      const d = Math.abs(layers[i].z - z);
      if (d < best) { best = d; idx = i; }
    }
    if (idx !== currentLayerIdx){
      currentLayerIdx = idx;
      syncScrubber(); render();
    }
  }

  function updateByGcodeLine(lineNo){
    if (!layers.length) return;
    // find the highest layer that has any segment with lineNo <= given
    let idx = currentLayerIdx;
    for (let i=0;i<layers.length;i++){
      const has = layers[i].lines.some(s => s.lineNo <= lineNo && s.extruding);
      if (has) idx = i;
    }
    if (idx !== currentLayerIdx){
      currentLayerIdx = idx;
      syncScrubber(); render();
    }
  }

  // Expose a small API for your sender
  window.GCodePreview = {
    loadFromText,
    updateCurrentZ,
    updateByGcodeLine,
    fitView,
    setLayer: (i)=>{ currentLayerIdx = clamp(i,0,layers.length-1); syncScrubber(); render(); },
    get meta(){ return { layers: layers.length, zList:[...layers.map(l=>l.z)], bbox }; }
  };

  // If you already have the file string available elsewhere, you can do:
  // GCodePreview.loadFromText(gcodeString);

})();

function genSpoolId() {
  const t = Date.now().toString(36).slice(-5);
  const r = Math.floor(Math.random() * 0xffff).toString(36).padStart(3, '0');
  return `S-${t}${r}`.toUpperCase();
}

function saveSpools(nextSpools) {
  if (Array.isArray(nextSpools)) spools = nextSpools;
  localStorage.setItem(LS_SPOOLS, JSON.stringify(spools || []));
  return spools;
}


function loadSpools() {
  try {
    spools = JSON.parse(localStorage.getItem(LS_SPOOLS) || '[]');
    if (!Array.isArray(spools)) spools = [];
  } catch {
    spools = [];
  }
  return spools;
}

function getActiveSpool() {
  if (!Array.isArray(spools) || !spools.length) loadSpools();
  const id = getActiveSpoolId();
  return spools.find(s => s.id === id) || null;
}

// Ensure an active spool is selected (pick first if missing)
function ensureActiveSpool() {
  if (!Array.isArray(spools) || !spools.length) loadSpools();
  let id = getActiveSpoolId();
  if (!id && spools.length) {
    id = spools[0].id;
    saveActive(id);
  }
  return getActiveSpool();
}

function setPidResult(which, kp, ki, kd) {
  which = (which === 'bed') ? 'bed' : 'hotend';
  const currEl = document.getElementById(which === 'bed' ? 'pidBedResult' : 'pidHotResult');
  const prevEl = document.getElementById(which === 'bed' ? 'pidBedPrev'   : 'pidHotPrev');

  // ensure in-memory holder exists
  window.pidCurr = window.pidCurr || { bed: null, hotend: null };

  // tiny local helpers
  const fmt2   = n => Number.isFinite(n) ? (+n).toFixed(2) : '‚Äî';
  const delta2 = (a,b) => (Number.isFinite(a)&&Number.isFinite(b))
    ? ((a-b)===0 ? '¬±0.00' : ((a-b)>0?'+':'')+(a-b).toFixed(2))
    : '‚Äî';

  // snapshot the old in-memory current BEFORE we overwrite it
  const oldCurrent = (window.pidCurr[which] && Number.isFinite(window.pidCurr[which].Kp))
    ? { ...window.pidCurr[which] } : null;

  // 1) NEW values -> Result <div>
  const now = { Kp:+kp, Ki:+ki, Kd:+kd, ts: Date.now() };
  if (currEl) {
    currEl.textContent = `Kp: ${fmt2(now.Kp)} ¬∑ Ki: ${fmt2(now.Ki)} ¬∑ Kd: ${fmt2(now.Kd)}`;
  }

  // 2) Prev <p>: prefer persisted prev; else fall back to old in-memory current
  let prev = null;
  try {
    const raw = localStorage.getItem('pidPrev:' + which);
    if (raw) prev = JSON.parse(raw);
  } catch {}
  if (!prev) prev = oldCurrent;

  if (prevEl) {
    if (prev && Number.isFinite(prev.Kp)) {
      prevEl.textContent =
        `Prev ‚Äî Kp: ${fmt2(prev.Kp)} ¬∑ Ki: ${fmt2(prev.Ki)} ¬∑ Kd: ${fmt2(prev.Kd)} ` +
        `(Œî Kp:${delta2(now.Kp, prev.Kp)}, Ki:${delta2(now.Ki, prev.Ki)}, Kd:${delta2(now.Kd, prev.Kd)})`;
    } else {
      prevEl.textContent = 'Prev ‚Äî Kp: ‚Äî ¬∑ Ki: ‚Äî ¬∑ Kd: ‚Äî (Œî ‚Äî)';
    }
  }

  // 3) update in-memory current
  window.pidCurr[which] = now;

  // 4) PERSIST: make *this run* the next "previous" so it loads after refresh
  if (Number.isFinite(now.Kp) && Number.isFinite(now.Ki) && Number.isFinite(now.Kd)) {
    try { localStorage.setItem('pidPrev:' + which, JSON.stringify(now)); } catch {}
  }
}


function restorePrevPidFromStorage() {
  ['bed','hotend'].forEach(which => {
    const prevEl = document.getElementById(which === 'bed' ? 'pidBedPrev' : 'pidHotPrev');
    if (!prevEl) return;
    try {
      const raw = localStorage.getItem('pidPrev:' + which);
      const prev = raw ? JSON.parse(raw) : null;
      if (prev && Number.isFinite(prev.Kp)) {
        prevEl.textContent =
          `Prev ‚Äî Kp: ${prev.Kp.toFixed(2)} ¬∑ Ki: ${prev.Ki.toFixed(2)} ¬∑ Kd: ${prev.Kd.toFixed(2)}`;
      } else {
        prevEl.textContent = 'Prev ‚Äî Kp: ‚Äî ¬∑ Ki: ‚Äî ¬∑ Kd: ‚Äî (Œî ‚Äî)';
      }
    } catch {
      prevEl.textContent = 'Prev ‚Äî Kp: ‚Äî ¬∑ Ki: ‚Äî ¬∑ Kd: ‚Äî (Œî ‚Äî)';
    }
  });
}

function updateActiveSpool(mutator) {
  if (typeof mutator !== 'function') return null;
  if (!Array.isArray(spools) || !spools.length) loadSpools();
  const id = getActiveSpoolId();
  const idx = spools.findIndex(s => s.id === id);
  if (idx === -1) return null;
  const updated = { ...spools[idx] };
  const next = mutator(updated) || updated;
  spools[idx] = next;
  saveSpools(spools);
  // optional UI hook if you have one:
  renderSpoolUi?.(next);
  return next;
}

function getActiveSpoolId() {
  // prefer in-memory; fall back to LS
  if (activeSpoolId) return activeSpoolId;
  const fromLS = localStorage.getItem(LS_ACTIVE) || '';
  activeSpoolId = fromLS || null;
  return activeSpoolId;
}



function saveActive(id) {
  activeSpoolId = id || null;
  localStorage.setItem(LS_ACTIVE, activeSpoolId || '');
  return activeSpoolId;
}

function materialDensityGuess(mat) {
  const k = String(mat || '').trim().toUpperCase();
  // Common aliases
  if (k === 'PA' || k.startsWith('PA')) return DEFAULT_DENSITY.NYLON; // PA/PA12/PA6
  return DEFAULT_DENSITY[k] ?? null;
}


function findSpool(id) {
  return spools.find(s => s.id === id) || null;
}

function formatG(x) {
  return Number.isFinite(x) ? Math.round(x) : '‚Äî';
}

function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function fillDensityByMaterial() {
  if (!window.spMaterial || !window.spDensity) return;
  const d = materialDensityGuess(spMaterial.value);
  if (d != null) {
    spDensity.value = d.toFixed(2);
    spDensity.dataset.auto = '1';
  } else {
    spDensity.value = '';
    delete spDensity.dataset.auto;
  }
}

// On init (where you wire your form):
spMaterial.addEventListener('change', fillDensityByMaterial);

// After you populate the form (writeForm/clearForm), call this so the field matches:
fillDensityByMaterial();

function qrUrlForSpool(s) {
  const payload = encodeURIComponent(JSON.stringify({
    id: s.id,
    brand: s.brand,
    mat: s.material,
    dia: s.diameter,
    dens: s.density,
    color: s.colorHex,
    cap: s.capacityG,
    rem: s.remainingG
  }));
  return `https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=${payload}`;
}

function openPrintLabel(s) {
  const w = window.open('', '_blank', 'width=360,height=520');
  if (!w) return;

  const html = `
    <html><head><title>Spool ${s.id}</title></head>
    <body style="font-family:sans-serif;padding:12px">
      <h3 style="margin:0 0 8px">Spool Label</h3>
      <div><strong>ID:</strong> ${s.id}</div>
      <div><strong>Brand:</strong> ${s.brand || '‚Äî'}</div>
      <div><strong>Material:</strong> ${s.material} ‚Äî √ò ${s.diameter} mm</div>
      <div><strong>Color:</strong> ${s.colorName || ''} 
        <span style="display:inline-block;width:12px;height:12px;background:${s.colorHex};
          border:1px solid #999;vertical-align:middle"></span>
      </div>
      <div><strong>Remaining:</strong> ${formatG(s.remainingG)} g / ${formatG(s.capacityG)} g</div>
      <img src="${qrUrlForSpool(s)}" alt="QR" style="margin-top:10px"/>
      <script>setTimeout(()=>window.print(), 200);<\/script>

    </body></html>`;

  w.document.write(html);
  w.document.close();
}

function reserveFilamentForJob(mmNeeded) {
  const spool = getActiveSpool();
  if (!spool) {
    setActivity?.('No active spool selected', 'bad');
    return null;
  }
  const before = spool.remainingMm ?? 0;
  if (before <= 0) {
    setActivity?.('Active spool is empty', 'bad');
    return null;
  }
  if (mmNeeded > before) {
    // still allow reservation, but warn
    setActivity?.('Warning: estimated usage exceeds remaining on active spool', 'warn');
  }
  const ticket = {
    id: 'job-' + Date.now(),
    spoolId: spool.id,
    reservedMm: Math.max(0, mmNeeded)
  };
  // deduct
  updateActiveSpool(s => ({ ...s, remainingMm: Math.max(0, (s.remainingMm ?? 0) - ticket.reservedMm) }));
  sessionStorage.setItem('filamentJobTicket', JSON.stringify(ticket));
  return ticket;
}

function refundFilamentReservation(ticket) {
  try {
    if (!ticket) {
      const t = sessionStorage.getItem('filamentJobTicket');
      if (!t) return;
      ticket = JSON.parse(t);
    }
    if (!ticket || !ticket.spoolId) return;
    const spools = loadSpools();
    const idx = spools.findIndex(s => s.id === ticket.spoolId);
    if (idx === -1) return;
    spools[idx] = { ...spools[idx], remainingMm: (spools[idx].remainingMm ?? 0) + (ticket.reservedMm ?? 0) };
    saveSpools(spools);
  } finally {
    sessionStorage.removeItem('filamentJobTicket');
    renderSpoolUi?.(getActiveSpool());
  }
}

function estimateFilamentUsage(gcodeText) {
  let units = 'mm';     // 'mm' or 'in'
  let eAbs  = true;     // true=M82 absolute E, false=M83 relative
  let posAbs = true;    // G90/G91 (we only need this if you later compute times/paths)

  let eLast = 0;
  let lengthMm = 0;
  const notes = [];

  const lines = gcodeText.split(/\r?\n/);
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    // strip comments
    line = line.replace(/;.*$/, '').trim();
    if (!line) continue;

    // mode switches
    if (/^G20\b/i.test(line)) { units = 'in'; continue; }
    if (/^G21\b/i.test(line)) { units = 'mm'; continue; }
    if (/^G90\b/i.test(line)) { posAbs = true;  continue; }
    if (/^G91\b/i.test(line)) { posAbs = false; continue; }
    if (/^M82\b/i.test(line)) { eAbs = true;    continue; }
    if (/^M83\b/i.test(line)) { eAbs = false;   continue; }

    // E axis resets
    const g92 = line.match(/^G92\b/i);
    if (g92) {
      const eTok = line.match(/\bE(-?\d+(?:\.\d+)?)/i);
      if (eTok) eLast = parseFloat(eTok[1]) || 0;
      continue;
    }

    // Only consider motion lines with E
    if (/^G0?1\b/i.test(line)) {
      const eTok = line.match(/\bE(-?\d+(?:\.\d+)?)/i);
      if (!eTok) continue;
      let eVal = parseFloat(eTok[1]);
      if (!Number.isFinite(eVal)) continue;

      // convert inches to mm for E if needed (rare, but valid)
      let eDelta;
      if (eAbs) {
        eDelta = eVal - eLast;
        eLast = eVal;
      } else {
        eDelta = eVal;
      }

      // Only count positive extrusion
      if (eDelta > 0) {
        if (units === 'in') eDelta *= 25.4;
        lengthMm += eDelta;
      }
    }
  }

  return { lengthMm, mode: { units, eMode: eAbs ? 'absolute' : 'relative' }, notes };
}

function loadActive() {
  try {
    const v = localStorage.getItem(LS_ACTIVE);
    activeSpoolId = v && v !== '' ? v : null;
    if (activeSpoolId && !findSpool(activeSpoolId)) {
      activeSpoolId = null;
      localStorage.setItem(LS_ACTIVE, ''); // clear ghost
    }
  } catch {
    activeSpoolId = null;
  }
}
function estimateGramsFromGcodeText(text, diameterMM, densityGperCM3) {
  const dia  = Math.max(0.5, parseFloat(diameterMM) || 1.75);
  const dens = Math.max(0.1, parseFloat(densityGperCM3) || 1.20);
  const A    = Math.PI * Math.pow(dia / 2, 2); // mm^2

  let absoluteE = true; // default: M82 unless G-code says otherwise
  let lastE = 0;
  let usedMM = 0;

  const lines = text.split(/\r?\n/);
  for (let raw of lines) {
    let line = raw.replace(/;.*$/, '').trim();
    if (!line) continue;

    if (/^M82\b/i.test(line)) { absoluteE = true;  continue; }
    if (/^M83\b/i.test(line)) { absoluteE = false; continue; }

    const g92 = line.match(/^G92\s+.*?E\s*([-+]?\d*\.?\d+)/i);
    if (g92) { lastE = parseFloat(g92[1]) || 0; continue; }

    if (/^G0?1\b/i.test(line)) {
      const m = line.match(/\bE\s*([-+]?\d*\.?\d+)/i);
      if (!m) continue;
      const eNow = parseFloat(m[1]);
      if (!Number.isFinite(eNow)) continue;

      let dE;
      if (absoluteE) {
        dE = eNow - lastE;
        lastE = eNow;
      } else {
        dE = eNow;
      }
      if (dE > 0) usedMM += dE; // ignore retractions
    }
  }
  const volMM3 = usedMM * A;      // mm^3
  const volCM3 = volMM3 / 1000.0; // cm^3
  return volCM3 * dens;           // grams
}

function clearForm(newId = true) {
  editingId = null;
  spIdShow.textContent = newId ? genSpoolId() : '‚Äî';
  spBrand.value = '';
  spMaterial.value = '';
  spDiameter.value = '1.75';
  spDensity.value = '1.24';
  spColorName.value = '';
  spColorHex.value = '#000000';
  spFinish.value = '';
  spTare.value = '250';
  spCapacity.value = '1000';
  spCostTotal.value = '';
  spCostPerKg.value = '';
  spLot.value = '';
  spDate.value = ''; // or set to today if you prefer: new Date().toISOString().slice(0,10)
  spVendor.value = '';

  // keep dependent fields fresh
  fillDensityByMaterial?.();
  autofillLot(true);      // <= generate a fresh lot every new spool
}

function fillForm(s) {
  editingId = s.id;
  spIdShow.textContent = s.id;
  spBrand.value     = s.brand || '';
  spMaterial.value  = s.material || '';
  spDiameter.value  = String(s.diameter || '1.75');
  spDensity.value   = String(s.density ?? 1.24);
  spColorName.value = s.colorName || '';
  spColorHex.value  = s.colorHex || '#000000';
  spFinish.value    = s.finish || '';
  spTare.value      = String(s.tareG ?? 0);
  spCapacity.value  = String(s.capacityG ?? 0);
  spCostTotal.value = s.costTotal ?? '';
  spCostPerKg.value = s.costPerKg ?? '';
  spLot.value       = s.lot || '';
  spDate.value      = s.purchaseDate || '';
  spVendor.value    = s.vendorUrl || '';

  // respect saved density/lot; otherwise auto-fill
  if (!s.density) fillDensityByMaterial?.();
  if (!s.lot) { autofillLot(true); } else { delete spLot.dataset.auto; }
}

function upsertFromForm(e) {
  if (e) e.preventDefault();
  const id = editingId || spIdShow.textContent || genSpoolId();

  const diameter = parseFloat(spDiameter.value);
  const density  = parseFloat(spDensity.value);
  const tare     = Math.max(0, parseFloat(spTare.value) || 0);
  const capacity = Math.max(0, parseFloat(spCapacity.value) || 0);

  if (!(diameter > 0)) return alert('Diameter must be > 0.');
  if (!(density  > 0)) return alert('Density must be > 0.');
  if (!(capacity >= 0)) return alert('Capacity must be ‚â• 0.');

  // cost sanity
  let costTotal = spCostTotal.value ? parseFloat(spCostTotal.value) : null;
  let costPerKg = spCostPerKg.value ? parseFloat(spCostPerKg.value) : null;
  if (costTotal == null && costPerKg != null && capacity > 0) {
    costTotal = costPerKg * (capacity / 1000);
  } else if (costPerKg == null && costTotal != null && capacity > 0) {
    costPerKg = costTotal / (capacity / 1000);
  }

  const existing = findSpool(id);
  const base = {
    id,
    brand: spBrand.value.trim(),
    material: spMaterial.value.trim() || 'PLA',
    diameter,
    density,
    colorName: spColorName.value.trim(),
    colorHex: spColorHex.value || '#000000',
    finish: spFinish.value.trim(),
    tareG: tare,
    capacityG: capacity,
    costTotal:  (costTotal  != null) ? +costTotal.toFixed(2)  : null,
    costPerKg:  (costPerKg  != null) ? +costPerKg.toFixed(2)  : null,
    lot: spLot.value.trim(),
    purchaseDate: spDate.value || '',
    vendorUrl: spVendor.value.trim()
  };

  if (existing) {
    Object.assign(existing, base);
    existing.remainingG = clamp(existing.remainingG ?? capacity, 0, capacity);
    existing.updatedAt  = Date.now();
  } else {
    spools.push({
      ...base,
      remainingG: capacity,
      createdAt:  Date.now(),
      updatedAt:  Date.now(),
      lastUsedAt: null
    });
  }
  saveSpools();
  renderSpoolList();
  renderActiveSel();
  clearForm(true);
  setActivity('Spool saved', 'ok');
}

function clearGhostActive() {
  try {
    const v = localStorage.getItem(LS_ACTIVE); // 'activeSpoolId'
    const isGhost = v && !spools.some(s => s.id === v);
    if (isGhost) {
      localStorage.setItem(LS_ACTIVE, '');  // clear saved ghost
      activeSpoolId = null;                 // clear in memory
    }
  } catch {
    activeSpoolId = null;
  }
}

function renderActiveSel() {
  if (activeSpoolId && !findSpool(activeSpoolId)) {
    saveActive(''); // clear ghost before building
  }
  const idKeep = activeSpoolId;
  spActiveSel.innerHTML =
    '<option value="">‚Äî none ‚Äî</option>' +
    spools.map(s => `<option value="${s.id}" ${s.id === idKeep ? 'selected' : ''}>
        ${s.id} ¬∑ ${s.brand || ''} ${s.material} ${s.colorName || ''}
      </option>`).join('');
}

function renderSpoolList() {
  const q      = spSearch.value.trim().toLowerCase();
  const mat    = spMatFilter.value.trim();
  const onlyRem= spOnlyRemaining.checked;

  let rows = spools.slice();
  if (q) {
    rows = rows.filter(s => (s.id + s.brand + s.colorName).toLowerCase().includes(q));
  }
  if (mat) rows = rows.filter(s => s.material === mat);
  if (onlyRem) rows = rows.filter(s => (s.remainingG || 0) > 0);

  const sort = spSort.value;
  rows.sort((a, b) => {
    if (sort === 'remainingDesc') return (b.remainingG || 0) - (a.remainingG || 0);
    if (sort === 'brandAsc')     return (a.brand || '').localeCompare(b.brand || '');
    if (sort === 'materialAsc')  return (a.material || '').localeCompare(b.material || '');
    if (sort === 'createdDesc')  return (b.createdAt || 0) - (a.createdAt || 0);
    return 0;
  });

  spTable.innerHTML = rows.map(s => `
    <tr>
      <td>${s.id}</td>
      <td>${s.brand || '‚Äî'}</td>
      <td>${s.material}</td>
      <td>
        <span style="display:inline-block;width:10px;height:10px;background:${s.colorHex};border:1px solid #999;vertical-align:middle"></span>
        ${s.colorName || ''}
      </td>
      <td>${s.diameter}</td>
      <td>${formatG(s.remainingG)}</td>
      <td>${formatG(s.capacityG)}</td>
      <td>
        <button data-act="edit" data-id="${s.id}">Edit</button>
        <button data-act="setActive" data-id="${s.id}">Set active</button>
        <button data-act="label" data-id="${s.id}">Label</button>
        <button data-act="del" data-id="${s.id}">Delete</button>
      </td>
    </tr>
  `).join('');

  const total   = spools.length;
  const withRem = spools.filter(s => (s.remainingG || 0) > 0).length;
  spSummary.textContent = `${rows.length}/${total} shown ¬∑ ${withRem} have remaining`;
}


function setActiveSpool(id) {
  saveActive(id || '');
  spActiveSel.value = activeSpoolId || '';
  setActivity(
    activeSpoolId ? `Active spool: ${activeSpoolId}` : 'No active spool',
    activeSpoolId ? 'ok' : ''
  );
}

// --- Lot / Batch auto-generator ---
function _slug3(s) {
  // first 3 letters/numbers of brand, fallback to 'XXX'
  const t = String(s || '').replace(/[^a-z0-9]/gi, '').toUpperCase();
  return (t.slice(0, 3) || 'XXX').padEnd(3, 'X');
}
function _matCode(s) {
  const k = String(s || '').trim().toUpperCase();
  if (k.startsWith('PA')) return 'NYL'; // PA, PA6, PA12 -> Nylon
  return (k || 'MAT').slice(0, 3);
}
function _dateYYMMDD(dateStr) {
  const d = dateStr ? new Date(dateStr) : new Date();
  const y = String(d.getFullYear()).slice(-2);
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const dd = String(d.getDate()).padStart(2, '0');
  return `${y}${m}${dd}`;
}
function genLotBatch() {
  const brand = _slug3(spBrand.value);
  const mat   = _matCode(spMaterial.value);
  const ymd   = _dateYYMMDD(spDate.value);
  const seq   = Math.random().toString(36).slice(2, 5).toUpperCase();
  return `${brand}-${mat}${ymd}-${seq}`;
}
/**
 * Fill lot only if:
 *  - force = true, or
 *  - field is empty, or
 *  - it was previously auto-filled (tracked via data-auto="1")
 */
function autofillLot(force = false) {
  if (!spLot) return;
  if (force || !spLot.value || spLot.dataset.auto === '1') {
    spLot.value = genLotBatch();
    spLot.dataset.auto = '1';
  }
}

// Keep lot in sync while user is building a new spool
spBrand?.addEventListener('input',  () => autofillLot(false));
spMaterial?.addEventListener('change', () => autofillLot(false));
spDate?.addEventListener('change', () => autofillLot(false));

// Optional: a quick way to "lock" custom lot once user types anything
spLot?.addEventListener('input', () => { delete spLot.dataset.auto; });

function ensureMeshTable() {
  if (!meshInput) return;
  if (meshInput.children.length) return; // already built

  const rows = 4, cols = 4;
  meshInput.innerHTML = '';
  for (let r = 0; r < rows; r++) {
    const tr = document.createElement('tr');
    for (let c = 0; c < cols; c++) {
      const td = document.createElement('td');
      const inp = document.createElement('input');
      inp.type = 'number';
      inp.step = '0.001';
      inp.style.width = '90px';
      inp.id = `m_${r}_${c}`;
      td.appendChild(inp);
      tr.appendChild(td);
    }
    meshInput.appendChild(tr);
  }
}

document.addEventListener('DOMContentLoaded', ensureMeshTable);

function deleteSpool(id) {
  const s = findSpool(id);
  if (!s) return;
  if (!safeConfirm(`Delete spool ${id}?`)) return;
  spools = spools.filter(x => x.id !== id);
  if (activeSpoolId === id) saveActive('');
  saveSpools();
  renderSpoolList();
  renderActiveSel();
}

function adjustRemaining(id, deltaG) {
  const s = findSpool(id);
  if (!s) return;
  const cap = s.capacityG || 0;
  s.remainingG = clamp((s.remainingG || 0) + deltaG, 0, cap);
  s.updatedAt  = Date.now();
  saveSpools();
  renderSpoolList();
  renderActiveSel();
}

// =============== FILAMENT: event wiring ===============
spMaterial?.addEventListener('change', fillDensityByMaterial);
spReset?.addEventListener('click', () => clearForm(true));
spoolForm?.addEventListener('submit', upsertFromForm);

spTable?.addEventListener('click', (e) => {
  const btn = e.target.closest('button');
  if (!btn) return;
  const id  = btn.getAttribute('data-id');
  const s   = findSpool(id);
  const act = btn.getAttribute('data-act');

  if (act === 'edit'      && s) fillForm(s);
  if (act === 'setActive' && s) setActiveSpool(id);
  if (act === 'label'     && s) openPrintLabel(s);
  if (act === 'del')           deleteSpool(id);
});

[spSearch, spMatFilter, spOnlyRemaining, spSort]
  .forEach(el => el?.addEventListener('input', renderSpoolList));

spActiveSel?.addEventListener('change', () => setActiveSpool(spActiveSel.value || ''));

spPrintLbl?.addEventListener('click', () => {
  const s = findSpool(activeSpoolId || '');
  if (!s) return alert('Select an active spool first.');
  openPrintLabel(s);
});

spWeigh?.addEventListener('click', () => {
  const s = findSpool(activeSpoolId || '');
  if (!s) return alert('Select an active spool first.');
  const gross = parseFloat(safePrompt('Current gross weight (g) ‚Äî spool+filament on scale:', '850') || '');
  if (!Number.isFinite(gross) || gross <= 0) return;
  const net = gross - (s.tareG || 0);
  if (net < 0) return alert('Gross must be ‚â• tare weight.');
  s.remainingG = clamp(Math.round(net), 0, s.capacityG || 0);
  s.updatedAt  = Date.now();
  saveSpools();
  renderSpoolList();
  renderActiveSel();
});

spDeduct5?.addEventListener('click', () => {
  const s = findSpool(activeSpoolId || '');
  if (!s) return alert('Select an active spool first.');

  const def = localStorage.getItem('spDeductDefault') || '5';
  const input = safePrompt('Deduct amount (grams):', def);
  const amt = parseFloat(input || '');
  if (!Number.isFinite(amt) || amt <= 0) return;

  localStorage.setItem('spDeductDefault', String(amt));
  adjustRemaining(s.id, -Math.abs(amt)); // deduct
});

spMarkEmpty?.addEventListener('click', () => {
  const s = findSpool(activeSpoolId || '');
  if (!s) return alert('Select an active spool first.');
  s.remainingG = 0;
  s.updatedAt  = Date.now();
  saveSpools();
  renderSpoolList();
});

// =============== FILAMENT: init ===============
(function filamentInit() {
  try {
    loadSpools();
    loadActive?.();          // if you have it
    clearGhostActive();      // <= add this line
    renderSpoolList();
    renderActiveSel();
    clearForm(true);
  } catch (e) {
    console.error('filamentInit failed:', e);
  }
})();

function updatePricePerKg() {
  const totalPrice = parseFloat(spCostTotal.value) || 0;
  const capacityGrams = parseFloat(spCapacity.value) || 0;
  if (capacityGrams > 0) {
    const perKg = totalPrice / (capacityGrams / 1000);
    spCostPerKg.value = perKg.toFixed(2);
  } else {
    spCostPerKg.value = '';
  }
}

spCostTotal.addEventListener('input', updatePricePerKg);
spCapacity.addEventListener('input', updatePricePerKg);











function getHomeSig() {
  try { return JSON.parse(localStorage.getItem('homeSig')) || HOME_SIG_DEFAULT; }
  catch { return HOME_SIG_DEFAULT; }
}
function setHomeSig(sig) {
  localStorage.setItem('homeSig', JSON.stringify(sig));
}

// Call on every incoming log line to update the ‚Äúhint‚Äù window
function maybeMarkHomingHint(line) {
  if (/\b(Homing|Home\s+all|Taring probe|Preheating)\b/i.test(line)) {
    lastHomeHintAt = performance.now();
  }
}

// Call when you parse a position to decide if we‚Äôre homed
function maybeMarkHomedFromPos(x, y, z) {
  const now = performance.now();

  // If we saw a homing-ish line very recently, trust this as homed
  if (now - lastHomeHintAt < 4000) {
    isHomed = true;
    return;
  }

  // Otherwise, compare to a known "home signature" with tolerance
  const sig = getHomeSig();
  const near =
    Math.abs(x - sig.x) <= sig.tolX &&
    Math.abs(y - sig.y) <= sig.tolY &&
    Math.abs(z - sig.z) <= sig.tolZ;

  if (near) isHomed = true;
}

// (optional) learn & persist your printer‚Äôs home signature after a known-good G28
function learnHomeSignature(x, y, z) {
  setHomeSig({ x, y, z, tolX: 2.0, tolY: 2.0, tolZ: 4.0 });
}

// === Nozzle Wipe + Prime Line (staged warmup, safe home, purge, cool, exit) ===
async function runPrimeLine() {
  cancelStream = false; // ‚Üê clear leftover cancel flag from a previous send
  const HOT_FINAL = 200;
  const BED_FINAL = 60;

  try {
    setActivity('Nozzle prep‚Ä¶', 'warn');

    // Restore mesh & motion defaults
    await sendCmdsSequential(
      'M420 S1',
      'M201 X500.00 Y500.00 Z100.00 E5000.00',
      'M203 X500.00 Y500.00 Z10.00 E50.00',
      'M204 P500.00 R1000.00 T500.00',
      'M205 X8.00 Y8.00 Z0.40 E5.00',
      'M220 S100',
      'M221 S100'
    );

    // Staged warmup to avoid droop before homing (per your script)
    await sendCmd('M190 S50');            await waitForOk(); // bed to 50 (wait)
    await sendCmd('M140 S65');            await waitForOk(); // bed target 65 (no wait)
    await sendCmd('M104 S120');           await waitForOk(); // nozzle 120 (no wait)
    await sendCmd('M190 S65');            await waitForOk(); // bed to 65 (wait)
    await sendCmd('M109 S145');           await waitForOk(); // nozzle to 145 (wait)
    await sendCmd('M105');                await waitForOk();

    // Home while warm (Z sensor happy at ~145)
    await sendCmd('G28');                 await waitForOk();

    // Set final print temps (don‚Äôt wait yet), park, then wait to temps
    await sendCmd(`M104 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd(`M140 S${BED_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();
    await sendCmdsSequential('G90', 'G0 Z20', 'G0 X0 Y0');
    await sendCmd(`M190 S${BED_FINAL}`);  await waitForOk();
    await sendCmd(`M109 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();

    // Purge / prime lines
    await sendCmdsSequential(
      'G92 E0',
      'M83',
      'G1 Z2.0 F3000',
      'G1 X10.1 Y20 Z0.28 F5000.0',
      'G1 X10.1 Y200.0 Z0.28 F1500.0 E15',
      'G1 X10.4 Y200.0 Z0.28 F5000.0',
      'G1 X10.4 Y20 Z0.28 F1500.0 E30',
      'G92 E0',
      'G1 Z2.0 F3000',
      'M82'
    );

    // Drain queue, Z hop +10, cool down, then close print screen
    await sendCmd('M400');                await waitForOk().catch(()=>{});
    await sendCmd('G91');                 await waitForOk().catch(()=>{});
    await sendCmd('G1 Z10 F600');         await waitForOk().catch(()=>{});
    await sendCmd('G90');                 await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');             await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');             await waitForOk().catch(()=>{});
    exitPrintScreen(0, { tellHost: false }); 

    isHomed = true;
    setActivity('Wipe + prime complete (cooled)', 'ok');
    logMsg('‚úÖ Homed at 65/145; primed at 200/60; Z+10; heaters OFF; closed print screen.');
    updateLastUpdated();
  } catch (e) {
    setActivity('Prep failed', 'bad');
    logMsg('‚ö†Ô∏è Wipe/prime error: ' + (e?.message || e));
  }
}

// === Nozzle Wipe + Prime Line (staged warmup, safe home, purge, cool, exit) ===
async function runPrimeLine() {
  const HOT_FINAL = 200;
  const BED_FINAL = 60;

  try {
    setActivity('Nozzle prep‚Ä¶', 'warn');

    // Restore mesh & motion defaults
    await sendCmdsSequential(
      'M420 S1',
      'M201 X500.00 Y500.00 Z100.00 E5000.00',
      'M203 X500.00 Y500.00 Z10.00 E50.00',
      'M204 P500.00 R1000.00 T500.00',
      'M205 X8.00 Y8.00 Z0.40 E5.00',
      'M220 S100',
      'M221 S100'
    );

    // Staged warmup to avoid droop before homing (per your script)
    await sendCmd('M190 S50');            await waitForOk(); // bed to 50 (wait)
    await sendCmd('M140 S65');            await waitForOk(); // bed target 65 (no wait)
    await sendCmd('M104 S120');           await waitForOk(); // nozzle 120 (no wait)
    await sendCmd('M190 S65');            await waitForOk(); // bed to 65 (wait)
    await sendCmd('M109 S145');           await waitForOk(); // nozzle to 145 (wait)
    await sendCmd('M105');                await waitForOk();

    // Home while warm (Z sensor happy at ~145)
    await sendCmd('G28');                 await waitForOk();

    // Set final print temps (don‚Äôt wait yet), park, then wait to temps
    await sendCmd(`M104 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd(`M140 S${BED_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();
    await sendCmdsSequential('G90', 'G0 Z20', 'G0 X0 Y0');
    await sendCmd(`M190 S${BED_FINAL}`);  await waitForOk();
    await sendCmd(`M109 S${HOT_FINAL}`);  await waitForOk();
    await sendCmd('M105');                await waitForOk();

    // Purge / prime lines
    await sendCmdsSequential(
      'G92 E0',
      'M83',
      'G1 Z2.0 F3000',
      'G1 X10.1 Y20 Z0.28 F5000.0',
      'G1 X10.1 Y200.0 Z0.28 F1500.0 E15',
      'G1 X10.4 Y200.0 Z0.28 F5000.0',
      'G1 X10.4 Y20 Z0.28 F1500.0 E30',
      'G92 E0',
      'G1 Z2.0 F3000',
      'M82'
    );

    // Drain queue, Z hop +10, cool down, then close print screen
    await sendCmd('M400');                await waitForOk().catch(()=>{});
    await sendCmd('G91');                 await waitForOk().catch(()=>{});
    await sendCmd('G1 Z10 F600');         await waitForOk().catch(()=>{});
    await sendCmd('G90');                 await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');             await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');             await waitForOk().catch(()=>{});
    exitPrintScreen(0, { tellHost: false }); 

    isHomed = true;
    setActivity('Wipe + prime complete (cooled)', 'ok');
    logMsg('‚úÖ Homed at 65/145; primed at 200/60; Z+10; heaters OFF; closed print screen.');
    updateLastUpdated();
  } catch (e) {
    setActivity('Prep failed', 'bad');
    logMsg('‚ö†Ô∏è Wipe/prime error: ' + (e?.message || e));
  }
}


function _ensureAudioCtx() {
  if (!_audioCtx) {
    try { _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {}
  }
  if (_audioCtx && _audioCtx.state === 'suspended') _audioCtx.resume();
  return _audioCtx;
}

function _tone(freq=880, ms=120, vol=0.22, when=0) {
  const ctx = _ensureAudioCtx(); if (!ctx) return;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.value = freq;

  const t0 = ctx.currentTime + when;
  gain.gain.setValueAtTime(0.0001, t0);
  gain.gain.linearRampToValueAtTime(vol, t0 + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.0001, t0 + ms/1000);

  osc.connect(gain).connect(ctx.destination);
  osc.start(t0);
  osc.stop(t0 + ms/1000 + 0.02);
}

function beep(kind='start') {
  try {
    if (!BEEP_BROWSER_ON) return;
    if (kind === 'start') { _tone(880,120,0.24,0); _tone(1100,120,0.24,0.15); }
    else if (kind === 'done') { _tone(784,120,0.24,0); _tone(988,120,0.24,0.16); _tone(1319,160,0.26,0.34); }
    else if (kind === 'cancel') { _tone(220,260,0.28,0); }
    else if (kind === 'error') { _tone(200,160,0.28,0); _tone(150,220,0.28,0.22); }
    if (navigator.vibrate) {
      if (kind === 'start') navigator.vibrate([25]);
      else if (kind === 'done') navigator.vibrate([20,40,20]);
      else if (kind === 'cancel' || kind === 'error') navigator.vibrate([60]);
    }
  } catch {}
}

async function printerBeep(kind='start') {
  if (!BEEP_PRINTER_ON) return;
  // only try if connected
  if (!(connKind === 'virtual' || writer)) return;

  // simple patterns (freq S, duration P)
  const seq = (kind === 'start') ? [[880,120],[1100,120]]
            : (kind === 'done')  ? [[784,120],[988,120],[1319,160]]
            : (kind === 'cancel')? [[220,260]]
            :                      [];
  try {
    for (const [s,p] of seq) {
      await sendCmd(`M300 S${Math.round(s)} P${Math.round(p)}`);
      await waitForOk().catch(()=>{});
      await sleep(10);
    }
  } catch {}
}

/* ===== Live Telemetry Chart (temps, fan %, M73 %) ===== */
const live = {
  els: [],        // canvases
  ctxs: [],       // 2D contexts
  buf: [],        // ring buffer of samples
  maxSec: 600,    // 10 minutes window
  lastFan255: 0,  // set elsewhere when fan speed is parsed (0..255)
  lastProg: null, // set elsewhere from M73 (%) if available
  raf: 0
};


(function initLiveChart(){
  // Prefer all canvases with class="liveChart"
  live.els = Array.from(document.querySelectorAll('.liveChart'));
  // Fallback to legacy single id="liveChart"
  if (!live.els.length) {
    const one = document.getElementById('liveChart');
    if (one) live.els = [one];
  }
  live.ctxs = live.els.map(el => el.getContext('2d'));

  const resize = () => {
    const dpr = window.devicePixelRatio || 1;
    live.els.forEach((el, i) => {
      const ctx = live.ctxs[i];
      if (!ctx) return;
      const cssW = el.clientWidth  || 900;
      const cssH = el.clientHeight || 260;
      el.width  = Math.round(cssW * dpr);
      el.height = Math.round(cssH * dpr);
      // draw in CSS pixels while benefiting from HiDPI backing store
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    });
    queueLiveDraw();
  };

  window.addEventListener('resize', resize);
  resize();
})();

function fmt(n, d=2) { return Number.isFinite(n) ? (+n).toFixed(d) : '‚Äî'; }
function fmtDelta(n) {
  if (!Number.isFinite(n)) return '‚Äî';
  if (n === 0) return '¬±0.00';
  return n > 0 ? `+${n.toFixed(2)}` : n.toFixed(2);
}

function prevKey(which) {
  return which === 'bed' ? 'pidPrev:bed' : 'pidPrev:hotend';
}

function fmt2(n) { return Number.isFinite(n) ? (+n).toFixed(2) : '‚Äî'; }
function delta2(a, b) {
  if (!Number.isFinite(a) || !Number.isFinite(b)) return '‚Äî';
  const d = a - b;
  return d === 0 ? '¬±0.00' : (d > 0 ? `+${d.toFixed(2)}` : d.toFixed(2));
}

function recordLiveSample() {
  if (!live.ctxs.length) return;
  const now = Date.now() / 1000;

  // temps.* should already be maintained by your M105 parser
  live.buf.push({
    ts: now,
    hot: Number.isFinite(temps?.hot) ? temps.hot : null,
    bed: Number.isFinite(temps?.bed) ? temps.bed : null,
    fanPct: Number.isFinite(live.lastFan255) ? Math.round(live.lastFan255 * 100 / 255) : null,
    progPct: (live.lastProg != null ? live.lastProg : null)
  });

  // prune old samples outside window
  const cut = now - live.maxSec;
  while (live.buf.length && live.buf[0].ts < cut) live.buf.shift();

  queueLiveDraw();
}

function queueLiveDraw(){
  if (live.raf) return;
  live.raf = requestAnimationFrame(() => {
    live.raf = 0;
    drawLive();
  });
}

function drawLive(){
  if (!live.ctxs.length) return;

  live.ctxs.forEach((ctx, idx) => {
    const el = live.els[idx];
    if (!ctx || !el) return;

    // Use backing size (works even on hidden tab)
    const dpr = window.devicePixelRatio || 1;
    const W = (el.width  || (el.clientWidth  || 900) * dpr) / dpr;
    const H = (el.height || (el.clientHeight || 260) * dpr) / dpr;

    // Panel bg (auto light/dark)
    const bodyBg = getComputedStyle(document.body).backgroundColor || 'rgb(255,255,255)';
    const [r,g,b] = (bodyBg.match(/\d+/g) || ['255','255','255']).slice(0,3).map(Number);
    const isDark = (r+g+b) < 3*128;

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = isDark ? '#0f1115' : '#f7f7fa';
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // Plot rect
    const padL = 40, padR = 40, padT = 10, padB = 20;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;
    ctx.save();
    ctx.fillStyle = isDark ? '#151820' : '#ffffff';
    ctx.fillRect(padL, padT, plotW, plotH);
    ctx.restore();

    // Time domain
    const now = Date.now()/1000;
    const t0 = now - live.maxSec, t1 = now;

    // Scales
    const tempMin = 0, tempMax = 270;
    const pctMin  = 0, pctMax  = 100;
    const xOf   = ts => padL + ((ts - t0) / (t1 - t0)) * plotW;
    const yTemp = v  => padT + (1 - (v - tempMin) / (tempMax - tempMin)) * plotH;
    const yPct  = v  => padT + (1 - (v - pctMin)  / (pctMax  - pctMin )) * plotH;

    // Grid
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = isDark ? '#ffffff' : '#000000';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i=0;i<=5;i++){
      const y = padT + (i/5)*plotH;
      ctx.moveTo(padL, y); ctx.lineTo(W - padR, y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Axis labels
    ctx.fillStyle = isDark ? '#d0d0d0' : '#333';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign = 'left';
    ctx.fillText('¬∞C', 4, padT + 12);
    ctx.textAlign = 'right';
    ctx.fillText('%', W - 4, padT + 12);

    // Polyline helper
    const drawSeries = (getY, key) => {
      if (!live.buf?.length) return; // no samples yet ‚Üí don't draw lines
      ctx.beginPath();
      let started = false;
      for (const s of live.buf) {
        const v = s[key];
        if (!Number.isFinite(v)) { started = false; continue; }
        const x = xOf(s.ts), y = getY(v);
        if (!started) { ctx.moveTo(x, y); started = true; }
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    };

    // Hotend (red), Bed (blue dashed), Fan% (grey), M73% (green dotted)
    ctx.save(); ctx.strokeStyle = '#e53935'; ctx.lineWidth = 2;   ctx.setLineDash([]);     ctx.lineCap='round'; drawSeries(yTemp,'hot');     ctx.restore();
    ctx.save(); ctx.strokeStyle = '#1e88e5'; ctx.lineWidth = 2;   ctx.setLineDash([5,4]);  ctx.lineCap='round'; drawSeries(yTemp,'bed');     ctx.restore();
    ctx.save(); ctx.strokeStyle = '#6d6d6d'; ctx.lineWidth = 1.5; ctx.setLineDash([]);                         drawSeries(yPct ,'fanPct');  ctx.restore();
    ctx.save(); ctx.strokeStyle = '#43a047'; ctx.lineWidth = 1.5; ctx.setLineDash([2,3]);                      drawSeries(yPct,'progPct');  ctx.restore();

    // === PID target overlay (dashed purple) ===
    let tPid = null;
    if (pidActiveBed || pidActiveHotend || pidTarget) {
      if (Number.isFinite(pidTargetTemp)) {
        tPid = pidTargetTemp;
      } else if ((pidActiveBed || pidTarget === 'bed') && Number.isFinite(temps.bedTarget)) {
        tPid = temps.bedTarget;
      } else if ((pidActiveHotend || pidTarget === 'hotend') && Number.isFinite(temps.hotTarget)) {
        tPid = temps.hotTarget;
      }
    }
    if (Number.isFinite(tPid)) {
      // clamp to chart range in case target is outside bounds
      const tClamped = Math.min(Math.max(tPid, tempMin), tempMax);
      const y = yTemp(tClamped);

      ctx.save();
      ctx.strokeStyle = '#8e24aa';
      ctx.setLineDash([8,4]);
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(W - padR, y);
      ctx.stroke();
      ctx.fillStyle = '#8e24aa';
      ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      ctx.fillText(`PID Target ${Math.round(tPid)}¬∞`, W - padR - 4, y - 4);
      ctx.restore();
    }

    // === Legend ===
    // Draw a color legend for the series (Nozzle, Bed, Fan, M73, Target)
    {
      const legendItems = [
        {color:'#e53935', dash:[],       text:'Nozzle'},
        {color:'#1e88e5', dash:[5,4],    text:'Bed'},
        {color:'#6d6d6d', dash:[],       text:'Fan'},
        {color:'#43a047', dash:[2,3],    text:'M73'},
        {color:'#8e24aa', dash:[8,4],    text:'Target'}
      ];
      ctx.save();
      ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textBaseline = 'middle';
      let lx = padL + 6;
      const ly = padT + 6;
      legendItems.forEach(item => {
        // draw line sample
        ctx.strokeStyle = item.color;
        ctx.lineWidth = 2;
        ctx.setLineDash(item.dash || []);
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(lx + 14, ly);
        ctx.stroke();
        ctx.setLineDash([]);
        // draw text label next to line
        ctx.fillStyle = isDark ? '#d0d0d0' : '#333';
        ctx.textAlign = 'left';
        ctx.fillText(item.text, lx + 18, ly);
        lx += ctx.measureText(item.text).width + 40;
      });
      ctx.restore();
    }

    // === Time axis ticks and labels ===
    // Draw small ticks at 1-minute intervals and labels from 10m down to 0m
    {
      ctx.save();
      ctx.strokeStyle = isDark ? '#aaaaaa' : '#555';
      ctx.fillStyle   = isDark ? '#aaaaaa' : '#555';
      ctx.lineWidth = 1;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // compute total minutes in view (should be 10)
      const totalMin = Math.round((t1 - t0) / 60);
      const maxMin   = Math.min(totalMin, 10);
      for (let m = 0; m <= maxMin; m++) {
        const ts = t0 + m * 60;
        const x  = xOf(ts);
        // tick line
        ctx.beginPath();
        ctx.moveTo(x, padT + plotH);
        ctx.lineTo(x, padT + plotH + 4);
        ctx.stroke();
        // label minutes remaining (e.g. 10m ... 0m)
        const labelMin = maxMin - m;
        const label = `${labelMin}m`;
        ctx.fillText(label, x, padT + plotH + 6);
      }
      ctx.restore();
    }
  });
}


function openPreflight(file) {
  _preflightFile = file;

  // dynamic bits
  document.getElementById('preFileName').textContent = file?.name || '(unnamed)';
  document.getElementById('preGuardrail').textContent = heaterUnlocked ? 'OFF' : 'ON';
  const ht = (temps.hot ?? NaN), bt = (temps.bed ?? NaN);
  const hT = (temps.hotTarget ?? NaN), bT = (temps.bedTarget ?? NaN);
  const fmt = (v) => Number.isFinite(v) ? (''+ (v % 1 ? v.toFixed(1) : Math.round(v))) : '‚Äî';
  document.getElementById('preTemps').textContent = `${fmt(ht)} / ${fmt(hT)} ¬∑ ${fmt(bt)} / ${fmt(bT)}`;
  document.getElementById('preMode').textContent = (connKind === 'virtual') ? 'Virtual' : 'Serial';
  document.getElementById('preHomed').textContent = isHomed ? 'Yes' : 'No';

  // reset checks & button
  document.querySelectorAll('.preChk').forEach(c => c.checked = false);
  document.getElementById('preStart').disabled = true;
  document.getElementById('preSkip').checked = false;

  // wire buttons
document.getElementById('preStart').onclick = async () => {
  if (document.getElementById('preSkip').checked) {
    sessionStorage.setItem('skipPreflight','1');
  }
  const f = _preflightFile; // capture file first
  closePreflight();
  await maybeAutoProbeBeforePrint(); // check mesh age & optionally run probe
  if (f) await streamGcode(f);
};

  document.getElementById('preCancel').onclick = closePreflight;
  document.getElementById('preClose').onclick  = closePreflight;

  document.getElementById('preHome').onclick = async () => {
    try {
      await sendCmd('G28'); await waitForOk().catch(()=>{});
      isHomed = true;
      document.getElementById('preHomed').textContent = 'Yes';
    } catch {}
  };
  document.getElementById('prePark').onclick = async () => {
    try { await sendCmdsSequential('G90', 'G1 X0 Y0 Z10 F3000'); } catch {}
  };

  // show
  document.getElementById('preOverlay').style.display = 'block';
  document.getElementById('preModal').style.display   = 'grid';

  // esc to close
  const esc = (e) => { if (e.key === 'Escape') closePreflight(); };
  document.addEventListener('keydown', esc, { once:true });
}

function closePreflight() {
  document.getElementById('preModal').style.display   = 'none';
  document.getElementById('preOverlay').style.display = 'none';
  _preflightFile = null;
}

function updateUnlockUi() {
  const btn  = document.getElementById('unlockTempsBtn');
  const hint = document.getElementById('unlockHint');
  if (!btn) return;

  // Toggle label + aria state
  btn.textContent = heaterUnlocked ? 'Lock high hotend temps' : 'Unlock high hotend temps';
  btn.setAttribute('aria-pressed', heaterUnlocked ? 'true' : 'false');

  // Helper text
  if (hint) {
    hint.textContent = heaterUnlocked
    ? '‚ö†Ô∏è Guardrail OFF ‚Äî be careful.'
    : '‚úÖ Guardrail ON ‚Äî 250¬∞C caps active.';
  }
}

function setHeaterUnlocked(on) {
  heaterUnlocked = !!on;
  localStorage.setItem('heaterUnlocked', JSON.stringify(heaterUnlocked));
  updateUnlockUi();

  const msg = heaterUnlocked
    ? '‚ö†Ô∏è Guardrail OFF ‚Äî be careful.'
    : '‚úÖ Guardrail ON ‚Äî 250¬∞C caps active.';
  const text = heaterUnlocked ? 'High hotend temps UNLOCKED' : 'High hotend temps LOCKED';
  const cls  = heaterUnlocked ? 'warn' : '';

  setActivity(text, cls);
  logMsg(msg);
}


function onUnlockToggle(e){
  e.preventDefault();
  setHeaterUnlocked(!heaterUnlocked);
  setActivity(heaterUnlocked ? 'High hotend temps UNLOCKED' : 'High hotend temps LOCKED',
              heaterUnlocked ? 'warn' : '');
  logMsg(heaterUnlocked ? '‚ö†Ô∏è Guardrail OFF ‚Äî be careful.'
                        : '‚úÖ Guardrail ON ‚Äî 250¬∞C caps active.');
}

if (unlockTempsBtn) unlockTempsBtn.onclick = onUnlockToggle; // bind once

function guardHeaterFromCmd(cmd) {
  if (heaterUnlocked) return true;
  // Only gate heater-set commands with S values
  if (!/^(?:M10(?:4|9)|M1(?:40|90))\b/i.test(cmd)) return true;
  const s = cmd.match(/\bS\s*([0-9.]+)/i);
  if (!s) return true;

  const val = parseFloat(s[1]);
  const isHot = /^M10(?:4|9)\b/i.test(cmd);
  const lim = isHot ? MAX_HOTEND : MAX_BED;

  if (val > lim) {
    setActivity('Heater limit blocked', 'bad');
    logMsg(`‚õî Blocked: ${cmd} (limit ${lim}¬∞C; click ‚ÄúUnlock hotend high temps‚Äù to override)`);
    return false;
  }
  return true;
}

function guardHeaterSet(tool, target, sourceLabel='UI') {
  const limit = tool === 'hotend' ? MAX_HOTEND : MAX_BED;
  if (Number.isFinite(target) && target > limit && !heaterUnlocked) {
    setActivity('Blocked by heater guardrail', 'bad');
    alert(`‚õî Limit ${limit}¬∞C. Requested ${target}¬∞C from ${sourceLabel}. Click ‚ÄúUnlock high hotend temps‚Äù to allow this.`);
    return false;
  }
  return true;
}

function startNetMeter() {
  if (net.timer) return;
  net.lastSample = performance.now();
  net.timer = setInterval(sampleNet, 1000);
}

function stopNetMeter() {
  if (net.timer) { clearInterval(net.timer); net.timer = null; }
  net.txRate = 0; net.rxRate = 0;
  updateNetUi();
}

function sampleNet() {
  const now = performance.now();
  const dt = (now - net.lastSample) / 1000;
  if (dt <= 0) return;

  const txInstant = net.txSince / dt;
  const rxInstant = net.rxSince / dt;
  const a = 0.30; // EMA smoothing

  net.txRate = net.txRate ? (a * txInstant + (1 - a) * net.txRate) : txInstant;
  net.rxRate = net.rxRate ? (a * rxInstant + (1 - a) * net.rxRate) : rxInstant;

  net.txSince = 0;
  net.rxSince = 0;
  net.lastSample = now;

  updateNetUi();
}

function fmtRate(v) {
  if (!v) return '‚Äî';
  if (v < 1024) return `${Math.round(v)} B/s`;
  if (v < 1024 * 1024) return `${(v / 1024).toFixed(1)} KB/s`;
  return `${(v / 1024 / 1024).toFixed(2)} MB/s`;
}





function updateNetUi() {
  const el = document.getElementById('netPill');
  if (!el) return;
  const lat = (net.latencyEMA != null) ? `${Math.round(net.latencyEMA)} ms` : '‚Äî';
  el.textContent = `TX ${fmtRate(net.txRate)} ¬∑ RX ${fmtRate(net.rxRate)} ¬∑ Lat ${lat}`;
}

function updateLatency(ms) {
  const a = 0.20; // EMA for OK latency
  net.latencyEMA = (net.latencyEMA == null) ? ms : (a * ms + (1 - a) * net.latencyEMA);
  updateNetUi();
}


// --- Baud selection and robust open/probe helpers ---------------------------
function baudSelection() {
  const sel = document.getElementById('baudSelect');
  const v = sel?.value || 'auto';
  if (v !== 'auto') {
    const fixed = parseInt(v, 10);
    return { mode: 'manual', list: Number.isFinite(fixed) ? [fixed] : [115200] };
  }
  // Try common rates (most likely first)
  return { mode: 'auto', list: [250000, 115200, 230400, 500000, 1000000, 57600] };
}

async function nudgeDTRRTS() {
  // Some boards wake/reset on signal toggles
  try {
    await port.setSignals({ dataTerminalReady: true,  requestToSend: true });
    await sleep(80);
    await port.setSignals({ dataTerminalReady: false, requestToSend: false });
  } catch { /* not supported on every driver */}
}

async function openAtBaud(baud) {
  // Clean any prior state
  try { if (reader) await reader.cancel(); } catch {}
  try { if (reader) reader.releaseLock(); } catch {}
  try { if (writer) writer.releaseLock(); } catch {}
  try { if (port && (port.readable || port.writable)) await port.close(); } catch {}

  await port.open({ baudRate: baud });

  // Pipe as strings when available for better perf
  if (typeof TextDecoderStream !== 'undefined') {
    const tds = new TextDecoderStream();
    textDecoder = tds;
    port.readable.pipeTo(tds.writable).catch(() => {});
    reader = tds.readable.getReader();      // yields strings
  } else {
    textDecoder = new TextDecoder();
    reader = port.readable.getReader();     // yields Uint8Array
  }
  writer = port.writable.getWriter();

  await nudgeDTRRTS(); // wake it up a bit
  return { success: true, baud };
}

// Auto-detect helper: open, poke, and look for tokens; otherwise close & fail.
async function probeAtBaud(baud, timeoutMs = 5000) {
  try {
    await openAtBaud(baud);
  } catch (e) {
    return { success: false, error: e };
  }

  const enc = new TextEncoder();
  const poke = async (s) => { try { await writer.write(enc.encode(s)); } catch {} };

  // Send a few CRLFs then M115; some stacks only react to \r\n
  await poke('\r\n\r\nM115\r\n');

  const deadline = performance.now() + timeoutMs;
  let buf = '';

  try {
    while (performance.now() < deadline) {
      const { value, done } = await reader.read();
      if (done) break;

      // Normalize to string
      const chunk = (value instanceof Uint8Array)
        ? textDecoder.decode(value, { stream: true })
        : (value ?? '');

      buf += chunk;

      // Accept any of these as "alive":
      // - Marlin/RepRap M115 banner
      // - a plain "start"
      // - an "ok"
      // - temps like "T:..." or "B:..."
      if (/FIRMWARE_NAME:|^start\b|^ok\b|T:\s*[-+]?\d|B:\s*[-+]?\d/m.test(buf)) {
        return { success: true, baud };
      }
    }
  } catch { /* ignore transient read errors during probing */ }

  // No luck: tear down cleanly
  try { await reader.cancel(); } catch {}
  try { reader.releaseLock(); } catch {}
  try { writer.releaseLock(); } catch {}
  try { await port.close(); } catch {}

  return { success: false };
}










async function maybeAutoProbeBeforePrint() {
  try {
    const enabled = localStorage.getItem('autoProbeAging') === '1';
    if (!enabled) return;

    const lastTs = parseInt(localStorage.getItem('levelsLastAt')||'0',10);
    if (!lastTs) return; // no mesh stored yet

    const THRESH_MS = 30 * 24 * 60 * 60 * 1000; // 30 days
    if ((Date.now() - lastTs) >= THRESH_MS) {
      const go = typeof safeConfirm === 'function'
        ? safeConfirm('Your last bed mesh is over 30 days old.\nRun Home & Probe now (G28 ‚Üí G29 T)?')
        : confirm('Your last bed mesh is over 30 days old.\nRun Home & Probe now (G28 ‚Üí G29 T)?');
      if (!go) return;
      await homeAndProbe(); // will save mesh and update timestamp
    }
  } catch (e) {
    console.warn('[auto-probe] skipped due to error:', e);
  }
}





//Critical section helpers
function beginCritical() { if (criticalDepth++ === 0) stopTempPolling(); }

function endCritical()   { if (criticalDepth > 0 && --criticalDepth === 0) startTempPolling(); }

//Ambient sampling
function _pushAmbientSample(tool, temp, target) {
  const now = Date.now() / 1000;
  const buf = _ambientBuf[tool];
  // Only track when target is off/zero/unknown
  if (target == null || target <= 0) {
    buf.push([now, temp]);
    while (buf.length && (now - buf[0][0]) > AMBIENT_WINDOW_SEC) buf.shift();
  } else {
    // heating/cooling to a target ‚Äî clear buffer so we don't mislabel
    buf.length = 0;
  }
}

function _ambientPlateau(tool) {
  const buf = _ambientBuf[tool];
  if (buf.length < 2) return null;
  const span = buf[buf.length - 1][0] - buf[0][0];
  if (span < AMBIENT_MIN_SEC) return null;

  let min = +Infinity, max = -Infinity;
  for (const [, t] of buf) { if (t < min) min = t; if (t > max) max = t; }
  const spread = max - min;

  const first = buf[0], last = buf[buf.length - 1];
  const slope = (last[1] - first[1]) / Math.max(1, (last[0] - first[0])); // ¬∞C/s
  if (spread <= AMBIENT_MAX_SPREAD && Math.abs(slope) <= AMBIENT_MAX_SLOPE) {
    // use mean as ambient estimate
    const avg = buf.reduce((a, [,t]) => a + t, 0) / buf.length;
    return { ambient: avg, spread, slope, span };
  }
  return null;
}

//ETA helpers
function isCountingLine(g) {
  const s = g.trim();
  if (!s || s.startsWith(';')) return false;

  // Ignore homing/leveling/heating/waits/setup
  if (/^(?:G28|G29|M104|M109|M140|M190|M82|M83|G90|G91|M84|M400)\b/i.test(s)) return false;

  // Count real motion lines; require X or Y or E (ignore pure Z hops)
  if (/^G0?1\b/i.test(s)) {
    const hasXorY = /[XY]/i.test(s);
    const hasE    = /\bE[-+]?\d/i.test(s);
    const hasOnlyZ= /Z[-+]?\d/i.test(s) && !hasXorY && !hasE;
    return (hasE || hasXorY) && !hasOnlyZ;
  }
  return false;
}

function formatETA(seconds) {
  if (!isFinite(seconds) || seconds <= 0) return '0s';
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  if (m > 59) {
    const h = Math.floor(m / 60);
    const mm = m % 60;
    return `${h}h ${mm}m`;
  }
  return m > 0 ? `${m}m ${s}s` : `${s}s`;
}

function showEtaPill(text, cls = 'warn') {
  if (!etaPill) return;
  etaPill.textContent = text;
  etaPill.className = 'pill ' + cls;
  etaPill.style.display = 'inline-flex';
}

function hideEtaPill() {
  if (!etaPill) return;
  etaPill.style.display = 'none';
}

//PID Prefs
function getPidCycles(tool) {
  const key = `pidCycles:${tool}`;            // tool = 'hotend' | 'bed'
  const saved = parseInt(localStorage.getItem(key) || '', 10);
  return Number.isFinite(saved) && saved >= 1 && saved <= 20 ? saved : 5; // default 5
}

function pidUiReset(kind) {
  const k = kind === 'bed' ? 'bed' : 'hot';
  pidEls[k].status.textContent = 'Idle';
  pidEls[k].bar.style.width = '0%';
  pidEls[k].bar.classList.remove('pulse');
  pidEls[k].info.textContent = 'T: ‚Äî / Target: ‚Äî (Œî ‚Äî)';
}

function pidUiStart(kind, targetTemp) {
  const k = kind === 'bed' ? 'bed' : 'hot';
  pidEls[k].status.textContent = `Tuning‚Ä¶ (${targetTemp}¬∞C)`;
  pidEls[k].bar.style.width = '10%';
  pidEls[k].bar.classList.add('pulse'); // animated via your .pulse keyframes
  pidEls[k].info.textContent = `T: ‚Äî / Target: ${targetTemp} (Œî ‚Äî)`;
  queueLiveDraw?.();
}

function pidUiUpdate(which, currentTemp, targetTemp) {
  const isBed = (which === 'bed');
  const idStem = isBed ? 'pidBed' : 'pidHot';

  const infoEl   = document.getElementById(idStem + 'Info');   // e.g. "T: ‚Äî / Target: ‚Äî (Œî ‚Äî)"
  const statusEl = document.getElementById(idStem + 'Status'); // optional
  const barEl    = document.getElementById(idStem + 'Bar');    // optional progress bar

  // Fallbacks if caller doesn't pass temps
  if (!Number.isFinite(currentTemp)) currentTemp = isBed ? temps?.bed : temps?.hot;
  if (!Number.isFinite(targetTemp)) {
    // prefer explicit PID target if present, else live tool target
    targetTemp = Number.isFinite(pidTargetTemp)
      ? pidTargetTemp
      : (isBed ? temps?.bedTarget : temps?.hotTarget);
  }

  // Update info line
  if (infoEl) {
    const d = (Number.isFinite(currentTemp) && Number.isFinite(targetTemp))
      ? (currentTemp - targetTemp) : null;
    infoEl.textContent =
      `T: ${_fmt1(currentTemp)} / Target: ${_fmt0(targetTemp)} ` +
      (Number.isFinite(d) ? `(Œî ${_fmt1(d)})` : `(Œî ‚Äî)`);
  }

  // Optional UI bits
  if (statusEl) statusEl.textContent = 'Tuning‚Ä¶';
  if (barEl)    barEl.classList.add('pulse'); // keep your CSS pulse

  // keep the chart overlay in sync (purple PID Target line)
  queueLiveDraw?.();
}

function pidUiFinish(which, ok, params) {
  const isBed = (which === 'bed');
  const idStem = isBed ? 'pidBed' : 'pidHot';

  const infoEl   = document.getElementById(idStem + 'Info');
  const statusEl = document.getElementById(idStem + 'Status');
  const barEl    = document.getElementById(idStem + 'Bar');

  // Status + bar
  if (statusEl) statusEl.textContent = ok ? 'Complete' : 'Failed';
  if (barEl)    barEl.classList.remove('pulse');

  // Leave the Kp/Ki/Kd RESULT ALONE. (setPidResult handles that elsewhere.)

  // Refresh the info line one last time with whatever temps/target we have
  const currentTemp = isBed ? temps?.bed : temps?.hot;
  const targetTemp  = Number.isFinite(pidTargetTemp)
    ? pidTargetTemp
    : (isBed ? temps?.bedTarget : temps?.hotTarget);

  if (infoEl) {
    const d = (Number.isFinite(currentTemp) && Number.isFinite(targetTemp))
      ? (currentTemp - targetTemp) : null;
    infoEl.textContent =
      `T: ${_fmt1(currentTemp)} / Target: ${_fmt0(targetTemp)} ` +
      (Number.isFinite(d) ? `(Œî ${_fmt1(d)})` : `(Œî ‚Äî)`);
  }

  // If you want to show the ‚Äúproposed‚Äù PID values in a small note (optional):
  // const noteEl = document.getElementById(idStem + 'Note');
  // if (noteEl && ok && params && Number.isFinite(params.Kp)) {
  //   noteEl.textContent = `Suggested: Kp ${params.Kp.toFixed(2)}, Ki ${params.Ki.toFixed(2)}, Kd ${params.Kd.toFixed(2)}`;
  // }

  // Redraw so the target line updates/clears depending on your setPidActive/cleanup sequence
  queueLiveDraw?.();
}

function fmt1(n){ return Number.isFinite(n) ? n.toFixed(1) : '‚Äî'; }
function fmt2(n){ return Number.isFinite(n) ? (+n).toFixed(2) : '‚Äî'; }

function setPidActive(tool, on = true) {
  // ---- guard: don't switch tools mid-run ----
  if (on && pidTarget && pidTarget !== tool) return;

  // ---- flags (make them mutually exclusive when turning ON) ----
  if (tool === 'hotend') {
    pidActiveHotend = !!on;
    if (on) pidActiveBed = false;
  } else if (tool === 'bed') {
    pidActiveBed = !!on;
    if (on) pidActiveHotend = false;
  }
  pidTarget = on ? tool : null;

  // ---- refresh top pills (existing) ----
  setTempPill?.(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
  setTempPill?.(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget,  'bed');

  // ---- NEW: toggle opposite PID button ----
  try {
    const bedBtn = document.getElementById('bedPidBtn');
    const hotBtn = document.getElementById('hotendPidBtn');

    if (bedBtn) {
      // disable Bed button when HOTEND is running; otherwise enable
      bedBtn.disabled = !!pidActiveHotend;
      bedBtn.setAttribute('aria-disabled', bedBtn.disabled ? 'true' : 'false');
    }
    if (hotBtn) {
      // disable Hotend button when BED is running; otherwise enable
      hotBtn.disabled = !!pidActiveBed;
      hotBtn.setAttribute('aria-disabled', hotBtn.disabled ? 'true' : 'false');
    }
  } catch {}

  // ---- existing cleanup when turning OFF ----
  if (!on) {
    if (tool === 'hotend' && typeof pidUiReset === 'function') pidUiReset('hotend');
    if (tool === 'bed'    && typeof pidUiReset === 'function') pidUiReset('bed');
    if (typeof pidTargetTemp !== 'undefined') pidTargetTemp = null;
  }

  // make sure the chart overlays re-render (PID target line)
  if (typeof queueLiveDraw === 'function') queueLiveDraw();
}



function clearAllPidUi() {
  // ---- core flags ----
  pidActiveHotend = false;
  pidActiveBed    = false;
  pidTarget       = null;         // ensure any ‚Äútuning‚Äù state is cleared
  if (typeof pidTargetTemp !== 'undefined') pidTargetTemp = null;

  // ---- top pills (your original behavior) ----
  try {
    topHotendPill?.classList.remove('warn', 'pulse');
    topBedPill?.classList.remove('warn', 'pulse');
    setTempPill?.(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
    setTempPill?.(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget,  'bed');
  } catch (_) {}

  // ---- PID progress UI (new bits; safe if not present) ----
  // Hotend
  if (pidEls?.hot) {
    pidEls.hot.status && (pidEls.hot.status.textContent = 'Idle');
    if (pidEls.hot.bar) {
      pidEls.hot.bar.classList.remove('pulse');
      pidEls.hot.bar.style.width = '0%';
    }
    pidEls.hot.info && (pidEls.hot.info.textContent = 'T: ‚Äî / Target: ‚Äî (Œî ‚Äî)');
  }

  // Bed
  if (pidEls?.bed) {
    pidEls.bed.status && (pidEls.bed.status.textContent = 'Idle');
    if (pidEls.bed.bar) {
      pidEls.bed.bar.classList.remove('pulse');
      pidEls.bed.bar.style.width = '0%';
    }
    pidEls.bed.info && (pidEls.bed.info.textContent = 'T: ‚Äî / Target: ‚Äî (Œî ‚Äî)');
  }
}


function setPidCycles(tool, c) {
  const key = `pidCycles:${tool}`;
  localStorage.setItem(key, String(c));
}

function promptCycles(tool) {
  const def = getPidCycles(tool);
  const raw = safePrompt(`How many PID cycles? (1‚Äì20)`, String(def));
  if (raw === null) return null;
  const n = parseInt(raw, 10);
  if (!Number.isFinite(n) || n < 1 || n > 20) {
    alert('Invalid cycle count. Enter a whole number between 1 and 20.');
    return null;
  }
  setPidCycles(tool, n);
  return n;
}

//Temp and UI state
function tempState(current, target, tolerance = 0.5) {
  if (target == null || Number.isNaN(target)) return 'idle';
  const diff = target - current;
  if (Math.abs(diff) <= tolerance) return 'ready';
  return diff > 0 ? 'heating' : 'cooling';
}

function setTempPill(pillEl, textEl, curr, target, type /* 'hotend'|'bed' */) {
  // Text (default)
  textEl.textContent =
    (target != null && !Number.isNaN(target))
      ? `${curr.toFixed(1)}¬∞C / ${Math.round(target)}¬∞`
      : `${curr.toFixed(1)}¬∞C`;

  // Reset base classes
  pillEl.classList.remove('offline','idle','ready','heating','cooling','pulse','warn','ok','bad');

  // If PID is running, keep orange pulse
  if (pidTarget && pidTarget === type) {
    pillEl.classList.add('warn','pulse');
    return;
  }

  // ‚úÖ Ambient plateau override: target off/zero and temp has stabilised for ~5 min
  if (target == null || target <= 0) {
    const tool = (type === 'hotend') ? 'hot' : 'bed';
    const amb = _ambientPlateau(tool);
    if (amb) {
      pillEl.classList.add('ready');            // green
      pillEl.classList.remove('pulse');
      textEl.textContent = `${curr.toFixed(1)}¬∞C (ambient‚âà${amb.ambient.toFixed(1)}¬∞)`;
      return;                                   // don't fall through to 'cooling'
    }
  }

  // Normal state machine
  const state = tempState(curr, target); // 'idle' | 'ready' | 'heating' | 'cooling'
  pillEl.classList.add(state);
  if ((state === 'heating' || state === 'cooling') && !pidTarget) {
    pillEl.classList.add('pulse');
  }
}

// Now updateTempPanel simply calls setTempPill for each
function updateTempPanel() {
  if (temps.hot != null || temps.hotTarget != null) {
setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
    hotendNow.textContent = `Current: ${temps.hot?.toFixed(1) ?? '‚Äî'}¬∞C` +
      (temps.hotTarget != null ? ` / ${Math.round(temps.hotTarget)}¬∞` : '');
  } else {
    hotendNow.textContent = 'Current: ‚Äî';
  }

  if (temps.bed != null || temps.bedTarget != null) {
    setTempPill(topBedPill, topBedText, temps.bed ?? 0, temps.bedTarget, 'bed');
    bedNow.textContent = `Current: ${temps.bed?.toFixed(1) ?? '‚Äî'}¬∞C` +
      (temps.bedTarget != null ? ` / ${Math.round(temps.bedTarget)}¬∞` : '');
  } else {
    bedNow.textContent = 'Current: ‚Äî';
  }
}

function setOfflinePills() {
  topHotendText.textContent = '--¬∞C';
  topBedText.textContent    = '--¬∞C';
  topHotendPill.className   = 'pill offline';
  topBedPill.className      = 'pill offline';
  hotendNow.textContent     = 'Current: ‚Äî';
  bedNow.textContent        = 'Current: ‚Äî';
}


//Axis UI
function updateAxisPanel(x, y, z) {
  posXEl.textContent = x.toFixed(3);
  posYEl.textContent = y.toFixed(3);
  posZEl.textContent = z.toFixed(3);
}


//Logging and Format
function normalizeLine(s){
  s = s.replace(/\x1b\[[0-9;]*m/g, '').replace(/[\u0000-\u001F\u007F]/g, '');
  s = s.replace(/\bcontinueing\b/gi, 'continuing');
  return s;
}

function isNoisyLine(s){ return NOISY_REGEX.test(s); }

function isSetNewScreenLine(s){ return /^setnewscreen\b/i.test(s); }

function trace(msg) { console.debug('[TRACE]', msg); }

function _logBase(msg) {
  if (!msg.endsWith('\n')) msg += '\n';
  printerLog.textContent += msg;
  printerLog.scrollTop = printerLog.scrollHeight;
}

function logMsg(msg, kind = 'info') {
  const el = window.logBox || document.getElementById('logBox');
  if (el) {
    // if it's a <textarea>, use .value; otherwise append textContent
    if ('value' in el) {
      el.value += (el.value ? '\n' : '') + String(msg);
      // keep scrolled to bottom
      el.scrollTop = el.scrollHeight;
    } else {
      el.textContent += (el.textContent ? '\n' : '') + String(msg);
    }
  } else {
    // fallback to console so we still see output
    (kind === 'bad' ? console.error : console.log)(msg);
  }
}

//Header and UI
function setActivity(text, cls='') {
  activityBadge.textContent = text;
  activityBadge.className = 'pill ' + cls;
}

function setConnected(connected) {
    if (connectBtn) connectBtn.disabled = connected;
  if (disconnectBtn) disconnectBtn.disabled = !connected;
  if (connected) {
    connBadge.textContent = 'Connected';
    connBadge.className = 'pill ok';

    topHotendPill.classList.remove('offline');
    topBedPill.classList.remove('offline');
    topHotendPill.classList.add('idle');
    topBedPill.classList.add('idle');
    updateTempPanel();
    // reset live net meter on fresh connect
    net.txBytesTotal = net.rxBytesTotal = 0;
    net.txSince = net.rxSince = 0;
    net.txRate = net.rxRate = 0;
    net.latencyEMA = null;
    updateNetUi();
    startTempPolling();
 startNetMeter();   
    hideEtaPill();
  } else {
    connBadge.textContent = 'Disconnected';
    connBadge.className = 'pill bad';
    stopTempPolling();
 stopNetMeter();   
    setOfflinePills();
    if (live) { live.buf.length = 0; live.lastProg = null; queueLiveDraw(); }
  }

  connectBtn.disabled    = connected;
  disconnectBtn.disabled = !connected;
  readMeshBtn.disabled   = !connected;
  sendCmdBtn.disabled    = !connected;
  bedPidBtn.disabled     = !connected;
  hotendPidBtn.disabled  = !connected;
  clearLogBtn.disabled   = !connected;

  hotendApply.disabled = !connected;
  hotendOff.disabled   = !connected;
  bedApply.disabled    = !connected;
  bedOff.disabled      = !connected;
  fanApply.disabled    = !connected;
  fanOff.disabled      = !connected;

  homeAll.disabled      = !connected;
  disableMotors.disabled= !connected;
  xMinus.disabled = xPlus.disabled =
  yMinus.disabled = yPlus.disabled =
  zMinus.disabled = zPlus.disabled = !connected;
  parkHead.disabled     = !connected;

  preheatPLA.disabled = preheatPETG.disabled =
  preheatABS.disabled = cooldown.disabled =
  loadFil.disabled = unloadFil.disabled = !connected;
primeLine.disabled = !connected;

  sendGcode.disabled   = !connected || !gcodeFile.files.length;
  cancelSend.disabled  = true;
}

function updateLastUpdated(){
  lastUpdated.textContent = 'Last updated: ' + new Date().toLocaleTimeString();
  updateTempPanel();
}

function setLastCmd(cmd){ lastCmd.textContent = 'Last Cmd: ' + cmd; }

//Polling
function startTempPolling(periodMs) {
  const ms = Number.isFinite(periodMs) ? periodMs : (window.debugMode ? 3000 : 7000);
  if (window.tempTimer) return;
  window.tempTimer = setInterval(() => { try { sendCmd('M105', true); } catch {} }, Math.max(750, ms));
}

function stopTempPolling() {
  if (window.tempTimer) { clearInterval(window.tempTimer); window.tempTimer = null; }
}

//Printer Name
function loadPrinterName() {
  const saved = localStorage.getItem('printerName');
  printerNameEl.textContent = saved || 'PRINTER';
}

function savePrinterName(name) {
  const cleanName = name.trim() || 'PRINTER';
  printerNameEl.textContent = cleanName;
  localStorage.setItem('printerName', cleanName);
}

function initPrinterName() {
  loadPrinterName();
  printerNameEl.addEventListener('click', () => {
    const currentName = printerNameEl.textContent.trim();
    const newName = safePrompt('Enter your printer name:', currentName);
    if (newName !== null) {
      savePrinterName(newName);
    }
  });
}

//Prompts
function safePrompt(message, def = '') {
  if (typeof window !== 'undefined' && typeof window.prompt === 'function') {
    return window.prompt(message, String(def));
  }
  console.warn('[prompt] not available; using default value.');
  return String(def);
}

function safeConfirm(message) {
  if (typeof window !== 'undefined' && typeof window.confirm === 'function') {
    return window.confirm(message);
  }
  console.warn('[confirm] not available; defaulting to false.');
  return false;
}

//Firmware screen exit
function exitPrintScreen(delayMs = 0, { tellHost = false } = {}) {
  const run = async () => {
    try {
      logMsg('‚åõ Tidying up LCD/host state‚Ä¶');
      const cmds = [
        'M400',                   // let moves/ISRs drain
        ...(tellHost ? ['M118 A1 action:cancel'] : []), // host-action for OctoPrint/etc.
        'M524',                   // abort SD print (harmless if none)
        'M117 Ready'              // friendly status on many LCDs
      ];
      await sendCmdsSequential(...cmds);
    } catch (e) {
      // non-fatal
      console.warn('exitPrintScreen failed:', e);
    }
  };

  if (delayMs > 0) setTimeout(() => { run(); }, delayMs);
  else run();
}

//Misc
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function sendCmdsSequential(...cmds) {
  for (const c of cmds) {
    // Skip empty or whitespace-only commands
    if (!c || !c.trim()) continue;

    try {
      await sendCmd(c.trim());       // send the command
      await waitForOk();             // wait for ack from printer
    } catch (err) {
      console.error(`Error sending command "${c}":`, err);
      break; // stop sending further commands if one fails
    }
  }
}


//Easter EGG
  const resetStreak = () => { streak = 0; };

  const openEasterEgg = () => {
    eeBody.textContent = [
      "This was a triumph,",
      "I‚Äôm making a note here: ‚ÄúBUILD SUCCESS.‚Äù",
      "It‚Äôs hard to overstate my satisfaction.",
      "Perfect adhesion,",
      "With just a touch of calibration. üéµ",
      "",
      "But there‚Äôs no sense whining when the layer‚Äôs too thin,",
      "You just tweak the Z-offset and then try it again.",
      "When the G-code‚Äôs complete,",
      "And the model‚Äôs elite,",
      "For the projects that are‚Ä¶",
      "Still printing. üéµ",
      "",
      "I‚Äôm not even angry,",
      "I‚Äôm being so sincere right now,",
      "Even though the extruder jammed and delayed my grand plans",
      "But I tuned the retraction",
      "And got a smooth reaction,",
      "",
      "Now the hours are flying, but I‚Äôm still having fun,",
      "Got a ten-hour Benchy and it‚Äôs only on run one.",
      "There‚Äôs a cat on the bed,",
      "And I‚Äôm filled with dread,",
      "For the projects that are‚Ä¶",
      "Still printing. üéµ",
      "",
      "Anyway, this print is great, it‚Äôs so dimensionally sweet,",
      "Look at me still sanding when there‚Äôs more stuff to complete.",
      "I‚Äôve got spools in a row,",
      "And they‚Äôre ready to go,",
      "For the models that are‚Ä¶",
      "Still printing. üéµ"
    ].join('\n');

    eeOverlay.style.display = 'block';
    eeModal.style.display = 'grid';
    eeClose.focus();
  };

  const closeEasterEgg = () => {
    eeModal.style.display = 'none';
    eeOverlay.style.display = 'none';
  };

/* =========================================================
   6) MESH UTILS (parse, store, render)
========================================================= */

//Flow Helpers

function collectMeshFromInputs() {
  const mesh = [];
  for (let y = 0; y < 4; y++) {
    const row = [];
    for (let x = 0; x < 4; x++) {
      const el = document.getElementById(`cell-${y}-${x}`);
      const v = el ? parseFloat(el.value) : NaN;
      row.push(Number.isFinite(v) ? v : null);
    }
    mesh.push(row);
  }
  const complete = mesh.every(r => r.every(v => typeof v === 'number' && !Number.isNaN(v)));
  return complete ? mesh : null;
}

function processMeshLineFromAnywhere(line) {
  const completed = ingestMeshLine(line);
  if (completed) {
    const meshForUi = meshScratch.map(r => r.slice()); // already Y-flipped
    setActivity('Mesh parsed', 'ok');
    saveMeshLS(meshForUi);
    renderMeshInputs(meshForUi);
    renderSuggestions(meshForUi);
    updateLastUpdated();
    resetMeshScratch();
  }
}

async function homeAndProbe() {
  try {
    setActivity('Homing‚Ä¶', 'warn');
    await sendCmd('G28'); await waitForOk();

    // set up latch that will resolve when printer says it's done
    probeLatch = {};
    probeLatch.promise = new Promise((resolve, reject) => {
      probeLatch.resolve = resolve;
      probeLatch.reject  = reject;
    });

    setActivity('Probing‚Ä¶', 'warn');
    await sendCmd('G29 T');            // don't await waitForOk here
    await probeLatch.promise;          // wait for "Settings Stored" / grid header

    await coolToIdle();
    setActivity('Parsing‚Ä¶', 'warn');
  } catch (e) {
    setActivity('Home & probe failed', 'bad');
    logMsg('‚ö†Ô∏è Home & probe error: ' + (e?.message || e));
  }
}

function updateLevelView() {
  const choice = (levelPrinterSelect?.value || 'cr6se');
  const isCR6  = choice === 'cr6se';
  const isConnectedNow = (connKind === 'virtual') || !!writer;

  if (cr6seLevelWrap) cr6seLevelWrap.style.display = isCR6 ? '' : 'none';
  if (unsupportedMsg) unsupportedMsg.style.display = isCR6 ? 'none' : '';

  // Home & Probe button
  if (readMeshBtn) {
    readMeshBtn.style.display = isCR6 ? '' : 'none';
    readMeshBtn.disabled = !isCR6 || !isConnectedNow;
  }

  // Export Mesh button (hide when not CR-6)
  if (exportMeshBtn) {
    exportMeshBtn.style.display = isCR6 ? '' : 'none';
    // optional: only enable if we actually have a mesh to export
    const hasInputs = typeof collectMeshFromInputs === 'function' && !!collectMeshFromInputs();
    const latest = (() => {
      try { return JSON.parse(localStorage.getItem('levels') || '[]').at(-1); } catch { return null; }
    })();
    const hasSaved = Array.isArray(latest) && latest.length === 4;
    exportMeshBtn.disabled = !(hasInputs || hasSaved);
  }
}


//Scratch mgmt.
function meshIsComplete(m = meshScratch) {
  return m.every(row => row.every(v => typeof v === 'number' && !Number.isNaN(v)));
}

function resetMeshScratch() {
  meshScratch = Array.from({ length: 4 }, () => Array(4).fill(null));
}

//Parsing
function ingestMeshLine(line) {
  const s = line.trim();

  // Row-based: "y  v0 v1 v2 v3"
  const row = s.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
  if (row) {
    const fwY = parseInt(row[1], 10);
    const uiY = 3 - fwY; // flip Y for UI
    meshScratch[uiY][0] = parseFloat(row[2]);
    meshScratch[uiY][1] = parseFloat(row[3]);
    meshScratch[uiY][2] = parseFloat(row[4]);
    meshScratch[uiY][3] = parseFloat(row[5]);
    return meshIsComplete();
  }

  // Point formats: "X0 Y1 Z-0.0945", "X: 0; Y: 1 ... Z..."
  const pXY = s.match(/X\s*:?\s*(\d)\s*[,; ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i)
            || s.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
  if (pXY) {
    const x   = parseInt(pXY[1], 10);
    const fwY = parseInt(pXY[2], 10);
    const uiY = 3 - fwY;
    const val = parseFloat(pXY[3]);
    if (x < 4 && fwY < 4 && Number.isFinite(val)) {
      meshScratch[uiY][x] = val;
      return meshIsComplete();
    }
  }

  return false;
}

function tryParseMeshFromLines(lines) {
  const mesh = Array.from({ length: 4 }, () => Array(4).fill(null));

  for (const raw of lines) {
    const line = raw.trim();

    // Row-based
    const m = line.match(/^([0-3])\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
    if (m) {
      const fwY = parseInt(m[1], 10);
      const uiY = 3 - fwY;
      const vals = [parseFloat(m[2]), parseFloat(m[3]), parseFloat(m[4]), parseFloat(m[5])];
      mesh[uiY] = vals;
      continue;
    }

    // Point-by-point
    const p1 = line.match(/[\(\[](\d)\s*,\s*(\d)[\)\]]\s+([+-]?\d*\.?\d+)/);
    const p2 = line.match(/X\s*:?\s*(\d)\s*;?\s*[, ]\s*Y\s*:?\s*(\d).*?\bZ\s*([+-]?\d*\.?\d+)/i);
    const p3 = line.match(/X\s*(\d)\s*Y\s*(\d)\s*Z\s*([+-]?\d*\.?\d+)/i);
    const mP = p1 || p2 || p3;
    if (mP) {
      const x   = parseInt(mP[1], 10);
      const fwY = parseInt(mP[2], 10);
      const uiY = 3 - fwY;
      const val = parseFloat(mP[3]);
      if (x < 4 && fwY < 4) mesh[uiY][x] = val;
    }
  }

  const complete = mesh.every(row => row.every(v => typeof v === 'number' && !isNaN(v)));
  return complete ? mesh : null;
}

//Persistence
function loadMeshLS() {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  return hist.at(-1) || Array.from({length:4},()=>Array(4).fill(''));
}

function saveMeshLS(mesh) {
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  hist.push(mesh);
  while (hist.length > 10) hist.shift();  // keep last 10
  localStorage.setItem('levels', JSON.stringify(hist));
  // Remember when the latest mesh was saved
  localStorage.setItem('levelsLastAt', String(Date.now()));
}


//Presentation
function getScrewData(mesh) {
  const result = {};
  for (const screw in screwAffects) {
    const points = screwAffects[screw];
    const values = points
      .map(([y,x]) => mesh?.[y]?.[x])
      .filter(v => typeof v === 'number' && !isNaN(v));
    const avg = values.length ? values.reduce((a,b)=>a+b,0)/values.length : null;

    let suggestion='N/A', turn='N/A';
    if (avg !== null) {
      if (avg >  0.07)      { suggestion='Tighten (Clockwise)';           turn='Strong (1/4 turn)'; }
      else if (avg > 0.04)  { suggestion='Tighten (Clockwise)';           turn='Moderate (1/8 turn)'; }
      else if (avg > 0.02)  { suggestion='Tighten (Clockwise)';           turn='Slight (1/16 turn)'; }
      else if (avg < -0.07) { suggestion='Loosen (Counterclockwise)';     turn='Strong (1/4 turn)'; }
      else if (avg < -0.04) { suggestion='Loosen (Counterclockwise)';     turn='Moderate (1/8 turn)'; }
      else if (avg < -0.02) { suggestion='Loosen (Counterclockwise)';     turn='Slight (1/16 turn)'; }
      else { suggestion='No change'; }
    }
    result[screw] = { avg: avg?.toFixed(3) ?? 'N/A', suggestion, turn };
  }
  return result;
}

function renderMeshInputs(mesh) {
  meshInput.innerHTML = '';
  for (let y=0; y<4; y++) {
    const tr = document.createElement('tr');
    for (let x=0; x<4; x++) {
      const v = mesh?.[y]?.[x];
      tr.innerHTML += `<td><input type="number" step="0.001" id="cell-${y}-${x}" value="${typeof v==='number'? v.toFixed(3): ''}" required></td>`;
    }
    meshInput.appendChild(tr);
  }
}

function renderSuggestions(mesh) {
  const data = getScrewData(mesh);
  screwTable.innerHTML = '';
  const layout = ['A1','GAP','A2','A3','B1','B2','B3','B4','C1','C2','C3','C4'];
  for (const sName of layout) {
    if (sName === 'GAP') continue;
    const s = data[sName];
    const tr = document.createElement('tr');
    tr.className = s.suggestion.includes('Tighten') ? 'tighten'
               :  s.suggestion.includes('Loosen')  ? 'loosen'
               :  'na';
    tr.innerHTML = `<td>${sName}</td><td>${s.avg}</td><td>${s.suggestion}</td><td>${s.turn}</td>`;
    screwTable.appendChild(tr);
    const cell = document.getElementById(sName);
    if (cell) {
      cell.className = tr.className;
      cell.innerHTML = `<strong>${sName}</strong><br>${s.avg} mm<br>${s.turn!=='N/A'? s.turn : ''}`;
    }
  }
}

//Export and Numeric
function exportMeshAsFile(mesh, label) {
  const blob = new Blob([JSON.stringify(mesh, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `cr6se-mesh-${label}-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

function promptNumber(message, def) {
  const raw = safePrompt(message, String(def));
  if (raw === null) return null;
  const n = parseFloat(raw);
  return Number.isFinite(n) ? n : NaN;
}

/* =========================================================
   7) SERIAL / COMMS (connect, read loop, send, waits)
========================================================= */

async function requestPortSafe() {
  if (isVirtual()) throw new Error('virtual-mode'); // never open picker in virtual
  return await navigator.serial.requestPort();
}

//Real Connection
//Real Connection
async function connectPrinter() {
  if (isConnecting) return;
  isConnecting = true;

  try {
    // Virtual path
if (virtualMode) {
  await connectVirtual();
  connKind = 'virtual';
  return;
}
    // Real serial path
    if (!('serial' in navigator)) {
      setConnected(false);
      setActivity('Web Serial not supported', 'bad');
      logMsg('‚ùå Web Serial API not supported. Use Chrome/Edge/Brave on desktop.');
      alert('Web Serial API not supported. Use Chrome/Edge/Brave on desktop.');
      connKind = 'none';
      return;
    }

    setActivity('Connecting...', 'warn');

    if (!port) {
      const granted = await navigator.serial.getPorts();
      port = granted[0] || await requestPortSafe();
    }

    const sel = baudSelection();
    let connectedAt = null;

    if (sel.mode === 'manual') {
      // Open immediately at the selected baud (no handshake gating)
      const b = sel.list[0];
      await openAtBaud(b);
      connectedAt = b;
    } else {
      // Auto-detect: probe each candidate with a longer timeout
      for (const b of sel.list) {
        setActivity(`Trying ${b}‚Ä¶`, 'warn');
        const res = await probeAtBaud(b, 5000);
        if (res.success) { connectedAt = res.baud; break; }
        await sleep(180); // brief pause before the next try
      }
    }

    if (!connectedAt) {
      setConnected(false);
      setActivity('Connect error', 'bad');
      logMsg('‚ùå No response at tried baud rates. Try selecting 115200 manually or another cable/port.');
      connKind = 'none';
      return;
    }

    // We're open with reader/writer from openAtBaud()/probeAtBaud()
    setConnected(true);
    cancelStream = false; // ‚Üê clear leftover cancel flag from a previous send
    sendCmd('M105', true); // prime a latency sample
    updateLevelView();
    hideEtaPill();
    updateTempPanel();
    startTempPolling();
    updateLastUpdated();
    setActivity(`Connected @ ${connectedAt}`, 'ok');
    logMsg(`Connected at ${connectedAt} baud.`);
    if (!reading) readLoop();

    connKind = 'real';
  } catch (err) {
    setConnected(false);
    setActivity('Connect error', 'bad');
    logMsg(String(err?.message || err));
    _rejectAllOk(new Error('Connect failed'));
    hideEtaPill();
    connKind = 'none';
  } finally {
    isConnecting = false;
  }
}

async function disconnectPrinter(reason = 'user') {
  if (isDisconnecting) return;
  isDisconnecting = true;

  const lost = reason === 'lost';
  try {
    // Fail any pending waits / streams immediately
    _rejectAllOk(new Error(lost ? 'Connection lost' : 'Disconnected'));
    if (probeLatch) {
      try { probeLatch.reject(new Error(lost ? 'lost' : 'disconnected')); }
      finally { probeLatch = null; }
    }

    // Put sender into a cancelled/abort state during teardown
    cancelStream = true;

    // Reset sender UI + ETA
    if (sendProgress) sendProgress.style.width = '0%';
    if (sendStatus)   sendStatus.textContent = 'Idle';
    hideEtaPill();
    clearAllPidUi();

    // Virtual path
    if (connKind === 'virtual' || virtualMode) {
      await disconnectVirtual();  // handles setConnected(false)
      connKind = 'none';
      stopTempPolling();
      setActivity(lost ? 'Connection lost (virtual)' : 'Disconnected', lost ? 'bad' : 'ok');
      if (lost) logMsg('‚ùå Connection lost (virtual).'); else logMsg('üîå Virtual printer disconnected.');
      return; // finally{} will still run
    }

    // Real serial path
    setConnected(false); // also stops temp polling + net meter + sets offline pills
    setActivity(lost ? 'Connection lost‚Ä¶' : 'Disconnecting‚Ä¶', lost ? 'bad' : 'warn');
    stopTempPolling();

    try { if (reader) await reader.cancel(); } catch {}
    try { if (reader) reader.releaseLock(); } catch {}
    try { if (writer) writer.releaseLock(); } catch {}
    try { if (port)   await port.close();   } catch {}

    port = null;
    reader = null;
    writer = null;

    if (postPrintTimer) { clearTimeout(postPrintTimer); postPrintTimer = null; }

    setActivity(lost ? 'Connection lost' : 'Disconnected', lost ? 'bad' : 'ok');
    logMsg(lost ? '‚ùå Connection to printer was lost.' : 'üîå Disconnected.');
    connKind = 'none';
  } catch (err) {
    logMsg('‚ùå Disconnect error: ' + (err?.message || err));
    setActivity('Disconnect error', 'bad');
    connKind = 'none';
  } finally {
    // IMPORTANT: don‚Äôt let a previous cancel poison future one-shot macros
    cancelStream = false;      // ‚Üê reset the sticky flag
    isDisconnecting = false;
  }
}

const VIRT_REPLIES = {
  M115: [
    'FIRMWARE_NAME:Marlin 2.1.2.1 (Github)',
    'FIRMWARE_URL:https://github.com/MarlinFirmware/Marlin',
    'PROTOCOL_VERSION:1.0',
    'MACHINE_TYPE:Ender-3 Pro',
    'EXTRUDER_COUNT:1',
    'UUID:00000000-0000-0000-0000-000000000000',
    'ok'
  ].join('\n'),

  M503: [
    'echo:  Steps per unit: M92 X80.00 Y80.00 Z400.00 E93.00',
    'echo:  Maximum feedrates: M203 X500.00 Y500.00 Z12.00 E25.00',
    'echo:  Acceleration: M201 X1000.00 Y1000.00 Z100.00 E5000.00',
    'echo:  Advanced: M205 X10.00 Y10.00 Z0.30 E5.00 J0.10',
    'ok'
  ].join('\n')
};

//Virtual Connection
async function connectVirtual() {
  if (connKind === 'virtual') { logMsg('üß™ Already in virtual mode.'); return; }
  setConnected(true);
updateLevelView();
  setActivity('Connected (virtual)', 'ok');
  logMsg('üß™ Virtual printer connected.');
  startVirtualSim();
  startTempPolling();
  updateLastUpdated();
}

async function disconnectVirtual() {
  if (connKind !== 'virtual') { logMsg('üß™ Virtual not active.'); }
  stopVirtualSim();
  setConnected(false);
  setActivity('Disconnected', 'ok');
  logMsg('üîå Virtual printer disconnected.');
}

//Virtual temps and sim
function refreshVirtualTemps() {
  // Mirror vState ‚Üí temps
  temps.hot = vState.hot;
  temps.hotTarget = vState.hotTarget;
  temps.bed = vState.bed;
  temps.bedTarget = vState.bedTarget;

  // ‚úÖ ADD THESE:
  _pushAmbientSample('hot', temps.hot ?? 0, temps.hotTarget);
  _pushAmbientSample('bed', temps.bed ?? 0, temps.bedTarget);

  // Update the pills + panel (normally done by readLoop in real mode)
  setTempPill(topHotendPill, topHotendText, temps.hot ?? 0, temps.hotTarget, 'hotend');
  setTempPill(topBedPill,    topBedText,    temps.bed ?? 0, temps.bedTarget, 'bed');
  updateTempPanel();
}

function startVirtualSim() {
  if (vSimTimer) return;
  vSimTimer = setInterval(() => {
    const stepHot = 0.6, stepBed = 0.35;
    if (Number.isFinite(vState.hotTarget)) {
      const d = vState.hotTarget - vState.hot;
      vState.hot += Math.sign(d) * Math.min(Math.abs(d), stepHot);
    }
    if (Number.isFinite(vState.bedTarget)) {
      const d = vState.bedTarget - vState.bed;
      vState.bed += Math.sign(d) * Math.min(Math.abs(d), stepBed);
    }
    // keep temps in sync and refresh UI
    refreshVirtualTemps();
    recordLiveSample();
  }, 100);
}

function stopVirtualSim() {
  if (vSimTimer) { clearInterval(vSimTimer); vSimTimer = null; }
}

// Send paths ‚Äî virtual and real separated cleanly
async function sendCmd(cmd, quiet = false) {
  const line = String(cmd).trim();
  const id = line.split(/\s+/)[0].toUpperCase(); // e.g. "M503", "M115"

  const isM503 = id === 'M503';
  const isM115 = id === 'M115';
  const isM122 = id === 'M122';

  // ---------------- VIRTUAL PATH ----------------
  if (connKind === 'virtual') {
    // canned replies by id
    const canned = VIRT_REPLIES && VIRT_REPLIES[id];
    if (!quiet) logMsg('>> ' + line);

    if (canned) {
      // stream lines into the log and return the full block
      canned.split('\n').forEach(l => logMsg(l));
      return canned; // IMPORTANT: tables/parsers rely on this
    }

    // No canned reply ‚Äî simulate a simple ok
    logMsg('ok');
    return 'ok';
  }

  // ---------------- REAL SERIAL PATH ----------------
  // Heater guardrail
  if (!guardHeaterFromCmd(line)) {
    throw new Error('Heater guardrail blocked high temperature command');
  }
  if (!writer) {
    setActivity('Not connected', 'bad');
    throw new Error('Not connected');
  }

  setLastCmd(line);
  setActivity('Sending‚Ä¶', 'warn');

  // Prepare optional capture for commands that dump multi-line blocks
  let replyPromise = null;
  if (isM503 || isM115 || isM122) {
    // ensure no stale capture is active
    if (typeof oneShotCapture !== 'undefined' && oneShotCapture) {
      try { oneShotCapture.resolve(oneShotCapture.buf?.join('\n') || ''); } catch {}
      oneShotCapture = null;
    }
    beginCritical?.();
    stopTempPolling?.();
    replyPromise = captureReplyOnce({ doneOnOk: true });
  }

  // Write to serial
  const payload = new TextEncoder().encode(line + '\n');
  lastSendTs = performance.now();

  await writer.write(payload);
  if (!quiet) logMsg('>> ' + line);

  // TX metering
  net.txBytesTotal += payload.length;
  net.txSince      += payload.length;

  updateLastUpdated();
  setActivity('Waiting‚Ä¶', 'warn');

  // If we started a capture, return it; make sure we endCritical/start polling after it finishes
  if (replyPromise) {
    return replyPromise.finally(() => {
      try { startTempPolling?.(); } catch {}
      endCritical?.();
    });
  }

  // Commands that don't produce a block reply just return empty string
  return '';
}

function updateTempsUI({ hotend, hotendSet, bed, bedSet }) {
  // Example spans ‚Äì change selectors to your IDs/classes
  const elH = document.getElementById('tempHotend');
  const elHS = document.getElementById('tempHotendSet');
  const elB = document.getElementById('tempBed');
  const elBS = document.getElementById('tempBedSet');

  if (elH)  elH.textContent  = isFinite(hotend)    ? hotend.toFixed(1) : '‚Äî';
  if (elHS) elHS.textContent = isFinite(hotendSet) ? hotendSet.toFixed(0) : '‚Äî';
  if (elB)  elB.textContent  = isFinite(bed)       ? bed.toFixed(1) : '‚Äî';
  if (elBS) elBS.textContent = isFinite(bedSet)    ? bedSet.toFixed(0) : '‚Äî';

  // If you have a live chart, enqueue a point here too
  if (typeof queueLiveDraw === 'function') {
    try {
      live.lastHotend = hotend;
      live.lastHotendSet = hotendSet;
      live.lastBed = bed;
      live.lastBedSet = bedSet;
      queueLiveDraw();
    } catch {}
  }
}

async function sendCmdVirtual(cmd, quiet = false) {
  const line = String(cmd).trim();

  // Heater guardrail (blocks M104/M109 or M140/M190 over limits unless unlocked)
  if (!guardHeaterFromCmd(line)) {
    throw new Error('Heater guardrail blocked high temperature command');
  }

  setLastCmd(line);
  setActivity('Sending‚Ä¶', 'warn');
  if (!quiet) logMsg('>> ' + line);

  // Approximate TX size for virtual path (no real serial)
  const approxLen = line.length + 1; // + '\n'
  if (typeof net !== 'undefined') {
    net.txBytesTotal += approxLen;
    net.txSince      += approxLen;
  }

  // Stamp send time for latency EMA in no-waiter cases
  lastSendTs = performance.now();

  // --- Live graph taps: fan (M106/M107) + progress (M73) -------------------
  // Fan set
  if (/^M106\b/i.test(line)) {
    const m = line.match(/\bS\s*([0-9.]+)/i);
    if (m) {
      const s = Math.max(0, Math.min(255, parseInt(m[1], 10) || 0));
      if (typeof live !== 'undefined') live.lastFan255 = s;
      if (typeof queueLiveDraw === 'function') queueLiveDraw();
    }
  }
  if (/^M107\b/i.test(line)) {
    if (typeof live !== 'undefined') live.lastFan255 = 0;
    if (typeof queueLiveDraw === 'function') queueLiveDraw();
  }
  // M73 progress
  if (/^M73\b/i.test(line)) {
    const p = line.match(/\bP\s*([0-9]+)/i);
    if (p && typeof live !== 'undefined') {
      live.lastProg = Math.max(0, Math.min(100, parseInt(p[1], 10) || 0));
      if (typeof queueLiveDraw === 'function') queueLiveDraw();
    }
    const r = line.match(/\bR\s*([0-9]+)/i);
    if (r) {
      const mins = Math.max(0, parseInt(r[1], 10) || 0);
      showEtaPill('ETA: ' + formatETA(mins * 60), 'warn');
    }
  }



  // -------------------------------------------------------------------------

  const ok = () => {
    setActivity('Waiting‚Ä¶', 'warn');
    setTimeout(() => {
      // suppress visible "ok" for quiet calls and for M105 polls
      if (!quiet && !/^M105\b/i.test(line)) logMsg('ok');
      _resolveNextOk();          // updates latency EMA if a waiter is present
      updateLastUpdated();
      setActivity('Idle');
    }, 60);
  };

  const emitTelemetry = () => {
    const ht = Number.isFinite(vState.hotTarget) ? vState.hotTarget : 0;
    const bt = Number.isFinite(vState.bedTarget) ? vState.bedTarget : 0;
    const telem = `T:${vState.hot.toFixed(1)} / ${Math.round(ht)} B:${vState.bed.toFixed(1)} / ${Math.round(bt)} @:0 B@:0`;
    logMsg(telem);
    refreshVirtualTemps();
  };

  switch (true) {

      case /^M122\b/i.test(line): {
    const lines = [
      'echo:  Testing TMC drivers...',
      'echo:  X driver: TMC2209',
      'echo:  X RMS current: 800',
      'echo:  X microsteps: 16',
      'echo:  X stealthChop: enabled',
      'echo:  X spreadCycle: disabled',
      'echo:  X otpw: false',
      'echo:  X error: false',
      'echo:  Y driver: TMC2209',
      'echo:  Y RMS current: 850',
      'echo:  Y microsteps: 16',
      'echo:  Y stealthChop: enabled',
      'echo:  Y spreadCycle: disabled',
      'echo:  Y otpw: false',
      'echo:  Y error: false',
      'echo:  Z driver: TMC2209',
      'echo:  Z RMS current: 900',
      'echo:  Z microsteps: 16',
      'echo:  Z stealthChop: enabled',
      'echo:  Z spreadCycle: disabled',
      'echo:  Z otpw: false',
      'echo:  Z error: false',
      'echo:  E driver: TMC2209',
      'echo:  E RMS current: 700',
      'echo:  E microsteps: 16',
      'echo:  E stealthChop: enabled',
      'echo:  E spreadCycle: disabled',
      'echo:  E otpw: false',
      'echo:  E error: false',
      'ok'
    ];
    lines.forEach(l => logMsg(l));
    if (typeof ok === 'function') ok();
    return lines.join('\n'); // returning ends the switch branch
  }

    // --- Telemetry ---
    case /^M105\b/i.test(line): {
      emitTelemetry();
      ok();
      break;
    }

    // --- PID autotune sim ---
    case /^M303\b/i.test(line): {
      const eParam = line.match(/\bE\s*(-?\d+)/i);
      const cParam = line.match(/\bC\s*(\d+)/i);
      const tool = eParam ? (parseInt(eParam[1], 10) === -1 ? 'bed' : 'hotend') : 'hotend';
      const cycles = cParam ? Math.max(1, Math.min(20, parseInt(cParam[1], 10))) : 5;

      logMsg(`PID Autotune start (${tool}) C=${cycles}`);
      setPidActive(tool, true);
      setTimeout(() => logMsg('PID Autotune finished'), Math.round(cycles * 600));
      ok();
      break;
    }

    // --- Targets / basic controls ---
    case /^M104\b/i.test(line): {
      const s = line.match(/S\s*([0-9.]+)/i);
      vState.hotTarget = s ? parseFloat(s[1]) : null;
      refreshVirtualTemps();
      ok();
      break;
    }
    case /^M140\b/i.test(line): {
      const s = line.match(/S\s*([0-9.]+)/i);
      vState.bedTarget = s ? parseFloat(s[1]) : null;
      refreshVirtualTemps();
      ok();
      break;
    }
    case /^M106\b/i.test(line):
    case /^M107\b/i.test(line):
    case /^M400\b/i.test(line):
    case /^M82\b/i.test(line):
    case /^M83\b/i.test(line):
    case /^M500\b/i.test(line):
    case /^M84\b/i.test(line):
    case /^G90\b/i.test(line):
    case /^G91\b/i.test(line):
      ok(); break;

    // --- Homing / movement ---
    case /^G28\b/i.test(line): {
      vState.x = 0; vState.y = 0; vState.z = 0;
      logMsg('X:0.000 Y:0.000 Z:0.000');
      ok();
      break;
    }
    case /^G1\b/i.test(line): {
      const x = line.match(/X\s*([-+]?\d*\.?\d+)/i);
      const y = line.match(/Y\s*([-+]?\d*\.?\d+)/i);
      const z = line.match(/Z\s*([-+]?\d*\.?\d+)/i);
      if (x) vState.x = parseFloat(x[1]);
      if (y) vState.y = parseFloat(y[1]);
      if (z) vState.z = parseFloat(z[1]);
      logMsg(`X:${vState.x.toFixed(3)} Y:${vState.y.toFixed(3)} Z:${vState.z.toFixed(3)}`);
      ok();
      break;
    }

    // --- Mesh report (G29 T) ---
    case /^G29\b/i.test(line) && /\bT\b/i.test(line): {
      const hasMock = Array.isArray(mockMesh) && mockMesh.length > 0;
      if (hasMock) {
        for (const raw of mockMesh) {
          const l = String(raw).trim();
          if (!l || /^ok\b/i.test(l)) continue;
          logMsg(l);
          processMeshLineFromAnywhere(l);
        }
      } else {
        const rows = [
          [ -0.120, -0.080, -0.035, -0.010 ],
          [ -0.075, -0.030,  0.005,  0.020 ],
          [ -0.040,  0.000,  0.030,  0.050 ],
          [ -0.010,  0.020,  0.055,  0.070 ],
        ];
        rows.forEach((vals, y) => {
          const l = `${y}  ${vals.map(v => (v >= 0 ? `+${v.toFixed(3)}` : v.toFixed(3))).join('  ')}`;
          logMsg(l);
          processMeshLineFromAnywhere(l);
        });
      }
      ok();
      break;
    }

    // --- Info / diagnostics ---
case /^M115\b/i.test(line): {
  const lines = [
    'FIRMWARE_NAME:Marlin 2.1.2.1 (Github)',
    'FIRMWARE_URL:https://github.com/MarlinFirmware/Marlin',
    'PROTOCOL_VERSION:1.0',
    'MACHINE_TYPE:Ender-3 Pro',
    'EXTRUDER_COUNT:1',
    'UUID:00000000-0000-0000-0000-000000000000',
    'ok'
  ];
  lines.forEach(l => logMsg(l));
  if (typeof ok === 'function') ok();
  return lines.join('\n');
}
    case /^M122\b/i.test(line): {
      logMsg('Driver diag (virtual): all good.');
      ok();
      break;
    }
case /^M503\b/i.test(line): {
  const lines = [
    'echo:  Steps per unit: M92 X80.00 Y80.00 Z400.00 E93.00',
    'echo:  Maximum feedrates: M203 X500.00 Y500.00 Z12.00 E25.00',
    'echo:  Acceleration: M201 X1000.00 Y1000.00 Z100.00 E5000.00',
    'echo:  Advanced: M205 X10.00 Y10.00 Z0.30 E5.00 J0.10',
    'ok'
  ];
  lines.forEach(l => logMsg(l));
  // if your flow expects an ‚Äúok‚Äù, keep this
  if (typeof ok === 'function') ok();
  // IMPORTANT: return the text so parseM503 receives it
  return lines.join('\n');
}


    // --- UI cancel hook ---
    case /^\/\/action:cancel/i.test(line): {
      logMsg('//action:cancel (virtual ack)');
      setTimeout(() => { _resolveNextOk(); updateLastUpdated(); }, 10);
      break;
    }

    // --- Fallback ---
    default:
      ok();
  }
}


//Read and parse loop
// Read and parse loop (drop-in)
async function readLoop() {
  // ---- helpers ---------------------------------------------------
  let _processed = 0;
  const yieldToUI = async (every = 60) => {
    if ((++_processed % every) === 0) await new Promise(requestAnimationFrame);
  };

  const throttle = (fn, windowMs) => {
    let last = 0;
    return (...args) => {
      const now = performance.now();
      if (now - last >= windowMs) { last = now; fn(...args); }
    };
  };

  const updateTempsThrottled = throttle(() => {
    updateTempPanel?.();
    if (pidActiveHotend) pidUiUpdate?.('hotend', temps.hot, pidTargetTemp ?? temps.hotTarget ?? null);
    if (pidActiveBed)    pidUiUpdate?.('bed',    temps.bed,  pidTargetTemp ?? temps.bedTarget  ?? null);
  }, 250);

  const logTempsThrottled = throttle(() => {
    const hotStr = (temps.hot != null)
      ? `${temps.hot.toFixed(1)}${Number.isFinite(temps.hotTarget) ? ' / ' + Math.round(temps.hotTarget) : ''}`
      : '--';
    const bedStr = (temps.bed != null)
      ? `${temps.bed.toFixed(1)}${Number.isFinite(temps.bedTarget) ? ' / ' + Math.round(temps.bedTarget) : ''}`
      : '--';
    logMsg?.(`üå° Hotend ${hotStr} ¬∑ Bed ${bedStr}`);
  }, 500);
  // ---------------------------------------------------------------

  // Regex used below
  const M73_RE   = /\bM73\b(?:\s+P\s*([0-9]+))?(?:\s+R\s*([0-9]+))?/i;
  const FAN_M106 = /\bM106\b[^S]*S\s*([0-9]{1,3})\b/i;
  const FAN_AT   = /@:\s*([0-9]{1,3})\b/;

  // PID constants (both styles)
  const PID_K_LINE = /\bKp:\s*([0-9.+\-eE]+)\s*Ki:\s*([0-9.+\-eE]+)\s*Kd:\s*([0-9.+\-eE]+)/;
  const DEF_KP     = /#define\s+DEFAULT_(bed)?Kp\s+([0-9.+\-eE]+)/i;
  const DEF_KI     = /#define\s+DEFAULT_(bed)?Ki\s+([0-9.+\-eE]+)/i;
  const DEF_KD     = /#define\s+DEFAULT_(bed)?Kd\s+([0-9.+\-eE]+)/i;

  // PID debug meta (tolerant token pick-up)
  const RE_RULE  = /(Classic PID|No overshoot|Some overshoot|Pessen|Tyreus[-\s]?Luyben|Ziegler[-\s]?Nichols)/i;
  const RE_BIAS  = /\bbias\s*:\s*([0-9.+\-eE]+)/i;
  const RE_D     = /\bd\s*:\s*([0-9.+\-eE]+)/i;
  const RE_MIN   = /\bmin\s*:\s*([0-9.+\-eE]+)/i;
  const RE_MAX   = /\bmax\s*:\s*([0-9.+\-eE]+)/i;
  const RE_KU    = /\bKu\s*:\s*([0-9.+\-eE]+)/i;
  const RE_TU    = /\bTu\s*:\s*([0-9.+\-eE]+)/i;

  // --- PID capture latch (across 'finished' + subsequent lines)
  const pidCap = { kind: null, pending: false, committed: false, kp: null, ki: null, kd: null, meta: {} };
  const pidCommitIfReady = () => {
    if (!pidCap.pending || pidCap.committed) return;
    const { kind, kp, ki, kd } = pidCap;
    if ((kind === 'bed' || kind === 'hotend')
        && Number.isFinite(kp) && Number.isFinite(ki) && Number.isFinite(kd)) {
      // Finish UI with real numbers
      pidUiFinish?.(kind, true, { Kp: kp, Ki: ki, Kd: kd });
      // Clear "active" now that we have numbers
      setPidActive?.(kind, false);
      // Write: NEW -> <div>, PREV -> <p> (prev persists only)
      setPidResult?.(kind, kp, ki, kd);
      // Optional: surface parsed meta (bias/Ku/Tu/rule, etc.)
      pidDebugMeta?.(kind, { ...pidCap.meta });

      // Close latch
      pidCap.committed = true;
      pidCap.pending = false;
      pidCap.kind = null;
      try { pidTargetTemp = null; } catch {}
    }
  };

  reading = true;
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) { if (!isDisconnecting) await disconnectPrinter('lost'); break; }
      if (value == null) continue;

      // RX metering
      const len = (value instanceof Uint8Array) ? value.length
                : (typeof value === 'string' ? value.length : 0);
      if (len) { net.rxBytesTotal += len; net.rxSince += len; }

      // Normalize chunk
      const chunk = (value instanceof Uint8Array)
        ? textDecoder.decode(value, { stream: true })
        : value;

      rxBuffer += chunk;
      const parts = rxBuffer.split(/\r?\n/);
      rxBuffer = parts.pop(); // keep incomplete tail

      for (const raw of parts) {
        const line = raw.trim();
        if (!line) { await yieldToUI(); continue; }

        // ===== TEMPERATURES (M105-style) =====
        const tMatch = !captureMode && TEMP_T?.test ? line.match(TEMP_T) : null;
        const bMatch = !captureMode && TEMP_B?.test ? line.match(TEMP_B) : null;

        if (tMatch) {
          const tCur = parseFloat(tMatch[1]);
          const tTar = tMatch[2] !== undefined ? parseFloat(tMatch[2]) : null;
          if (Number.isFinite(tCur)) {
            temps.hot = tCur;
            temps.hotTarget = Number.isFinite(tTar) ? tTar : null;
            _pushAmbientSample?.('hot', temps.hot ?? 0, temps.hotTarget);
            setTempPill?.(topHotendPill, topHotendText, temps.hot, temps.hotTarget, 'hotend');
          }
        }
        if (bMatch) {
          const bCur = parseFloat(bMatch[1]);
          const bTar = bMatch[2] !== undefined ? parseFloat(bMatch[2]) : null;
          if (Number.isFinite(bCur)) {
            temps.bed = bCur;
            temps.bedTarget = Number.isFinite(bTar) ? bTar : null;
            _pushAmbientSample?.('bed', temps.bed ?? 0, temps.bedTarget);
            setTempPill?.(topBedPill, topBedText, temps.bed, temps.bedTarget, 'bed');
          }
        }
        if (tMatch || bMatch) {
          updateTempsThrottled();
          recordLiveSample?.();
        }

        // ===== LIVE Z TRACKING =====
        if (!captureMode) {
          const zMatch = line.match(/\bZ\s*[:=]\s*(-?\d+(?:\.\d+)?)/i);
          if (zMatch) {
            const z = parseFloat(zMatch[1]);
            if (Number.isFinite(z)) window.GCodePreview?.updateCurrentZ?.(z);
          }
        }

        // ===== CAPTURE / LOGGING PREP =====
        const out = (typeof normalizeLine === 'function') ? normalizeLine(line) : line;

        // M73 progress
        const m73 = out.match(M73_RE);
        if (m73 && m73[1] != null) {
          const p = Math.max(0, Math.min(100, parseInt(m73[1], 10)));
          if (live) live.lastProg = p;
        }

        // Fan PWM (prefer "@:"; fallback to M106 echoes)
        const fmAt = out.match(FAN_AT);
        if (fmAt) {
          const s = parseInt(fmAt[1], 10);
          if (Number.isFinite(s)) live && (live.lastFan255 = Math.max(0, Math.min(255, s)));
        } else {
          const fm = out.match(FAN_M106);
          if (fm) {
            const s = parseInt(fm[1], 10);
            if (Number.isFinite(s)) live && (live.lastFan255 = Math.max(0, Math.min(255, s)));
          }
        }

        // Telemetry flag for logging
        const looksTelemetry = !!(tMatch || bMatch || /^T:|^B:/i.test(line) || /^T:|^B:/i.test(out));

        // Capture non-ok lines
        if (oneShotCapture && out && !/^ok\b/i.test(out)) oneShotCapture.buf.push(out);

        // Homing-ish hints
        maybeMarkHomingHint?.(out);

        // Noisy filters
        const noisy = (typeof isSetNewScreenLine === 'function' && isSetNewScreenLine(out)) ||
                      (typeof isNoisyLine        === 'function' && isNoisyLine(out));

        // Final logging rules
        if (!window.debugMode) {
          if (!looksTelemetry && !noisy) logMsg?.(out);
        } else {
          if (looksTelemetry) logTempsThrottled();
          else                logMsg?.(out);
        }

        // ===== MESH INGESTION =====
        const meshCompleted = ingestMeshLine?.(out);
        if (meshCompleted) {
          const meshForUi = meshScratch.map(r => r.slice()); // already Y-flipped
          setActivity?.('Mesh parsed', 'ok');
          saveMeshLS?.(meshForUi);
          renderMeshInputs?.(meshForUi);
          renderSuggestions?.(meshForUi);
          updateLastUpdated?.();
          resetMeshScratch?.();
        }

        // ===== PROBE COMPLETION LATCH =====
        if (probeLatch) {
          if (out.includes('//action:notification Settings Stored') ||
              /Bilinear Leveling Grid:/i.test(out)) {
            try { probeLatch.resolve?.(); } finally { probeLatch = null; }
          }
        }

        // ===== PID AUTOTUNE HOOKS (latched) =====
        if (/PID Autotune start/i.test(out)) {
          const isBed = /\(bed\)|\bE-?1\b|\bBED\b/i.test(out) || pidTarget === 'bed';
          const kind  = isBed ? 'bed' : 'hotend';

          setPidActive?.(kind, true);
          const t = pidTargetTemp ?? (isBed ? temps.bedTarget : temps.hotTarget) ?? '‚Äî';
          pidUiStart?.(kind, t);
          setActivity?.('PID tuning‚Ä¶', 'warn');

          // Debug start
          pidDebugStart?.(kind);

          // Reset capture latch for this session
          pidCap.kind = kind;
          pidCap.pending = true;
          pidCap.committed = false;
          pidCap.kp = pidCap.ki = pidCap.kd = null;
          pidCap.meta = {};
        }

        if (/PID Autotune finished/i.test(out)) {
          // Do NOT wipe results here; constants usually follow
          setActivity?.('PID tuning complete', 'ok');
          pidDebugEnd?.(pidCap.kind || (pidTarget === 'bed' ? 'bed' : 'hotend'), true);
          // keep pidCap.pending = true; wait for constants
        }

        if (/PID Autotune failed/i.test(out)) {
          const kind = pidCap.kind || (/\(bed\)|\bE-?1\b|\bBED\b/i.test(out) || pidTarget === 'bed' ? 'bed' : 'hotend');
          setActivity?.('PID tuning failed', 'bad');
          pidUiFinish?.(kind, false, null);
          setPidActive?.(kind, false);
          pidDebugEnd?.(kind, false);
          pidCap.pending = false;
          pidCap.kind = null;
        }

        // ===== PID DEBUG: lines we want to keep (and meta we can parse) =====
        const looksPidDebug =
          /\bbias\s*:/i.test(out) || /\bKu\s*:/i.test(out) || /\bTu\s*:/i.test(out) || RE_RULE.test(out);

        if (looksPidDebug && (pidCap.pending || pidActiveBed || pidActiveHotend || pidTarget)) {
          const knd = pidCap.kind || (pidActiveBed ? 'bed' : (pidActiveHotend ? 'hotend' : (pidTarget || 'hotend')));
          pidDebugLine?.(knd, out);

          // Gather meta (best-effort)
          const r = out.match(RE_RULE); if (r) pidCap.meta.rule = r[1];
          const b = out.match(RE_BIAS); if (b) pidCap.meta.bias = +b[1];
          const d = out.match(RE_D);    if (d) pidCap.meta.d    = +d[1];
          const mi= out.match(RE_MIN);  if (mi)pidCap.meta.min  = +mi[1];
          const ma= out.match(RE_MAX);  if (ma)pidCap.meta.max  = +ma[1];
          const ku= out.match(RE_KU);   if (ku)pidCap.meta.Ku   = +ku[1];
          const tu= out.match(RE_TU);   if (tu)pidCap.meta.Tu   = +tu[1];
        }

        // ===== PID constants capture (both styles) =====
        // Style 1: "Kp: .. Ki: .. Kd: .."
        let m = out.match(PID_K_LINE);
        if (m) {
          pidCap.kp = parseFloat(m[1]);
          pidCap.ki = parseFloat(m[2]);
          pidCap.kd = parseFloat(m[3]);
          pidCommitIfReady();
        }

        // Style 2: "#define DEFAULT_bedKx ‚Ä¶" OR "#define DEFAULT_Kx ‚Ä¶"
        let md;
        if ((md = out.match(DEF_KP))) {
          if (md[1]) pidCap.kind = 'bed'; else if (!pidCap.kind) pidCap.kind = 'hotend';
          pidCap.kp = parseFloat(md[2]);
        }
        if ((md = out.match(DEF_KI))) {
          if (md[1]) pidCap.kind = 'bed'; else if (!pidCap.kind) pidCap.kind = 'hotend';
          pidCap.ki = parseFloat(md[2]);
        }
        if ((md = out.match(DEF_KD))) {
          if (md[1]) pidCap.kind = 'bed'; else if (!pidCap.kind) pidCap.kind = 'hotend';
          pidCap.kd = parseFloat(md[2]);
        }
        pidCommitIfReady();

        // ===== OK RESOLVER =====
        if (/^ok\b/i.test(out)) {
          if (oneShotCapture && oneShotCapture.doneOnOk) {
            try { oneShotCapture.resolve?.(oneShotCapture.buf.join('\n')); }
            finally { oneShotCapture = null; }
          }

          updateLastUpdated?.();

          // ALWAYS leave capture and ALWAYS restart polling (cadence based on window.debugMode)
          if (captureMode) {
            captureMode = null;
            stopTempPolling?.();
            startTempPolling?.(); // picks 3s when Debug ON, slower when OFF
          }

          _resolveNextOk?.();
        }

        // ===== WAIT/BUSY =====
        if (/^\s*wait\s*$/i.test(out) || /\bbusy:\b/i.test(out)) {
          setActivity?.('Printer busy‚Ä¶', 'warn');
        }

        await yieldToUI();
      }
    }
  } catch (err) {
    logMsg?.('‚ö†Ô∏è Read error: ' + (err?.message || err));
    if (!isDisconnecting) await disconnectPrinter('lost');
  } finally {
    reading = false;
  }
}








//Wait plumbing
function waitForOk() {
  beginCritical();
  return new Promise((resolve, reject) => {
    const wrapResolve = () => { try { resolve(); } finally { if (pendingOk.length === 0) endCritical(); } };
    const wrapReject  = (err) => { try { reject(err); }  finally { if (pendingOk.length === 0) endCritical(); } };

    // Real serial requires a live port/writer; virtual can proceed.
    const isReal = (connKind === 'real');
    if (isReal && (!port || !writer)) { wrapReject(new Error('Disconnected')); return; }
    if (cancelStream) { wrapReject(new Error('Cancelled')); return; }

    pendingOk.push({ resolve: wrapResolve, reject: wrapReject, startedAt: performance.now() });
  });
}

function _resolveNextOk() {
  const waiter = pendingOk.shift();
  if (waiter) {
    const ms = (typeof waiter.startedAt === 'number')
      ? (performance.now() - waiter.startedAt)
      : null;

    try { waiter.resolve(); } finally {
      if (ms != null && typeof updateLatency === 'function') {
        updateLatency(ms);
      }
      // ‚úÖ avoid stale measurements on the next ok
      lastSendTs = null;

      if (pendingOk.length === 0) endCritical();
    }
  } else {
    if (lastSendTs != null) {
      const ms = performance.now() - lastSendTs;
      lastSendTs = null;                 // consume this measurement
      if (ms > 0 && isFinite(ms) && typeof updateLatency === 'function') {
        updateLatency(ms);
      }
    }
  }
}



function _rejectAllOk(err) {
  const all = pendingOk.splice(0);
  for (const w of all) {
    try { w.reject(err || new Error('Aborted')); } catch {}
  }

  // also reject an in-flight probe latch
  if (probeLatch) {
    try { probeLatch.reject(err || new Error('disconnected')); }
    finally { probeLatch = null; }
  }

  // Ensure we don't leave polling paused
  criticalDepth = 0;
  startTempPolling();
}

//Heater waiters
async function waitForHotend(target, tol = 1.0) {
  await sendCmd(`M104 S${Math.round(target)}`);
  await waitForOk().catch(()=>{});
  return new Promise(resolve => {
    let timer;
    const check = async () => {
      await sendCmd('M105', true);
      if (temps.hot != null && Math.abs(temps.hot - target) <= tol) {
        clearInterval(timer); resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}

async function waitForBed(target, tol = 1.0) {
  await sendCmd(`M140 S${Math.round(target)}`);
  await waitForOk().catch(()=>{});
  return new Promise(resolve => {
    let timer;
    const check = async () => {
      await sendCmd('M105', true);
      if (temps.bed != null && Math.abs(temps.bed - target) <= tol) {
        clearInterval(timer); resolve();
      }
    };
    timer = setInterval(check, 1000);
    check();
  });
}

/* =========================================================
   8) UI ACTIONS (PID, leveling, movement, sender, config)
========================================================= */

//PID
async function runBedPID() {
  const t = promptNumber('Enter bed PID target temp (S):', 60);
  if (t === null || !Number.isFinite(t)) return alert('Invalid temperature.');
  const c = promptCycles('bed');
  if (c === null) return;

  // NEW: remember target + start UI
  pidTargetTemp = Math.round(t);
  setPidActive('bed', true);
  pidUiStart('bed', pidTargetTemp); // shows ‚ÄúTarget: ‚Ä¶‚Äù immediately

  setActivity(`PID bed @ ${t}¬∞C (C=${c})‚Ä¶`, 'warn');
  pidTarget = 'bed';
  try {
    const useFlag = (typeof window.pidUseResults !== 'undefined' && window.pidUseResults === false) ? '' : ' U';
    await sendCmd(`M303 C${c} E-1 S${t}${useFlag}`);
    await waitForOk();
  } finally {
    // NEW: clear UI flags when the command finishes
    pidTarget = null;
    setPidActive('bed', false);
    pidTargetTemp = null;
  }
  logMsg('‚ÑπÔ∏è PID tuning can take a few minutes. Send M500 to save if required.');
}

async function runHotendPID() {
  const t = promptNumber('Enter nozzle PID target temp (S):', 220);
  if (t === null || !Number.isFinite(t)) return alert('Invalid temperature.');
  const c = promptCycles('hotend');
  if (c === null) return;

  // NEW: remember target + start UI
  pidTargetTemp = Math.round(t);
  setPidActive('hotend', true);
  pidUiStart('hotend', pidTargetTemp); // shows ‚ÄúTarget: ‚Ä¶‚Äù immediately

  setActivity(`PID hotend @ ${t}¬∞C (C=${c})‚Ä¶`, 'warn');
  pidTarget = 'hotend';
  try {
    const useFlag = (typeof window.pidUseResults !== 'undefined' && window.pidUseResults === false) ? '' : ' U';
    await sendCmd(`M303 C${c} E0 S${t}${useFlag}`);
    await waitForOk();
  } finally {
    // NEW: clear UI flags when the command finishes
    pidTarget = null;
    setPidActive('hotend', false);
    pidTargetTemp = null;
  }
  logMsg('‚ÑπÔ∏è PID tuning can take a few minutes. Send M500 to save if required.');
}

//Leveling Shortcuts
async function readMesh(){
  await sendCmd('G29 T');
  setActivity('Parsing‚Ä¶', 'warn');
}

async function reprobe(){
  await sendCmdsSequential('G28', 'G29 T');
  setActivity('Probing‚Ä¶', 'warn');
}

//Manual
function sendManual(){
  const cmd = manualCmd.value.trim();
  if (!cmd) return;
  sendCmd(cmd).catch(err => logMsg('‚ö†Ô∏è ' + (err?.message || 'Send failed')));
  manualCmd.value = '';
}

//Jog and move
async function jog(axis, dir) {
  const step = parseFloat(jogStep.value) || 1;
  const dist = (dir * step).toFixed(3);
  const feed = (axis === 'Z') ? 300 : 3000;

  try {
    // Auto-home once if needed
    if (!isHomed) {
      setActivity('Auto-homing before jog‚Ä¶', 'warn');
      await sendCmd('G28'); await waitForOk().catch(()=>{});
      isHomed = true;

      // ‚¨áÔ∏è Cool to 0 after auto-home triggered by a jog
      await coolToIdle();

      setActivity('Jogging‚Ä¶', 'warn');
    }

    // Relative move, then back to absolute
    await sendCmd('G91');                        await waitForOk().catch(()=>{});
    await sendCmd(`G1 ${axis}${dist} F${feed}`); await waitForOk().catch(()=>{});
    await sendCmd('G90');                        await waitForOk().catch(()=>{});
    setActivity('Idle');

    // Update position readout
    await sendCmd('M114', true);                 await waitForOk().catch(()=>{});
  } catch (e) {
    setActivity('Jog failed', 'bad');
    logMsg('‚ö†Ô∏è Jog error: ' + (e?.message || e));
  }
}

// Full, integrated sender with: async preview build (worker + chunked render via buildPreviewAsync),
// layer tracking, ETA, connection-tab lock, filament estimate + reservation,
// and robust UI guards.
async function streamGcode(file) {
  // --- Guards ---
  if (!(connKind === 'virtual' || writer)) {
    alert('Not connected.');
    return;
  }
  if (!file) {
    sendStatus && (sendStatus.textContent = 'No file selected');
    logMsg?.('‚ö†Ô∏è streamGcode called without a file');
    return;
  }

  // ---- Lock the "Connection & Log" tab while sending ----
  const connectTabBtn = document.getElementById('connectTab'); // your tab button/id
  if (connectTabBtn) {
    if ('disabled' in connectTabBtn) connectTabBtn.disabled = true; // real <button>/<input>
    connectTabBtn.classList?.add('locked');                        // CSS guard for non-form elts
  }

  cancelStream = false;
  let _jobSucceeded = false;
  let _filamentTicket = null;

  cancelSend && (cancelSend.disabled = true);
  hideEtaPill?.();

  sendProgress && (sendProgress.style.width = '0%');
  sendStatus   && (sendStatus.textContent   = 'Homing‚Ä¶');

  try {
    beep?.('start');
    printerBeep?.('start');
    // Send Telegram notification for start of print
    try {
      const fname = (file && file.name) ? file.name : '';
      if (typeof sendTelegramEvent === 'function') {
        sendTelegramEvent('start', fname);
      }
    } catch {
      /* silently ignore telegram errors */
    }

    // ---- Read the file text we will send ----
    const text = await file.text();

    // ---- Build the preview asynchronously (non-blocking UI) ----
    if (typeof buildPreviewAsync === 'function') {
      await buildPreviewAsync(text);
    } else if (window.GCodePreview?.loadFromTextAsync) {
      await window.GCodePreview.loadFromTextAsync(text);
    } else {
      window.GCodePreview?.loadFromText?.(text);
    }

    // ---- Filament estimate & reservation ----
    if (typeof estimateFilamentUsage === 'function') {
      const est = estimateFilamentUsage(text);  // { lengthMm }
      const mm  = Math.round(est.lengthMm || 0);
      if (mm > 0) {
        logMsg?.(`üßµ Estimated filament: ${mm} mm from file`);
        const estEl = document.getElementById('preEstFilament');
        if (estEl) estEl.textContent = `${mm} mm`;
        // Reserve from active spool; will refund on cancel/error in finally
        _filamentTicket = reserveFilamentForJob?.(mm) || null;
      } else {
        setActivity?.('Estimated filament: 0 mm (no extrusion detected)', 'warn');
      }
    } else {
      setActivity?.('Filament estimator unavailable', 'warn');
    }

    // ---- Build sendable lines + map to original source line numbers for tracking ----
    const rawLines = text.split(/\r?\n/);
    const lines = [];
    const srcNos = []; // 1-based original line numbers
    for (let i = 0; i < rawLines.length; i++) {
      const stripped = rawLines[i].replace(/;.*/, '').trim();
      if (!stripped) continue;
      lines.push(stripped);
      srcNos.push(i + 1);
    }

    if (!lines.length) {
      sendStatus && (sendStatus.textContent = 'No G-code lines found');
      return;
    }

    // ---- Octolapse layer mapping ----
    // Precompute which layer each raw G-code line belongs to, based on byte offsets
    if (window.GCodePreviewModel?.layers) {
      const layers = window.GCodePreviewModel.layers || [];
      const layerStarts = layers.map(l => l.byteStart || 0);
      const totalLayers = layerStarts.length;
      octoLayerForLine = new Array(rawLines.length).fill(totalLayers ? totalLayers - 1 : 0);
      let lIdx = 0;
      let byteSum = 0;
      for (let idx = 0; idx < rawLines.length; idx++) {
        // Add line length plus newline to approximate byte offset
        byteSum += rawLines[idx].length + 1;
        while (lIdx + 1 < layerStarts.length && byteSum >= layerStarts[lIdx + 1]) lIdx++;
        octoLayerForLine[idx] = lIdx;
      }
    } else {
      octoLayerForLine = null;
    }

    // ---- ETA precomputation ----
    const countingMask  = lines.map(isCountingLine);
    const countingTotal = countingMask.reduce((a,b)=>a+(b?1:0),0);
    const warmupCount   = Math.min(400, Math.max(50, Math.floor(countingTotal * 0.01))); // 1% (50‚Äì400)

    // EMA for time/line (s), starts after first counting line
    let emaSecPerLine = 0;
    const alpha       = 0.15;  // smoothing
    let sentCounting  = 0;
    let lastCountTs   = 0;
    let startedETA    = false;

    // ---- Home before sending ----
    logMsg?.('üè† Homing all axes (G28)‚Ä¶');
    await sendCmd('G28'); await waitForOk();

    let sent = 0;
    const total = lines.length;

    cancelSend && (cancelSend.disabled = false);
    sendStatus && (sendStatus.textContent = 'Sending‚Ä¶');
    showEtaPill?.('ETA: heating/preamble‚Ä¶', 'warn');

    for (let i = 0; i < lines.length; i++) {
      if (cancelStream) break;

      const line = lines[i];

      // Send + wait
      await sendCmd(line);
      const t0 = Date.now();
      await waitForOk();
      const t1 = Date.now();

      // ---- Advance preview to reflect this command's original line ----
      window.GCodePreview?.updateByGcodeLine?.(srcNos[i]);

      // ---- Progress ----
      sent++;
      const pct = Math.round((sent / total) * 100);
      sendProgress && (sendProgress.style.width = pct + '%');
      sendStatus   && (sendStatus.textContent = `Sent ${sent}/${total} (${pct}%)`);

      // ---- ETA: count only real "print" lines ----
      if (countingMask[i]) {
        const deltaSec = (t1 - (lastCountTs || t1)) / 1000;
        lastCountTs = t1;

        if (!startedETA) {
          startedETA = true;
          emaSecPerLine = Math.max(0.001, deltaSec);
          sentCounting = 1;
          showEtaPill?.('ETA: estimating‚Ä¶', 'warn');
        } else {
          sentCounting++;
          // Train EMA continuously
          emaSecPerLine = alpha * deltaSec + (1 - alpha) * emaSecPerLine;

          if (sentCounting >= warmupCount && countingTotal > 0) {
            const remaining    = Math.max(0, countingTotal - sentCounting);
            const remainingSec = emaSecPerLine * remaining;
            showEtaPill?.('ETA: ' + formatETA(remainingSec), 'warn');
          } else {
            showEtaPill?.(`ETA: stabilising‚Ä¶ (${sentCounting}/${warmupCount})`, 'warn');
          }
        }
      } else {
        // While still in setup/heating, keep the pill clear and honest
        if (!startedETA) showEtaPill?.('ETA: heating/preamble‚Ä¶', 'warn');
      }

      // ---- Octolapse: capture a frame when moving to a new layer ----
      if (octoActive && octoLayerForLine) {
        const rlIndex = srcNos[i] - 1;
        const layerIdx = (rlIndex >= 0 && rlIndex < octoLayerForLine.length) ? octoLayerForLine[rlIndex] : 0;
        handleOctoLayerChange(layerIdx);
      }

      // Small pacing delay to avoid flooding slower boards
      await new Promise(r => setTimeout(r, 10));
    }

    cancelSend && (cancelSend.disabled = true);

    if (cancelStream) {
      // ---- Cancel path ----
      sendStatus && (sendStatus.textContent = 'Cancelled');
      showEtaPill?.('ETA: ‚Äî', 'bad');
      beep?.('cancel');
      printerBeep?.('cancel');
      // Send Telegram notification for cancellation
      try {
        const fname = (file && file.name) ? file.name : '';
        if (typeof sendTelegramEvent === 'function') {
          sendTelegramEvent('cancel', fname);
        }
      } catch {
        /* silently ignore telegram errors */
      }

      // Mirror cleanup: heaters off + tiny lift (best-effort)
      try {
        await sendCmd('M104 S0');      // hotend off
        await waitForOk().catch(()=>{});
        await sendCmd('M140 S0');      // bed off
        await waitForOk().catch(()=>{});
        await sendCmd('G91');          // relative mode
        await waitForOk().catch(()=>{});
        await sendCmd('G1 Z0.1 F600'); // lift 0.1mm
        await waitForOk().catch(()=>{});
        await sendCmd('G90');          // back to absolute mode
        await waitForOk().catch(()=>{});
      } catch (e) {
        logMsg?.('‚ö†Ô∏è Cancel cleanup failed: ' + (e?.message || e));
      }

      exitPrintScreen?.(0, { tellHost: false });
      hideEtaPill?.();
      clearAllPidUi?.();

      // Stop Octolapse recording on cancel
      if (octoActive && _octoRecorder && (_octoRecorder.state === 'recording' || _octoRecorder.state === 'paused')) {
        try { _octoRecorder.stop(); } catch {}
      }
      octoActive = false;

    } else {
      // ---- Success path ----
      sendProgress && (sendProgress.style.width = '100%');
      sendStatus   && (sendStatus.textContent = 'Done');
      showEtaPill?.('Complete', 'ok');
      beep?.('done');
      printerBeep?.('done');
      // Send Telegram notification for completion
      try {
        const fname = (file && file.name) ? file.name : '';
        if (typeof sendTelegramEvent === 'function') {
          sendTelegramEvent('done', fname);
        }
      } catch {
        /* silently ignore telegram errors */
      }
      exitPrintScreen?.(0, { tellHost: false });
      _jobSucceeded = true; // mark success so we don't refund reservation

      // Completion actions: heaters off + lift Z by 0.1mm
      try {
        await sendCmd('M104 S0');      // hotend off
        await waitForOk();
        await sendCmd('M140 S0');      // bed off
        await waitForOk();
        await sendCmd('G91');          // relative mode
        await waitForOk();
        await sendCmd('G1 Z0.1 F600'); // lift 0.1mm
        await waitForOk();
        await sendCmd('G90');          // back to absolute mode
        await waitForOk();
      } catch (e) {
        logMsg?.('‚ö†Ô∏è Cleanup move/heater-off failed: ' + (e?.message || e));
      }

      // Stop Octolapse recording on success
      if (octoActive && _octoRecorder && (_octoRecorder.state === 'recording' || _octoRecorder.state === 'paused')) {
        try { _octoRecorder.stop(); } catch {}
      }
      octoActive = false;
    }

    setTimeout(() => hideEtaPill?.(), 2500);
  } catch (err) {
    cancelSend && (cancelSend.disabled = true);
    sendStatus && (sendStatus.textContent = 'Error during send');
    showEtaPill?.('Error', 'bad');
    beep?.('error');
    printerBeep?.('cancel');
    logMsg?.('‚ùå Send error: ' + (err?.message || err));
    setTimeout(() => hideEtaPill?.(), 2500);

    // Send Telegram notification for error/cancel
    try {
      const fname = (file && file.name) ? file.name : '';
      if (typeof sendTelegramEvent === 'function') {
        sendTelegramEvent('cancel', fname);
      }
    } catch {
      /* silently ignore telegram errors */
    }
  } finally {
    // ---- Unlock the "Connection & Log" tab ----
    if (connectTabBtn) {
      if ('disabled' in connectTabBtn) connectTabBtn.disabled = false;
      connectTabBtn.classList?.remove('locked');
    }

    // ---- Refund filament reservation on cancel/error; keep deduction on success ----
    try {
      if (!_jobSucceeded && _filamentTicket && typeof refundFilamentReservation === 'function') {
        refundFilamentReservation(_filamentTicket);
      }
    } catch (_) {}
  }
}







//Quick helpers
async function coolToIdle(opts = {}) {
  const { force = false, postSync = false } = opts;

  try {
    // If we're calling right after G29 T, let firmware settle
    if (postSync) {
      await sendCmd('M400');              // wait for all moves/ISR queue
      await waitForOk().catch(()=>{});
      await sleep(150);                   // tiny UI/EEPROM settle
    }

    // Don‚Äôt spam heat-off if already ‚Äúoff‚Äù unless forced
    const wantHot = force || ((temps.hotTarget ?? 0) > 0);
    const wantBed = force || ((temps.bedTarget ?? 0) > 0);

    if (wantHot) { await sendCmd('M104 S0'); await waitForOk().catch(()=>{}); }
    if (wantBed) { await sendCmd('M140 S0'); await waitForOk().catch(()=>{}); }
  } finally {
    clearAllPidUi();
    setActivity('Temps set to 0', 'ok');
    updateLastUpdated();
  }
}

async function markHomedAfterG28() {
  await sendCmd('G28');
  await waitForOk().catch(()=>{});
  isHomed = true;

  // Ask for current pos and learn the signature
  await sendCmd('M114', true);
  await waitForOk().catch(()=>{});
}

/* =========================================================
   9) EVENT LISTENERS
========================================================= */

primeLine.addEventListener('click', runPrimeLine);

// --- Unlock button: remove any old listeners, bind once ---
(function bindUnlockClean(){
  const oldBtn = document.getElementById('unlockTempsBtn'); // correct id
  if (!oldBtn) return;
  const newBtn = oldBtn.cloneNode(true);          // drop any old listeners
  oldBtn.parentNode.replaceChild(newBtn, oldBtn);

  newBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
    setHeaterUnlocked(!heaterUnlocked);           // ‚Üê this alone
  });
})();





//Connection
connectBtn.addEventListener('click', () => { trace('Connect button'); connectPrinter(); });

disconnectBtn.addEventListener('click', () => {
  trace('Disconnect button');
  disconnectPrinter('user');
});

//Leveling
exportMeshBtn.addEventListener('click', () => {
  const fromInputs = collectMeshFromInputs();
  if (fromInputs) {
    exportMeshAsFile(fromInputs, 'current');
    return;
  }
  const hist = JSON.parse(localStorage.getItem('levels') || '[]');
  const latest = hist.at(-1);
  if (latest && Array.isArray(latest) && latest.length === 4) {
    exportMeshAsFile(latest, 'latest');
  } else {
    alert('‚ö†Ô∏è No mesh available to export yet.');
  }
});

resetBtn.addEventListener('click', () => {
  if (!safeConfirm('Reset leveling data (grid only)?')) return;

  const cleared = clearLevelingData(); // same helper from before

  if (cleared) {
    setActivity?.('Leveling data cleared', 'ok');
    // Clear in-memory state and re-render UI
    resetMeshScratch?.();
    renderMeshInputs?.(null);
    renderSuggestions?.(null);
    updateLastUpdated?.();
  } else {
    setActivity?.('No leveling data found', 'warn');
  }
});

readMeshBtn.addEventListener('click', homeAndProbe);

document.getElementById('levelForm').addEventListener('submit', (e) => {
  e.preventDefault();
  const mesh = [];
  for (let y=0; y<4; y++) {
    const row = [];
    for (let x=0; x<4; x++) {
      const v = parseFloat(document.getElementById(`cell-${y}-${x}`).value);
      row.push(isNaN(v) ? 0 : v);
    }
    mesh.push(row);
  }
  saveMeshLS(mesh);
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  alert('‚úÖ Round submitted!');
});

//Manual
sendCmdBtn.addEventListener('click', sendManual);

manualCmd.addEventListener('input', () => { captureMode = null; });

clearLogBtn.addEventListener('click', () => { printerLog.textContent = ''; });

//Temps and fan
hotendApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(3000, parseInt(hotendSet.value) || 0)); // clamp silly inputs
  if (!guardHeaterSet('hotend', val, 'Hotend Set')) return;
  sendCmd(`M104 S${val}`);
});

hotendOff.addEventListener('click',   () => sendCmd('M104 S0'));

bedApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(3000, parseInt(bedSet.value) || 0));
  if (!guardHeaterSet('bed', val, 'Bed Set')) return;
  sendCmd(`M140 S${val}`);
});

bedOff.addEventListener('click',      () => sendCmd('M140 S0'));

fanSlider.addEventListener('input',   () => { fanVal.textContent = fanSlider.value; });

fanApply.addEventListener('click', () => {
  const val = Math.max(0, Math.min(255, parseInt(fanSlider.value)||0));
  live.lastFan255 = val;                  // ‚Üê add this
  sendCmd(`M106 S${val}`);
});

fanOff.addEventListener('click', () => {
  live.lastFan255 = 0;                    // ‚Üê add this
  sendCmd('M107');
});

//Movement
homeAll.addEventListener('click', async () => {
  try {
    setActivity('Homing‚Ä¶', 'warn');
    await sendCmd('G28'); await waitForOk().catch(()=>{});
    isHomed = true; // <-- mark homed
    await sendCmd('M104 S0'); await waitForOk().catch(()=>{});
    await sendCmd('M140 S0'); await waitForOk().catch(()=>{});
    setActivity('Homed & cooled', 'ok');
    updateLastUpdated();
  } catch (e) {
    setActivity('Home failed', 'bad');
    logMsg('‚ö†Ô∏è Home error: ' + (e?.message || e));
  }
});

disableMotors.addEventListener('click', () => sendCmd('M84'));

xMinus.addEventListener('click', () => jog('X', -1));

xPlus .addEventListener('click', () => jog('X', +1));

yMinus.addEventListener('click', () => jog('Y', -1));

yPlus .addEventListener('click', () => jog('Y', +1));

zMinus.addEventListener('click', () => jog('Z', -1));

zPlus .addEventListener('click', () => jog('Z', +1));

parkHead.addEventListener('click', () =>sendCmdsSequential('G90', 'G1 X0 Y0 Z10 F3000')
);

//EEPROM and Diag


// Maintenance
preheatPLA .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S200', 'M140 S60');
});
preheatPETG.addEventListener('click', async () => {
  await sendCmdsSequential('M104 S240', 'M140 S80');
});
preheatABS .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S250', 'M140 S100');
});
cooldown   .addEventListener('click', async () => {
  await sendCmdsSequential('M104 S0', 'M140 S0');
});

loadFil.addEventListener('click', async () => {
  const mm   = parseFloat(safePrompt('How many mm to LOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(safePrompt('Hotend temp for load (¬∞C)?', '200'));
if (!guardHeaterSet('hotend', temp, 'Filament Load')) return;
  if (!Number.isFinite(temp) || temp <= 0) return;
  try {
    await sendCmd('G28');                    await waitForOk().catch(()=>{});
    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});
    await waitForHotend(temp, 1.0).catch(()=>{});
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{});
    await sendCmd('M82');                    await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});
    sendStatus.textContent = 'Filament load complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Load failed';
    console.error(e);
  }
});

unloadFil.addEventListener('click', async () => {
  const mm   = parseFloat(safePrompt('How many mm to UNLOAD?', '60'));
  if (!Number.isFinite(mm) || mm <= 0) return;
  const temp = parseFloat(safePrompt('Hotend temp for unload (¬∞C)?', '200'));
if (!guardHeaterSet('hotend', temp, 'Filament Unload')) return;
  if (!Number.isFinite(temp) || temp <= 0) return;
  try {
    await sendCmd('G28');                    await waitForOk().catch(()=>{});
    await sendCmd('G90');                    await waitForOk().catch(()=>{});
    await sendCmd('G1 Z110 F300');           await waitForOk().catch(()=>{});
    await waitForHotend(temp, 1.0).catch(()=>{});
    await sendCmd('M83');                    await waitForOk().catch(()=>{});
    await sendCmd(`G1 E-${mm.toFixed(2)} F200`); await waitForOk().catch(()=>{});
    await sendCmd('M400');                   await waitForOk().catch(()=>{});
    await sendCmd('M82');                    await waitForOk().catch(()=>{});
    await sendCmd('M104 S0');                await waitForOk().catch(()=>{});
    await sendCmd('M140 S0');                await waitForOk().catch(()=>{});
    sendStatus.textContent = 'Filament unload complete (cooled)';
  } catch (e) {
    sendStatus.textContent = 'Unload failed';
    console.error(e);
  }
});

//Sender
gcodeFile.addEventListener('change', () => {
  const connected = (connKind === 'virtual') || !!writer;
  sendGcode.disabled = !gcodeFile.files.length || !connected;
});

sendGcode.addEventListener('click', (e) => {
  e.preventDefault();
  e.stopImmediatePropagation();

  const file = gcodeFile?.files?.[0];
  if (!file) { gcodeFile.click(); return; }

  if (sessionStorage.getItem('skipPreflight') === '1') {
    streamGcode(file);
    return;
  }
  openPreflight(file);
});

cancelSend.addEventListener('click', async () => {
  if (sendStatus) sendStatus.textContent = 'Cancelling‚Ä¶';
  cancelSend.disabled = true;
  showEtaPill('Cancelling‚Ä¶', 'warn');

  cancelStream = true;
  _rejectAllOk(new Error('Cancelled'));

  try {
    await sendCmd('M400');      await waitForOk().catch(() => {}); // finish moves
    await sendCmd('M104 S0');   await waitForOk().catch(() => {});
    await sendCmd('M140 S0');   await waitForOk().catch(() => {});
    await sendCmd('M106 S0');   await waitForOk().catch(() => {});

    // Small retract
    await sendCmd('M83');       await waitForOk().catch(() => {}); 
    await sendCmd('G1 E-1.5 F1800'); await waitForOk().catch(() => {});

    // Z-hop (lift a fraction before XY)
    await sendCmd('G91');       await waitForOk().catch(() => {}); 
    await sendCmd('G1 Z0.6 F1200');  await waitForOk().catch(() => {});
    await sendCmd('G90');       await waitForOk().catch(() => {});

    // Park move
    await sendCmd('G1 X0 Y0 F12000'); await waitForOk().catch(() => {});
    await sendCmd('G1 Z10 F3000');    await waitForOk().catch(() => {});
  } finally {
    exitPrintScreen(0, { tellHost: false });
    hideEtaPill();
    clearAllPidUi();
    cancelStream = false;
  }
});


//PID Tab
bedPidBtn.addEventListener('click', runBedPID);

hotendPidBtn.addEventListener('click', runHotendPID);

//APP lifecycle
window.addEventListener('unload', () => {
  if (postPrintTimer) clearTimeout(postPrintTimer);
});

document.addEventListener('DOMContentLoaded', () => {
  const aboutBtn = document.querySelector('#tabButtons button[data-tab="aboutTab"]');
  const allTabBtns = Array.from(document.querySelectorAll('#tabButtons button'));


  if (!aboutBtn || !eeOverlay || !eeModal || !eeClose || !eeBody) {
    console.warn('[EE] Modal wiring skipped (missing elements).');
    return;
  }

  // Any other tab click resets
  allTabBtns.forEach(btn => {
    if (btn !== aboutBtn) btn.addEventListener('click', resetStreak);
  });

  aboutBtn.addEventListener('click', () => {
    streak += 1;
    if (streak >= 5) {
      openEasterEgg();
      streak = 0;
    }
  });

    allTabBtns.forEach(btn => {
    if (btn !== aboutBtn) btn.addEventListener('click', () => { streak = 0; });
  });

  // Close handlers
  eeClose.addEventListener('click', closeEasterEgg);
  eeOverlay.addEventListener('click', closeEasterEgg);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && eeModal.style.display !== 'none') closeEasterEgg();
  });
});


const preBody  = document.getElementById('preBody');
const preStart = document.getElementById('preStart');
if (preBody && preStart) {
  preBody.addEventListener('change', (e) => {
    if (!(e.target instanceof HTMLInputElement) || !e.target.classList.contains('preChk')) return;
    const all = Array.from(preBody.querySelectorAll('.preChk')).every(c => c.checked);
    preStart.disabled = !all;
  });
}


//Selectors and toggles
if (levelPrinterSelect) {
  const saved = localStorage.getItem('levelPrinterChoice');
  if (saved) levelPrinterSelect.value = saved;

  levelPrinterSelect.addEventListener('change', () => {
    localStorage.setItem('levelPrinterChoice', levelPrinterSelect.value);
    updateLevelView();
  });
}



if (debugToggle) {
  debugToggle.checked = !!window.debugMode;
debugToggle.addEventListener('change', () => {
  window.debugMode = debugToggle.checked;
  localStorage.setItem('debugMode', JSON.stringify(window.debugMode));
  // restart poller at the appropriate interval
  stopTempPolling();
  startTempPolling(); // picks 3000ms when ON, 7000ms when OFF
});
}

if (virtualToggle) {
  virtualMode = JSON.parse(localStorage.getItem('virtualMode') || 'false');
  virtualToggle.checked = virtualMode;
  virtualToggle.addEventListener('change', () => {
    virtualMode = virtualToggle.checked;
    localStorage.setItem('virtualMode', JSON.stringify(virtualMode));
  });
}

(function(){
  // Build modal once
  let overlay=document.getElementById('helpOverlay');
  if(!overlay){overlay=document.createElement('div');overlay.id='helpOverlay';document.body.appendChild(overlay);}
  let modal=document.getElementById('helpModal');
  if(!modal){
    modal=document.createElement('div');modal.id='helpModal';modal.setAttribute('role','dialog');modal.setAttribute('aria-modal','true');
    modal.innerHTML=`
      <div id="helpCard">
        <div id="helpHead">
          <h3 id="helpTitle">Help</h3>
          <div id="helpActions">
            <input id="helpSearch" type="search" placeholder="Search in help‚Ä¶">
            <button id="helpClose" type="button" aria-label="Close">Close</button>
          </div>
        </div>
        <div id="helpBodyWrap"><div id="helpBody" class="help-body"></div></div>
      </div>`;
    document.body.appendChild(modal);
  }

  const titleEl  = document.getElementById('helpTitle');
  const searchEl = document.getElementById('helpSearch');
  const closeBtn = document.getElementById('helpClose');
  const bodyEl   = document.getElementById('helpBody');

  // Mini Help engine
  const registry=new Map();
  const state={open:false, activeTab:'default', q:''};

  function register(id,{title,html}){ registry.set(id,{title,html,rawHtml:html}); }
  function setActiveTab(id){ state.activeTab = registry.has(id)?id:'default'; if(state.open) render(); }
  function highlight(html,q){ if(!q) return html;
    const esc=s=>s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
    return html.replace(new RegExp(`(${esc(q)})`,'gi'),'<mark>$1</mark>');
  }
  function render(){
    const page=registry.get(state.activeTab)||registry.get('default')||{title:'Help',html:'<p>No help yet.</p>'};
    titleEl.textContent=page.title;
    bodyEl.innerHTML = state.q?highlight(page.rawHtml||page.html,state.q):page.html;
  }

  function open(){ state.open=true; overlay.classList.add('open'); modal.classList.add('open'); try{searchEl.focus();}catch{}; render(); }
  function close(){ state.open=false; overlay.classList.remove('open'); modal.classList.remove('open'); }
  function toggle(){ state.open?close():open(); }

  window.Help={register,setActiveTab,open,close,toggle,setHTML:(id,title,html)=>{register(id,{title,html}); if(state.activeTab===id&&state.open) render();}};

  // Close wiring (capture so nothing blocks it)
  overlay.addEventListener('click',e=>{e.stopImmediatePropagation();close();},{capture:true});
  closeBtn.addEventListener('click',e=>{e.preventDefault();e.stopImmediatePropagation();close();},{capture:true});
  document.addEventListener('keydown',e=>{ if(e.key==='Escape'&&modal.classList.contains('open')){e.stopImmediatePropagation();close();}}, {capture:true});
  searchEl.addEventListener('input',()=>{ state.q=searchEl.value.trim(); render(); });

  // Keep Help button from switching tabs
  (function isolateHelpButton(){
    const bar=document.getElementById('tabButtons');
    const help=document.getElementById('helpToggleBtn');
    if(!bar||!help) return;
    bar.addEventListener('click',(e)=>{ if(e.target===help||help.contains(e.target)){ e.stopImmediatePropagation(); e.preventDefault(); toggle(); }}, true);
    help.addEventListener('click',(e)=>{ e.stopPropagation(); e.preventDefault(); toggle(); });
  })();

  // Auto-sync to your active tab
  (function wireTabs(){
    const bar=document.getElementById('tabButtons');
    if(!bar) return;
    const tabs = Array.from(bar.querySelectorAll('button[data-tab]'));
    function current(){ const btn=tabs.find(b=>b.classList.contains('active'))||tabs[0]; return btn?.dataset.tab||'connectTab'; }
    setActiveTab(current());
    tabs.forEach(b=>b.addEventListener('click',()=>requestAnimationFrame(()=>setActiveTab(current()))));
    new MutationObserver(()=>setActiveTab(current())).observe(bar,{attributes:true,subtree:true,attributeFilter:['class']});
  })();

  // Default + tab pages
  register('default',{title:'Help',html:'<p>Select a tab to see contextual help. Toggle with <kbd>F1</kbd> or <kbd>?</kbd>.</p>'});
// 1) Connection & Log
Help.register('connectTab', {
  title: 'Connection & Log',
  html: `
    <p>Connect to your printer (USB/Serial or Web Serial) and monitor live firmware output.</p>

    <h4>Workflow</h4>
    <ol>
      <li>Select <strong>Port</strong> ‚Üí pick your device (often ‚ÄúUSB-Serial‚Äù, ‚ÄúCH340‚Äù, ‚ÄúSilicon Labs‚Äù).</li>
      <li>Pick <strong>Baud</strong> (115200 or 250000 are most common).</li>
      <li>Click <strong>Connect</strong>. You should see a banner line (e.g., Marlin/Klipper) in the log.</li>
      <li>Use the <strong>Manual G-code</strong> box to send quick commands (e.g., <code>M115</code>, <code>M503</code>).</li>
    </ol>

    <h4>Useful Commands</h4>
    <ul>
      <li><code>M115</code> ‚Äî firmware info; <code>M503</code> ‚Äî dump settings; <code>M112</code> ‚Äî emergency stop.</li>
      <li><code>G28</code> ‚Äî home axes; <code>M105</code> ‚Äî read temps (polled periodically by the UI).</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>If connect fails: try a different cable/port, or close other apps that hold the port (e.g., PrusaSlicer/OctoPrint).</li>
      <li>Toggle <strong>Echo/Debug</strong> in the UI to see more parsing detail.</li>
      <li>‚ÄúVirtual printer‚Äù mode lets you test the UI without hardware.</li>
    </ul>
  `
});

// 2) Leveling
Help.register('levelTab', {
  title: 'Leveling',
  html: `
    <p>Probe a mesh, evaluate flatness, and optionally get screw-turn guidance.</p>

    <h4>Before You Start</h4>
    <ul>
      <li>Heat the bed/nozzle to normal print temps (flatness changes with heat).</li>
      <li>Make sure the nozzle is clean; remove filament blobs.</li>
    </ul>

    <h4>Procedure</h4>
    <ol>
      <li><strong>Home</strong> (<code>G28</code>).</li>
      <li><strong>Probe mesh</strong> (e.g., <code>G29 T</code> in Marlin) via the UI‚Äôs button.</li>
      <li>Inspect the heatmap: aim for range ‚â§ <code>0.02‚Äì0.05 mm</code> for best first-layers.</li>
      <li>Use the <strong>screw hints</strong> panel (if your bed has manual screws). Turn little-by-little, then re-probe.</li>
    </ol>

    <h4>Common Tweaks</h4>
    <ul>
      <li><code>M851 Z</code> ‚Äî set Z-offset; <code>M500</code> ‚Äî save.</li>
      <li>On printers with mesh leveling stored in EEPROM: <code>M420 S1</code> enables saved mesh after homing.</li>
    </ul>

    <h4>Troubleshooting</h4>
    <ul>
      <li>Probe crashes or misses points ‚Üí check Z-min/probe wiring and homing direction.</li>
      <li>Mesh looks ‚Äútilted‚Äù ‚Üí ensure X/Y gantry is square and belts are tensioned.</li>
    </ul>
  `
});

// 3) PID Tuning
Help.register('pidTab', {
  title: 'PID Tuning',
  html: `
    <p>Autotune heaters to reduce overshoot and oscillation.</p>

    <h4>Quick Start</h4>
    <ol>
      <li>Hotend autotune: <code>M303 E0 S200 C8</code> (adjust temp for your material).</li>
      <li>Bed autotune: <code>M303 E-1 S60 C8</code>.</li>
      <li>Apply results with <code>M301</code> (hotend) / <code>M304</code> (bed), then <code>M500</code> to save.</li>
    </ol>

    <h4>Targets</h4>
    <ul>
      <li>PLA ~200 ¬∞C, PETG ~235 ¬∞C, ABS ~245 ¬∞C (choose your typical print temp).</li>
      <li>Bed: PLA ~60 ¬∞C, PETG ~80 ¬∞C, ABS ~100 ¬∞C.</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>Run fans as you would during printing to get accurate results.</li>
      <li>Verify by plotting a small print: overshoot ¬±3‚Äì5 ¬∞C or less is fine.</li>
    </ul>
  `
});

// 4) Temperature & Fan
Help.register('tempTab', {
  title: 'Temperature & Fan',
  html: `
    <p>Set targets and monitor live temperatures & fans.</p>

    <h4>Controls</h4>
    <ul>
      <li>Hotend: <code>M104 S&lt;temp&gt;</code> ¬∑ Bed: <code>M140 S&lt;temp&gt;</code> ¬∑ Cooldown: set S0 or use the UI‚Äôs Off buttons.</li>
      <li>Part fan: <code>M106 S0‚Äì255</code>, Off: <code>M107</code>. Some firmwares use 0‚Äì100% scales in UI; values are converted.</li>
    </ul>

    <h4>Graph</h4>
    <ul>
      <li>Temp polling via <code>M105</code> (interval shown near the chart).</li>
      <li>Hover for exact readings; bed/nozzle lines match your theme.</li>
    </ul>

    <h4>Safety</h4>
    <ul>
      <li>Never leave heaters unattended. If temps run away, hit <strong>Emergency Stop</strong> (<code>M112</code>).</li>
    </ul>
  `
});

// 5) Movement & Axes
Help.register('moveTab', {
  title: 'Movement & Axes',
  html: `
    <p>Home, jog, and park axes for setup and maintenance.</p>

    <h4>Basics</h4>
    <ul>
      <li><strong>Home</strong> all or per-axis (<code>G28</code>).</li>
      <li><strong>Jog</strong> X/Y/Z by 0.1/1/10 mm; adjust feedrate if offered.</li>
      <li><strong>Park</strong> positions the tool for easy access (configurable in UI).</li>
    </ul>

    <h4>Hand Moves</h4>
    <ul>
      <li><code>M84</code> disables steppers (careful: the tool can fall if Z isn‚Äôt supported).</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>If moves are inverted, check motor direction in firmware or swap connectors (power off!).</li>
      <li>Binding or missed steps ‚Üí check belt tension, pulley grub screws, and rails.</li>
    </ul>
  `
});

// 6) EEPROM / Config
Help.register('eepromTab', {
  title: 'EEPROM / Config',
  html: `
    <p>View and edit key motion/thermal settings. Parse <code>M503</code> output into readable fields.</p>

    <h4>Key Parameters</h4>
    <ul>
      <li><strong>Steps/mm</strong> <code>M92</code> ¬∑ <strong>Max feedrate</strong> <code>M203</code> ¬∑ <strong>Accel</strong> <code>M201/M204</code>.</li>
      <li><strong>PID</strong> hotend <code>M301</code> ¬∑ bed <code>M304</code> ¬∑ <strong>Z-probe offset</strong> <code>M851</code>.</li>
      <li><strong>Retract</strong> <code>M207</code> ¬∑ <strong>Recover</strong> <code>M208</code> ¬∑ <strong>Auto-retract</strong> <code>M209</code>.</li>
    </ul>

    <h4>Workflow</h4>
    <ol>
      <li>Click <strong>Read</strong> to fetch current values (<code>M503</code>).</li>
      <li>Adjust fields; the UI will generate the right commands.</li>
      <li>Click <strong>Apply</strong> to send, then <strong>Save</strong> (<code>M500</code>).</li>
    </ol>

    <h4>Notes</h4>
    <ul>
      <li>Some boards/firmwares disable EEPROM ‚Äî saving may be unavailable.</li>
      <li>Always save your current config before big changes (export button in UI).</li>
    </ul>
  `
});

// 7) Maintenance
Help.register('maintTab', {
  title: 'Maintenance',
  html: `
    <p>One-click macros and a simple logbook to track upkeep.</p>

    <h4>Macros</h4>
    <ul>
      <li><strong>Preheat</strong> PLA/PETG/ABS: sets bed/nozzle presets and waits.</li>
      <li><strong>Cooldown</strong>: turns heaters off and fans as configured.</li>
      <li><strong>Load/Unload</strong>: heats and runs controlled extrusions/retractions.</li>
    </ul>

    <h4>Logbook</h4>
    <ul>
      <li>Record nozzle swaps, lubrication, belt tensioning, cleanings.</li>
      <li>Export or clear entries as needed.</li>
    </ul>

    <h4>Tips</h4>
    <ul>
      <li>Run a purge after swapping materials (esp. PLA ‚Üî PETG/ABS).</li>
      <li>Lubricate Z lead screws lightly; avoid belts and idlers.</li>
    </ul>
  `
});

// 8) Filament
Help.register('filamentTab', {
  title: 'Filament',
  html: `
    <p>Track spools, presets, and estimated remaining material.</p>

    <h4>Spools</h4>
    <ul>
      <li>Store brand, material, color, diameter, density, tare, capacity, and price.</li>
      <li>Mark an <strong>active spool</strong> and deduct usage after prints.</li>
      <li>Quick-filter by material or ‚ÄúWith remaining only‚Äù.</li>
    </ul>

    <h4>Presets</h4>
    <ul>
      <li>Per-material default temps (nozzle/bed) and fan profiles.</li>
    </ul>

    <h4>Labels</h4>
    <ul>
      <li>Generate a simple shelf label with key info and QR if available.</li>
    </ul>
  `
});

// 9) Diagnostics
Help.register('diagTab', {
  title: 'Diagnostics',
  html: `
    <p>Inspect firmware and driver status.</p>

    <h4>Quick Commands</h4>
    <ul>
      <li><code>M115</code> ‚Äî firmware banner, capabilities.</li>
      <li><code>M122</code> ‚Äî TMC driver report (if supported): RMS current, microsteps, stealth/spread, errors.</li>
    </ul>

    <h4>Checks</h4>
    <ul>
      <li>Endstops/probe: trigger by hand and read status.</li>
      <li>Thermistors: look for unrealistic temps or ‚Äúdef‚Äù/‚Äúopen‚Äù errors.</li>
    </ul>

    <h4>Troubleshooting</h4>
    <ul>
      <li>Skipped steps ‚Üí verify motor current, belt tension, pulley grub screws.</li>
      <li>Thermal runaway ‚Üí PID tune, inspect wiring, ensure fans work.</li>
    </ul>
  `
});

// 10) G-code Sender
Help.register('senderTab', {
  title: 'G-code Sender',
  html: `
    <p>Send single commands or stream full files with a live 2D preview.</p>

    <h4>Pre-flight</h4>
    <ul>
      <li>Check temps and homing; the UI can enforce guardrails (e.g., refuse to print cold/unhomed).</li>
      <li>Optional: run a skirt or prime line macro.</li>
    </ul>

    <h4>While Printing</h4>
    <ul>
      <li>Preview supports <code>G0/G1</code>, absolute/relative (<code>G90/G91</code>), extrusion modes (<code>M82/M83</code>), and common layer comments.</li>
      <li>Scrub layers; toggle travel (dashed) to declutter.</li>
      <li>Live highlight follows the current layer via <code>GCodePreview.updateCurrentZ(z)</code> or <code>updateByGcodeLine(n)</code>.</li>
    </ul>

    <h4>Recovery</h4>
    <ul>
      <li>Pause/Resume sends <code>M25/M24</code> (or equivalent); consult firmware if different.</li>
      <li>Emergency stop: <code>M112</code>.</li>
    </ul>
  `
});

  // Keyboard toggle (F1 / ?)
  document.addEventListener('keydown',(e)=>{
    if(e.key==='F1' || e.key==='?' || (e.shiftKey && e.key==='/')){ e.preventDefault(); toggle(); }
  });
})();

/* =========================================================
   10) INIT (runs once)
========================================================= */
(function init() {
  window.debugMode = JSON.parse(localStorage.getItem('debugMode') ?? 'false');
  const mesh = loadMeshLS();
  renderMeshInputs(mesh);
  renderSuggestions(mesh);
  updateLastUpdated();
  setConnected(false);
  setOfflinePills();
  updateLevelView();
  initPrinterName();
  updateUnlockUi();
  restorePrevPidFromStorage();
})();
</script>
</body>
</html>
